{"pages":[{"title":"关于维基","date":"2021-05-23T12:08:45.167Z","path":"about/index.html","text":"小白维基的由来「维基」这个概念在我脑海中最早形成的具体形象是「库」，最早在看一篇文章讲某位作家（还是记者来着）看完书后都会将书「撕碎」，把碎片按照自己制定好的分类区分开来，如此整理归类以便之后查阅使用。 最终影响我把这个东西实现出来的是博友 三无计划 的一篇博文：为什么每个人都应该有自己的 Wiki。 看完这篇文章没多久我就仿照他的基本配置将原本糅杂在博客中的技术类文章全部剥离出来到维基站点上，而博客站点也就只拿来写一些生活方面的规划和思考。 小白维基的配置正如我的网站介绍：语言、框架、架构，技术有关的一切都在这里。 我通过一些简单的「大类别」将所有的文章做了一个粗略的划分，而后在每次写新文章之前挑选一个『大类别』进行匹配并辅以更精确的「小类别」，最后利用 Hexo 配合 Wikitten 主题渲染，已达到按照文章分类进行分级的维基站点。 全部技术栈如下： 博客渲染：Hexo博客主题：Wikitten代码托管：GitHub数据分析：百度统计、谷歌分析 链接提交：谷歌：sitemap百度：sitemap 配合 hexo-baidu-url-submit 插件 Hexo 插件列表： 插件名称 插件功能 hexo-abbrlink 随机生成唯一 URL hexo-autonofollow 为非本站链接添加 no-follow 属性 hexo-baidu-url-submit 每次更新博客时主动推送文章链接到百度站长 hexo-generator-sitemap 自动生成 sitemap hexo-genertaor-baidu-sitemap 自动生成百度 sitemap Timeline2020-04-26开启时间线，记录维基站点变(mo)更(gai)历史 2020-04-26修改文章时效性提示样式 2020-06-26去除了一些错误显示修改了 toTop 按钮的位置实现了 sidebar TOC 组件将 sidebar 和 profile 组件进行位置互换 2021-02-05修改了站点字体和部分样式 2021-05-23修改站点目录结构和标签方式"},{"title":"Categories","date":"2021-05-23T12:08:45.167Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2021-05-23T12:08:45.167Z","path":"tags/index.html","text":""}],"posts":[{"title":"人工智能-0-概览","date":"2021-05-13T00:00:00.000Z","path":"archives/8fbb5ea2.html","text":"","tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://wiki.blanc.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"3-计算机应用技术","slug":"3-计算机科学/3-计算机应用技术","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"4-人工智能","slug":"3-计算机科学/3-计算机应用技术/4-人工智能","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/4-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"神经网络-1-概览","date":"2021-05-13T00:00:00.000Z","path":"archives/61dc3b15.html","text":"前言","tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://wiki.blanc.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"神经网络","slug":"神经网络","permalink":"https://wiki.blanc.site/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"3-计算机应用技术","slug":"3-计算机科学/3-计算机应用技术","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"4-人工智能","slug":"3-计算机科学/3-计算机应用技术/4-人工智能","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/4-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"虚拟机常见的网络模式","date":"2021-05-12T00:00:00.000Z","path":"archives/ab9fcc5d.html","text":"前言无论使用何种虚拟机管理软件都不可避免的要接触到虚拟机网络这一概念，本文整理了常见的几类网络模式： 未指定 内部模式 桥接模式 NAT 模式 主机网络模式 注：后文展示的全部图片均为便于理解的理解模型，而非拓扑图。 名词宿主机（host）：安装虚拟机软件的机器虚拟机（guest）：被虚拟机软件构建出的虚构机器 未指定 | Not Attached虚拟机有虚拟网卡但是没有链接网线。 内部模式 | Internal虚拟机与外部环境完全断开，只允许虚拟机之间互相访问。 桥接模式 | Bridge Networking桥接模式类似于在主机内部虚拟出一个交换机，通过这台交换机连接了所有（使用桥接模式的）虚拟机和（当前）宿主机。宿主机和虚拟机对于外部网络来说处于相同地位，即对于外部网络来说宿主机和虚拟机是不同主机。 NAT 模式 | Network Address Translation在 NAT 模式下，就是让虚拟机借助 NAT 功能通过宿主机所在的网络来访问公网，虚拟机和宿主机不再同一个网络中。虚拟机向外网发送的请求数据会交由 NAT 网络适配器加上「特殊标记」后并以宿主机的名义转发出去，外网返回的响应数据也是先由主机接收让后再交由 NAT 网络适配器根据「特殊标记」进行识别并转发给对应的虚拟机。 严格来说 NAT 模式又可分为：NAT 和 NAT 网络两种模式： NAT通过虚拟 NAT 设备将宿主机与虚拟机进行网络隔离，虚拟机与虚拟机也进行网络隔离，每台虚拟机单独拥有一台虚拟 NAT 设备。 NAT 网络通过虚拟 NAT 设备在宿主机和虚拟机之间进行网络隔离，虚拟机之间可以互相连通，所有虚拟机共享一台虚拟 NAT 设备。 主机网络模式 | Host-only（默认情况下）仅限于宿主机内部访问的网络，虚拟机之间相互连通，虚拟机和宿主机之间也相互连通，但虚拟机不能访问外部网络。可以通过配置使得虚拟机可以通过宿主机的网卡访问外部网络。 同一台宿主机可以创建多个 Host-only 模式的虚拟网络，处于同一个 Host-only 虚拟网络中的虚拟机可以相互通信。如果处于不同虚拟网络，则默认不能通信。 参考 猿大白：虚拟机网络模型详解，看这篇就够了（图文并茂） CWH：virtualbox 常用网络模式解释和配置 K0rz3n：VMware 使用注意事项以及三种网络模式的拓扑分析 RQ：VirtualBox 网络模式总结 喵了个咪乎：为什么内网渗透要用NAT模式","tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://wiki.blanc.site/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Shell 基础语法","date":"2021-05-09T00:00:00.000Z","path":"archives/3beb222a.html","text":"前言本文只是对 shell 脚本语言中一些常用的基础语法进行汇总整理，如果你真的想系统的学习 shell 脚本编程，这里推荐两本电子读物： The Linux Command Line-中文版 Advanced Bash-Scripting Guide-中文版 第一本相对来说更加平滑，适合零基础的人进行自学；第二本相对来说更加全面，适合有一点基础的人进行自学； 另外，强烈建议你在学习了一定 shell 语法基础之后去找一个比较完善的编码规范进行阅读并严格按照规范进行脚本编辑，这里我个人推荐 Google Shell 风格指南。 无论是大的项目脚本还是小的工具脚本，严格的按照一个成熟的编码规范进行编辑能够帮助我们（在前期）更好的规划脚本以及（在后期）更快的 DEBUG。 注：本文中所有测试代码均为 zsh 输出结果注2：本文中所有测试代码均以 Google Shell 风格指南 作为编码规范 变量相关变量命名 定义变量时不需要加美元符号（$）； 变量名和等号之间不能有空格（分隔符）； 命名只能使用英文、数字和下划线且首个字符不能是数字； 不能使用关键字，可以使用 bash -c help 命令查看关键字； 使用变量使用一个已经定义的变量只需要在变量名前加美元符号（$）即可，变量名两边的花括号（{}）可加可不加。 123test_name=\"test\"echo $test_nameecho $&#123;test_name&#125; 注意无论您是否选择在变量名两边加入花括号请保持上下文编码规范的一致性。 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 删除变量可以使用 unset 命令删除变量，被删除的变量不能再次使用，unset 不能删除只读变量。 变量类型shell 中存在三类变量： 局部变量：在脚本或命令中定义的变量，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量； 环境变量：所有程序（包括 shell 启动的程序）都能访问的变量，有些程序需要环境变量来保证正常运行； shell 变量：由 shell 程序设定的特殊变量，有一部分是环境变量、一部分是局部变量，这些变量保证了 shell 程序的正常运行； 数组相关1234567891011121314151617181920212223# 定义格式：array_name=(value1 value2 ... valuen)a=1my_array=(\"test\" 2 \"abc\" $&#123;a&#125;)echo $&#123;my_array[0]&#125; # testecho $&#123;my_array[1]&#125; # 2echo $&#123;my_array[2]&#125; # abcecho $&#123;my_array[3]&#125; # 1echo $&#123;my_array[*]&#125; # test 2 abc 1 输出数组全部元素echo $&#123;my_array[@]&#125; # test 2 abc 1 输出数组全部元素echo $&#123;#my_array&#125; # 4 输出数组长度# 遍历数组for i in $&#123;my_array[*]&#125;; do echo $&#123;i&#125;donefor i in $&#123;my_array[@]&#125;; do echo $&#123;i&#125;donefor (( i = 0; i &lt; $&#123;#my_array&#125;; i++ )) do echo $&#123;my_array[i]&#125;done 注：这里仅罗列了集中常见用法，如果想要了解更多数组操作可以查看 余子越：shell数组与字典总结；注2：该博文给出的特性本人并未全部测试，请先测试确定有效后再使用； 字典相关本地测试失败，暂不整理。 字符串相关字符串变量定义时的单引号和双引号123456first_name=\"test\"last_name1=\"test1 $&#123;first_name&#125;\"last_name2='test1 $&#123;first_name&#125;'echo $&#123;last_name1&#125; # test1 testecho $&#123;last_name2&#125; # test1 $&#123;first_name&#125; 在定义 shell 字符串变量时如果使用单引号包裹变量内容，则被包裹的部分会原样输出，如果使用双引号包裹变量内容，则在输出变量内容时会先解析变量内的变量、命令和转义字符。 字符串拼接123456789101112your_name=\"test\"# 单引号拼接welcome1='hello, $&#123;your_name&#125; !'welcome2='hello, '$&#123;your_name&#125;' !'echo $&#123;welcome1&#125; # hello, $&#123;your_name&#125; !echo $&#123;welcome2&#125; # hello, test !# 双引号拼接welcome3=\"hello, $&#123;your_name&#125; !\"welcome4=\"hello, \"$&#123;your_name&#125;\" !\"echo $&#123;welcome3&#125; # hello, test !echo $&#123;welcome4&#125; # hello, test ! 以上句式中：welcome1 属于单引号字符串无法解析变量，welcome2 属于字符串拼接，welcome3 属于双引号解析字符串变量，welcome4 属于字符串拼接。 字符串操作1234567891011string=\"abcdefghijklmn\"string2=\"这是一段中文字符串\"# 输出字符串长度echo $&#123;#string&#125; # 14echo $&#123;#string1&#125; # 0# 截取字符串，从下表 1 截取到下表 4echo $&#123;string:1:4&#125; # bcdeecho $&#123;string1:1:4&#125; # 无输出echo $&#123;string1&#125; # 无输出# 在我的测试系统环境下无法对中文字符串进行操作# 中文字符串操作具体逻辑我没有详细查询，感兴趣可以自己查询一下，估计是字符集的问题 基础语法相关特殊变量12345678910111213141516171819202122232425# $&#123;n&#125;：$0 表示命令本身，$1-$9 代表第 1 到第 9 个参数，10 以上加花括号，个人建议全部加花括号# $&#123;*&#125;：运行当前脚本时的所有参数，且把所有参数看做一个整体# $&#123;@&#125;：运行当前脚本时的所有参数，且把每个参数区别对待# $&#123;#&#125;：运行当前脚本时的所有参数个数# $&#123;$&#125;：当前进程 PID# $&#123;!&#125;：在当前脚本中后台运行的最后一个进程 PID# $&#123;?&#125;：最后一次执行的命令返回状态，0 为执行正确，非 0 为执行错误# 测试文件名称：test.sh# 测试命令 ./test.sh 1 2 3 4 5 6 7 8 9# 同目录下有一个输出 hello, world 的 hello.sh 文件echo $(dirname $&#123;0&#125;) # .echo $&#123;0&#125; # ./test.shecho $&#123;1&#125; # 1echo $&#123;2&#125; # 2echo $&#123;6&#125; # 6echo $&#123;99&#125; # 无输出echo $&#123;*&#125; # 1 2 3 4 5 6 7 8 9echo $&#123;@&#125; # 1 2 3 4 5 6 7 8 9echo $&#123;#&#125; # 9echo $&#123;$&#125; # 70149./hello.sh # 注意：这里不会立即输出结果echo $&#123;!&#125; # 70151echo $&#123;?&#125; # 0 # hello.sh 的输出结果 -&gt; hello, world 特殊字符# | 井号注释符。如果一行脚本的开头是#（除了#!），那么代表这一行是注释，不会被执行。 ; | 分号命令分隔符。允许在同一行内放置两条或更多的命令。 : | 冒号空命令。它在 shell 中等价于 “NOP”（即no op，空操作）与 shell 内建命令 true 有同样的效果。它本身也是 Bash 的内建命令之一，返回值是 true（0）。 如果你学过 Python 的话，它很像 Python 中的 pass（个人感觉）。 () | 单组小括号在新的子 shell （环境）里执行使用分号（;）隔开的一组命令，且最后一个命令可以不用分号。 12345# 测试文件路径 /root/test.shpwd # /root(cd /etc;pwd) # /etcpwd # /root {} | 花括号在当前 shell （环境）里执行使用分号（;）隔开的一组命令，最后一个命令也需要加分号，且左括号和第一个命令之间必须有空格（分隔符）。 代码块，又被称作内联组（inline group）。它实际上创建了一个匿名函数（anonymous function），即没有名字的函数。但是，不同于那些“标准”函数，代码块内的变量在脚本的其他部分仍旧是可见的。 Advanced Bash-Scripting Guide-中文版 123456789101112131415161718# 测试文件路径 /root/test.shpwd # /root&#123; cd /etc; pwd; &#125; # /etcpwd # /etc# 注意 &#123; cd /etc; pwd; &#125; 命令中，除了 &#123; 和 c 之间 以及 cd 和 / 之间的空格是必须的其他空格都可省略``` #### $() 和 ``二者都可用于「命令替换」，所谓命令替换与前面变量章节提到的变量替换类似，即完成区域内部的命令并将结果替换出来和当前命令行重组。```shellecho \"today is $(date +%Y-%m-%d)\" # today is 2021-05-15echo \"today is `date +%Y-%m-%d`\" # today is 2021-05-15# 执行逻辑是：先运行命令 date +%Y-%m-%d 然后将结果和原先命令所在的位置进行替换，程序执行时实际运行的是替换后的语句 比较推荐使用 $() 这种形式，理由有： 反引号（``）容易与单引号（’’）混淆； 在复合命令替换中，使用反引号（``）需要进行额外的转义 12a=`command1 \\`command2\\` `b=$(command1 $(command2)) 但是 $() 不能支持全部 shell（但 bash 中是可以用的），而反引号（``）基本上可以在所有 unix shell 中使用。 (()) 和 $(()) | 双组小括号(()) 的特性：与 let 命令类似，允许对算术表达式的扩展和求值，是 let 命令的简化形式。 (()) 单独使用时的一些作用： 123456789101112131415a=3(( b = 10 + a )) # C 语言风格变量赋值， = 前后都有空格echo $&#123;b&#125; # 13(( b-- ))echo $&#123;b&#125; # 12(( b++ ))echo $&#123;b&#125; # 13(( ++b ))echo $&#123;b&#125; # 14(( --b ))echo $&#123;b&#125; # 13(( t = b &lt; 45 ? 7 : 11 ))echo $&#123;t&#125; # 7 (()) 配合其他语句使用时的一些例子： 123456789101112131415for (( i = 0; i &lt; 5; i++)); do echo $&#123;i&#125; # 依次输出 0 1 2 3 4doneif (( 1 + 2 )); then echo \"true\" # truefiif !(( 1 - 1 )); then echo \"false\" # falsefiif (( 3 &gt; 2 )); then echo \"3 &gt; 2\" # 3 &gt; 2 在 if 语句下可以使用双圆括号直接进行数值比较fi $(()) 的作用：整数运算（不支持浮点数） 1234567891011121314151617# $(()) 中支持 + - * / % &amp; | ^ !# 此外，$(()) 还可用作不同进制的运算，但只能输出十进制结果a=1b=2c=3echo $(( a + b )) # 3echo $(( c - a )) # 2echo $(( a * c )) # 3echo $(( c / a )) # 3echo $(( c / b )) # 1 可见这里的取整方式是直接抛弃小数点后面的数echo $(( c % a )) # 0echo $(( (a + b) * c )) # 9echo $(( a &amp; b )) # 0echo $(( a | b )) # 3echo $(( a ^ b )) # 3echo $(( !a )) # 0echo $(( 16#2a )) # 42 这里是将 16 进制的 2a 转化成了十进制的 42 [] | 单组中括号在 shell 中 [ expr ] （注意：左右中括号和命令之间都有空格）等同于命令 test expr，主要用于：数值判断、文件判断和字符串判断。 test 和 [] 中可用的比较运算符只有 = 和 !=，要比较大小则只能使用 test 3 -eq 4 或 [ 3 -eq 4 ] 这种形式 数值判断 参数 功能 A -eq B 判断 A 是否等于 B A -ne B 判断 A 是否不等于 B A -gt B 判断 A 是否大于 B A -ge B 判断 A 是否大于等于 B A -lt B 判断 A 是否小于 B A -le B 判断 A 是否小于等于 B 注：A 和 B 为任意数值或数值变量 文件判断 参数 功能 -e filename 判断文件是否存在 -r filename 判断文件是否可读 -w filename 判断文件是否可写 -x filename 判断文件是否可执行 -s filename 判断文件是否存在且至少有一个字符 -d filename 判断文件是否存在且为目录文件 -f filename 判断文件是否存在且为普通文件 -c filename 判断文件是否存在且为字符型特殊文件 -b filename 判断文件是否存在且为块特殊文件 注：filename 为完整（但可以是相对也可以是绝对）文件路径或文件路径变量 字符串判断 参数 功能 stringA = stringB 判断 stringA 是否等于 stringB stringA == stringB 判断 stringA 是否等于 stringB stringA != stringB 判断 stringA 是否不等于 stringB -z stringA 判断 stringA 长度是否为零 -n stringA 判断 stringA 长度是否不为零 注：stringA 和 stringB 代表任意字符串或字符串变量 [[]] | 双组中括号[[]] 并非 shell 通用关键字，但大多数常用 shell 都支持，与 [] 相比，[[]] 更加常用。 [[]] 支持字符串的模式匹配，使用 == 操作符时还支持 shell 的正则表达式，字符串在比较的时候可以将等号右边的内容当做一个正则表达式的匹配模式，而不仅仅是一个字符串，例如 [[ hello == hell? ]] 的结果为 true，[[]] 中匹配字符串或通配符不需要引号。 在 if 语句中使用 [[]] 可以直接在判断语句中使用 &amp;&amp; || 等操作符，但在 [] 中会报错，例如 if [[ ${a} == 1 &amp;&amp; ${a} != 2 ]]，如果使用 [] 则需写成 if [ ${a} -ne 1 ] &amp;&amp; [ ${a} != 2 ] 或者 if [ ${a} -ne 1 -a ${a} != 2]。 注：在 [[]] 中使用 &lt; &gt; 是基于字符串进行判断的，例如 [[ 321 &gt; 1234 ]] 输出为真，因为按照字符串来判断，3 大于 1 在支持 [[]] 的 shell 中会把它内部的表达式当做一个单独的元素，并返回一个退出状态码（0 为真，1 为假）。 用户输入基本读取12345#!/bin/bashecho -n \"Enter your name: \" # -n 的作用是不换行read nameecho \"hello $&#123;name&#125;, welcome to my program\"exit 0 read 参数 参数 说明 -a 后面跟一个变量，该变量会被认为是一个数组，通过 read 给其赋值，默认以空格为分隔符 -d 后面跟一个标志符，作为结束的标志 -p 后面根提示信息，在输入前打印提示信息 -e 输入的时候打开自动补全功能 -n 后面跟一个数字，定义输入文本长度 -r 屏蔽 \\，如果没有该选项 \\ 会被认为是转义符，如果有的话会被认为是正常字符 -s 安静模式，输入字符时不在屏幕上显示，常用于密码输入 -t 后面跟秒数，定义输入字符的等待时间 -u 后面跟 fd，从文件描述符中读入 函数语法相关1234567891011# 基础语法格式function function_name() &#123; command(s)... [ return value ] # 用 [] 框起来表示此语句可选&#125;# 函数返回值，可以显式增加 return 语句；# 如果不加，会将最后一条命令运行结果作为返回值。# 函数在定义时无需在 function_name() 的 () 中写入具体参数，而是通过 $&#123;1&#125; $&#123;2&#125; 的形式对参数进行调用name param1 param2 param3 流程控制相关if 语句12345678# 基本语法格式if [ condition ]; then command(s)...elif [ condition ]; then command(s)...else command(s)...fi 12345if [ $&#123;1&#125; -ge 60 ]; then echo \"及格\"elif [ $&#123;1&#125; -lt 60 ]; then echo \"不及格\" fi case 语句123456789101112131415# 基本语法格式case $&#123;variable&#125; in \"condition1\") command... ;; \"condition1\") command... ;;... *) command... ;;esac 12345678910111213141516171819# 实例case $&#123;1&#125; in \"1\") echo 周一 ;; \"2\") echo 周二 ;; *) echo 其它 ;;esac# 简写case $&#123;1&#125; in \"1\") echo 周一 ;; \"2\") echo 周二 ;; *) echo 其它 ;;esac 循环语法相关循环是当循环控制条件为真时，一系列命令迭代执行的代码块。 for 循环12345678910111213my_array=(\"test\" 2 \"abc\" $&#123;a&#125;)for i in $&#123;my_array[*]&#125;; do echo $&#123;i&#125;donefor (( i = 0; i &lt; $&#123;#my_array&#125;; i++ )) do echo $&#123;my_array[i]&#125;donefor i in \"test\" 2 \"abc\" $&#123;a&#125;; do echo $&#123;i&#125;done while 循环while 循环结构会在循环顶部检测循环条件，若循环条件为真（退出状态为 0）则循环持续进行。与 for 循环 不同的是，while 循环是在不知道循环次数的情况下使用的。 123456789sum=0i=0while [[ $&#123;i&#125; -le 100 ]]; do sum=$(( sum + i )) (( i++ ))doneecho $&#123;sum&#125; # 5050 util 循环与 while 循环相反，until 循环测试其顶部的循环条件，直到其中的条件为真时停止。 123456789sum=0i=0until [[ $&#123;i&#125; -gt 100 ]]; do sum=$(( sum + i )) (( i++ ))doneecho $&#123;sum&#125; # 5050 小结本来就是想简单的整理一下 shell 的常用基础语法，没想到越整理接触到的概念越多，导致我要往这篇文章里塞入的东西也越来越多，当你读完以上文章内容，不过是接触到了 shell 语法的冰山一角。它还有很多基础语法是我没有整理到位的，也有很多进阶应用是这篇文章不应涉及但却十分重要的，毕竟 shell 非常接近 Unix 系统内核，因此如果你想要系统的学习 shell 还请根据自身情况参考我在 前言 中给出的书籍进行学习。 参考 菜鸟教程：Shell 变量 菜鸟教程：Shell test 命令 菜鸟教程：Linux read 命令 Zhongbo Wang：Shell 十三问 梦想远航：shell中的(),{}几种语法用法 Locutus：Shell编程中的用户输入处理… 知乎-小晶：掌握Shell编程，一篇就够了 Advanced Bash-Scripting Guide-中文版 chengd：Linux—shell中$(( ))、$( )、``与${ }的区别","tags":[{"name":"Shell","slug":"Shell","permalink":"https://wiki.blanc.site/tags/Shell/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Shell","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Shell","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Shell/"}]},{"title":"块加密的工作模式","date":"2021-05-08T00:00:00.000Z","path":"archives/a45966e2.html","text":"块加密块加密，也成分组加密，是一类对称密钥加密算法。它将明文分成多个等长的块，使用确定的算法和对称密钥对每组数据块分别进行加密解密。 常见的块加密算法有：DES，3DES 块密码工作模式块密码工作模式允许使用同一个分组密码密钥对多于一块的数据进行加密并保证密文的安全性。单次运行块密码算法只能加密长度等于密码分组长度的单块数据，如果需要加密的数据边长，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据还需要使用合适的填充方式将数据扩展到符合算法要求的长度。 一种工作模式描述了加密一个长明文的每一个数据块的过程，并常常使用一个被称为初始化向量的附加输入值对加密过程进行随机化提高安全性。 ECB 模式（Electronic Codebook） | 电子密码本模式最简单的工作模式，加密前根据加密块大小将明文分成若干块，之后对每个明文块进行加密，拼接后输出密文。解密同理。 优点：可并行运算、速度快、易于标准化、明文传输错误不会扩大到影响整个数据区域。 缺点： 相同的明文生成相同的密文块； 通过删除、替换密文分组可以对明文进行操作； 不能抵御重放攻击； 不能很好的隐藏数据模式； CBC 模式（Cipher-block Chaining） | 密码块链接每个明文块先与前一个密文块进行异或运算再进行加密，第一块明文与初始向量 IV 进行异或运算。 优点： 明文的数据特征不会反应在密文中； 解密过程支持并行（因为解密时已经知道每一块密文块的内容）； 缺点： 加密计算过程是串行的（因为后一次运算需要前一次运算的结果）； 如果明文在传输过程中出错，错误会向后传递； PCBC 模式（Propagating Cipher-block Chaining）| 填充密码块链接PCBC 模式是一种可以使密文中微小更改在解密时导致明文大部分错误的模式，并且在加密是也具有同样的特征。 PCBC 主要用于 Kerberos v4 和 WASTE 中。 CFB 模式（Cipher Feedback） | 密文反馈密文反馈模式是一种接近于流密码的工作模式，他不用 DES 加密明文，而是把 DES 作为一个随机数生成器，把初始向量 IV 作为种子。这样就可以从初始向量 IV 和指定 key 生成字节流，让后把明文与这个字节流进行异或。 CFB 模式每次加密明文的一个字节，因此 CFP 模式不需要对明文进行填充。 优点： 不需要填充； 解密过程支持并行运算； 缺点： 加密过程不支持并行运算； 明文中的错误会向后传递； 不能抵御重放攻击； OFB 模式（Output Feedback） | 输出反馈OFB 模式是先用块加密器生成密钥流，然后再将密钥流与明文流进行异或运算得到密文流；解密时先用块加密器生成密钥流，再将密钥流与密文流异或得到明文，由于异或操作的对称性所以加密和解密的流程是完全一样的。 可以利用输入为全 0 的 CBC 模式产生 OFB 模式的密钥流，这个过程可以利用快速 CBC 硬件实现来加速 OFB 模式的加密过程。 优点： 不需要填充； 可以提前准备加密或解密需要的密钥； 加密、解密使用相同结构； 对包含某些错误比特的密文进行解密时，只有明文中相应的比特会出错； 缺点： 不支持并行运算； 主动攻击密文的某一（些）比特时，明文中对应位置的比特也会发生变换； CTR 模式（Counter Mode）CTR 模式也被称为 ICM 模式（Integer Counter Mode，整数计数模式）或 SIC 模式（Segmented Integer Counter），与 OFB 相似，CTR 将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证长时间不产生重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。 CTR 模式的特征类似于 OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR 适合运用于多处理器的硬件上。 优点： 不需要填充； 可以事先准备加密解密需要的密钥； 加密和解密结构相同； 支持并行计算； 缺点： 主动攻击反转密文分组中的某些比特时，解密出的明文中相同位置的数据也会被反转； 参考 Pionee1eer：块加密的工作模式 张维鹏：对称加密算法之分组加密的六种工作模式… HappyDeveloper：对称加密算法的几种模式优缺点一览 维基百科：分组密码 维基百科：分组密码工作模式","tags":[{"name":"计算机安全和密码学","slug":"计算机安全和密码学","permalink":"https://wiki.blanc.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"5-计算机安全和密码学","slug":"3-计算机科学/2-计算机系统/5-计算机安全和密码学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"dmidecode 解析","date":"2021-04-05T00:00:00.000Z","path":"archives/89447a6c.html","text":"简介dmidecode 命令能够获取 Linux 系统下有关硬件方面的信息。 dmidecode 是将 DMI 数据库中的信息解码，以可读文本方式显示，由于 DMI 信息可以认为修改，因此里面的信息不一定是系统准确的信息。 dmidecode 遵循 SMBIOS/DMI 标准，其输出的信息包括 BIOS、系统、主板、处理器、内存、缓存等等。 DMI桌面管理接口（Desktop Management Interface, DMI） SMBIOS/DMI","tags":[{"name":"命令行工具","slug":"命令行工具","permalink":"https://wiki.blanc.site/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"dmidecode","slug":"dmidecode","permalink":"https://wiki.blanc.site/tags/dmidecode/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"dmidecode","slug":"2-软件使用/命令行工具/dmidecode","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/dmidecode/"}]},{"title":"Cisco IOS 系列-0-概览","date":"2021-04-05T00:00:00.000Z","path":"archives/3bd55461.html","text":"简介 Cisco Internetwork Operating System(IOS) 是思科公司为其网络设备开发的操作维护系统。用户可以通过命令行界面对网络设备进行功能设定，提供的功能大致为一下几点： 网络设备及连接端口的功能参数设置； 设置、运行网络协议和网络功能； 设备间资料传输； 安全管理； 来自维基百科：思科IOS 路由器组件及功能设备管理方法可通过多种方法访问 CLI 环境，最常用的方法有： 通过 Console 接口管理设备 通过 Telnet 或 SSH 远程管理设备 辅助端口 操作模式 用户执行模式 | 用户模式正常登陆设备 CLI 后的默认配置模式，只具备最基本的查看权限 1cisco&gt; ... 特权执行模式 | 特权模式通过用户认证后即可进入特权模式，能够查看当前设备的全部配置信息 1cisco# ... 全局配置模式在特权模式下，使用命令 config terminal 进入全局配置模式，在此模式下可配置设备全局参数，开启或关闭设备全局特性或功能；也可从此模式进入多种不同的其他子配置模式。 1cisco(config)# ... 其他配置模式line 模式 | 线路模式、行模式12345cisco(config)# line ...cisco(cofnig-line)# ...cisco(config)# line ?可以通过如上命令查看 line 模式下支持的配置选项 interface 模式 | 接口模式针对设备的某一类端口（可以针对某一具体端口也可针对某一类端口的多个端口）进行配置，例如： 12345cisco(config)# interface ...cisco(config-if)# ...cisco(config)# interface ?可以通过如上命令查看 interface 模式下支持的配置选项 router 模式 | 路由进程配置模式12345cisco(config)# router ...cisco(config-router)# ...cisco(config)# router ?可以通过如上命令查看 router 模式下支持的配置选项 使用 CLI 帮助 命令提示及补全命令提示Cisco IOS 系统的命令提示符是 ?在命令未输入完成之前输入 ? 系统会提示你所有可能的命令在命令输入完成后输入 ? 系统会提示你所有当前命令可接参数形式以及具体功能 12345678R1(config)# c?cdp class-map clock config-register cryptoR1(config)# router ?bgp .... eigrp ....ospf ....rip .... 命令补全Cisco IOS 系统的命令补全按钮是 Tab 键 命令语法检查123456789R1(config)# router ospf% Incomplete command. &#x2F;&#x2F; 命令不完整R1(config)# router ospd 1 ^% Invalid input detected at &#39;^&#39; marker. &#x2F;&#x2F; 箭头所指字符无法识别R1(config)#s% Ambiguous command: &quot;s&quot; &#x2F;&#x2F; 未知的输入 热键和快捷方式参考 维基百科：思科 IOS","tags":[{"name":"Cisco IOS","slug":"Cisco-IOS","permalink":"https://wiki.blanc.site/tags/Cisco-IOS/"},{"name":"系列文章","slug":"系列文章","permalink":"https://wiki.blanc.site/tags/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"2-操作系统","slug":"3-计算机科学/2-计算机系统/2-操作系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"CiscoIOS","slug":"3-计算机科学/2-计算机系统/2-操作系统/CiscoIOS","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CiscoIOS/"}]},{"title":"8086 处理器寻址方式","date":"2021-02-14T00:00:00.000Z","path":"archives/4940711f.html","text":"前言本文主要描述了何为寻址，寻址能力的计算以及 8086 处理器的寻址方式有哪些。 寻址什么是寻址？内存中每一个字节（8bit）都有一个对应的内存地址，CPU 去访问某一具体内存地址的过程称为寻址。 寻址能力与什么有关？CPU 的寻址能力一般使用寻址空间来表示，寻址空间的大小决定了 CPU 可支持的最大内存容量，以字节为单位。寻址空间的大小由地址总线的地址寄存器宽度（位数）决定，假设地址总线位数为 N 位，则寻址空间为 2 的 N 次方字节（因为计算机使用的是二进制所以是 2 的 N 次方）。 特殊的 8086 处理器8086 处理器有 20 位地址总线，可传送 20 位的地址，寻址空间为 1M。 而 8086 处理器是 16 位结构的处理器即 8086 内部的寄存器位数为 16 位，如果按照这个数据处理能力 8086 只能发送出 16 位的地址，表现出的寻址能力只有 64 KB。 为了解决上述问题，在 8086 处理器内部采用了一种使用两个 16 位地址（段地址：偏移地址）合成一个 20 位物理地址的方案。 具体计算公式为：物理地址 = 段地址左移四位 + 偏移地址 指令在汇编语言中，一般的指令格式为：指令代码 目的操作数,源操作数 目的操作数和源操作数统称为操作数，而寻址方式的主要表现形式就是体现在两个操作数的表现形式上 8086 处理器的寻址方式8086 处理器有七种基本寻址方式： 寄存器寻址指令执行时，操作数位于寄存器中，可以直接从寄存器中获取。 123mov ax,cx ; 此条指令中目的操作数和源操作数使用的都是寄存器寻址add bx,0xf000 ; 此条指令中目的操作数使用的是寄存器寻址，源操作数使用的是后面要介绍的直接寻址inc dx ; 这是一条比较特殊的指令，它有目的操作数，这里使用的是寄存器寻址 立即寻址立即寻址又称为立即数寻址，指的是操作数为立即数的寻址方式。 所谓立即数指的是直接包含在指令中且紧跟在操作码后可以立即从指令中获取的操作数。 在立即寻址中立即数可以是 8位的，也可以是 16位的（注意我们的大前提是在 8086 处理器下）。这种寻址方式主要用于给寄存器或存储单元赋初始值，立即寻址是这七种基本寻址方式中速度最快的寻址方式。 注：在实例代码中会有一个特殊的立即寻址例子。 12mov ax,oxf000 ; 此条指令中目的操作数使用的是寄存器寻址，源操作数采用的是立即寻址mov ax,label_a ; 注意此条指令的源操作数，它采用的也是立即寻址，这里的 &#96;label_a&#96; 虽然是一个标号但是标号是数值的等价形式，它代表了所在位置的汇编地址，在编译阶段被转换为一个立即数 内存寻址寄存器寻址的操作数位于寄存器中，立即寻址的操作数位于指令中，是指令的一部分。这是两种速度比较快的寻址方式，但它们也有局限性：一方面，我们不可能总是知道要操作的数是多少，因此也就不可能总是在指令上使用立即数；另一方面，寄存器的数量有限，不可能总指望在寄存器之间来回传递数据。 考虑到内存容量大，所以在指令中使用内存地址来操作内存中的数据是比较理想的方案。 在正式介绍内存寻址之前需要先理解一个概念：有效地址。 有效地址（Effective Address，EA） = 位移量（disp） + 基址（base） + 变址（index） 位移量：存放在指令中的数，但它不是一个立即数，而是一个地址，可以用变量或标号标识基址：存放在基址寄存器（BX，BP）中，有效地址的基址部分变址：存放在变址寄存器（SI，DI）中，有效地址的变址部分 直接寻址寄存器间接寻址寄存器相对寻址基址变址寻址相对基址变址寻址","tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"https://wiki.blanc.site/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"x86汇编指令","date":"2021-02-05T00:00:00.000Z","path":"archives/f3934733.html","text":"前言注：本文以 x86 指令集架构为例 数据传送指令算数运算指令逻辑运算指令串指令程序转移指令可以修改 IP 或同时修改 CS 和 IP 寄存器内容的指令统称为转移指令。可以通俗理解为：转移指令就是可以控制 CPU 下一步执行内存中哪一处指令的指令。 在 8086 中按照转移行为可分为： 段内转移：只修改 IP 短转移：IP 修改范围为 -128~127(2^7-1) 近转移：IP 修改范围为 -32768~32767(2^15-1) 段间转移（远转移）：同时修改 CS 和 IP 按照功能不同，转移指令又可细分为一下几种： 无条件转移指令描述：无条件转移指令可以控制 CPU 下一步执行代码段（CS）中任意内存地址对应的指令 offset描述操作符，由编译器处理，功能是获取标号的偏移地址 实例12start: mov ax,offset start ; 相当于 mov ax,0next: mov ax,offset next ; 相当于 mov ax,3 | 第一条指令长度为三个字节，因此 next 的偏移地址为 3 jmp描述转移地址可以在指令、内存或寄存器中指出。可以只修改 IP，也可以同时修改 CS 和 IP 用法使用 jmp 指令时需要提供两种信息： 转移的目的地址 转移类型（段间转移（远转移）、段内短转移、段内近转移） 实例 转移目的地址在指令中 语法：jmp short 标号作用：转移到标号处执行指令描述：这种格式的 jmp 指令实现的是段内短转移，short 为短转移标志原理：ip = ip + 8 位位移 | 8 位位移 = 标号地址 - jmp 指令后第一个字节的地址此指令形式是针对当前指令所在位置（即当前 IP）进行跳转的，且 8 位位移范围是 -128~127，由编译程序在编译时计算示例： 1234567start: mov ax,0 jmp short next add ax,1next: inc ax; 最终结果 ax 内的值为 1 语法：jmp near ptr 标号作用：转移到标号处执行指令描述：这种格式的 jmp 指令实现的是段内近转移，near 为近转移标志原理：ip = ip + 16 位位移 | 16 位位移 = 标号地址 - jmp 指令后的第一个字节地址此指令也是针对当前指令所在位置（即当前 IP）进行跳转的，且 16 位位移范围是 -32768~32767，由编译程序在编译时计算 语法：jmp far ptr 标号作用：转移到标号处执行命令描述：这种格式的 jmp 指令实现的是段间转移（即远转移），far ptr 为远转移标志原理：cs = 标号所在段的段地址 | ip = 标号所在段中的偏移 | 高位存储段地址，低位存储偏移地址 转移目的地址在内存中 语法：jmp word ptr 内存单元地址作用：转移到目标内存地址所存储的地址处执行指令描述：这种格式的 jmp 指令实现的是段内转移，word ptr 是转移标志原理：ip = 内存地址所存储的内容 语法：jmp dword ptr 内存单元地址作用：在内存单元地址处存放两个字，高地址存放转移的目的段地址，低地址存放转移的目的偏移地址描述：这种格式的 jmp 指令实现的是段间转移（即远转移），dword ptr 为远转移标志原理：cs = 内存单元地址 + 2 所存储的内容 | ip = 内存单元地址存储的内容示例： 12345mov ax,0123Hmov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0]; 执行后 cs &#x3D; 0 | ip &#x3D; 0123H 转移目的地址在寄存器中 语法：jmp 16位寄存器作用：转移到目标寄存器所存储的地址处执行指令描述：这种格式的 jmp 指令实现的是段内转移原理：ip = 16位寄存器内容 语法：jmp 段地址:偏移地址作用：转移到目标地址处执行命令描述：这种格式的 jmp 执行实现的是段间转移原理：cs = 段地址 | ip = 偏移地址 条件转移指令循环控制指令终端指令处理器控制指令伪指令处理器控制指令参考 Inno’s Blog：汇编语言学习笔记（九）：转移指令的原理 jasonM：一步步学习汇编(10)之jmp指令原理分析（破解软件的必修课）","tags":[{"name":"汇编指令","slug":"汇编指令","permalink":"https://wiki.blanc.site/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"汇编语言","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/汇编语言","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"计算机的启动","date":"2021-02-02T00:00:00.000Z","path":"archives/37910dd2.html","text":"前言本文并非从本质上去讲解计算机的启动过程，而是站在汇编程序执行的角度去理解计算机在启动过程中是如何执行最底层的汇编程序的，并进一步了解这些汇编程序是从哪里来的。 注：本文内容以 x86 体系计算机为例 硬件 CPU：负责读取和执行被加载（或映射）到内存中的指令或数据； ROM：只读存储器，存储在一个非易失芯片上，即在关机后内容仍然可以被保存。主要用来存储计算机启动的引导系统 BIOS(Basic Input/Output System)； 内存：存储（或映射）正在执行的程序所编译好的指令或数据； 硬盘：存储数据或程序可执行文件； 其他硬件：显示器、显卡、键盘等等。 提前了解想要完整的理解计算机启动过程需要有一定的前置知识积累，这里简单的罗列和解释了一些前置知识点。选择自己不熟悉的内容查看即可。 CPU 工作模式CPU 在上电之后会反复重复两个动作： 从内存读取指令； 执行刚刚读取的指令。 注：当然具体工作原理要比这个复杂的多，这里仅是解释一下 CPU 简单的工作模式 ROM 中的 BIOS只读存储器（Read Only Memory，ROM）：是一种半导体存储器，其特性是一旦存储资料就无法再将之改变或删除，且内容不会因为电源关闭而消失。正是由于这种特性 ROM 被用在在计算机中存储启动引导程序。 基本输入输出系统（Basic Input/Output System，BIOS），也成为 ROM BIOS、System BIOS、PC BIOS，是在计算机通电引导阶段运行硬件初始化以及为操作系统提供运行时服务的固件。BIOS 预安装在计算机的主板上是计算机启动时加载的第一个软件。 注：这边讲的都是一个大概，并非具体细节，如果想了解具体细节的话可以自己搜索资料深入了解。 寻址空间、寻址、物理地址、逻辑地址寻址空间（最大内存容量）寻址空间一般指的是 CPU 对于内存的寻址能力，通俗来说就是 CPU 可支持的最大内存容量，以字节为单位。寻址空间的大小由地址总线的地址寄存器宽度（位数）决定，假设地址总线位数为 N 位，则寻址空间为 2 的 N 次方字节（因为计算机使用的是二进制所以是 2 的 N 次方）。 小知识目前（2015年5月），Intel 的 32位架构下，可使用的地址线是 36个，可使用的最大物理地址是 2^36B，折合 64GB，可用的地址空间是 4GB。64位架构下，地址线是 46个，所以最大的物理地址是 2^46B，折合 64TB，可用地址空间也是这么大（目前为止） 知乎：北极就「32位系统只能寻址4G空间，64位则是128G，这些是怎么算出来的？」这一问题的回答节选 寻址内存中每一个字节都有一个对应的内存地址，CPU 去访问某一具体内存地址的过程称为寻址。 物理地址CPU 地址总线传来的地址，大部分是留给内存对应了内存的内存地址，但也常被映射到其他存储器上（如显存、BIOS 等）。 逻辑地址为了方便编程，进一步的将内存划分成不同的段，在这种模式下内存地址的表达形式为：段地址：偏移地址，逻辑地址仅在汇编编程的过程中使用，在汇编程序经过编译之后逻辑地址会转化成物理地址。 所以，无论是物理地址还是逻辑地址都是指的内存地址，只是两种不同的表达方式，逻辑地址的出现也只是为了方便编程。 I/O、MMIOI/OI/O 为 Input &amp; Output 的简写，这里指的是 I/O 设备。 所谓 I/O 设备指的是计算机的输入和输出设备，常见的有：输出设备：显示器、打印机；输入设备：键盘、鼠标。 而控制这些 I/O 设备的原理其实就是控制设备内部寄存器的读写，这些 I/O 设备的寄存器被称为 I/O 端口，通常包括：控制寄存器、状态寄存器和数据寄存器三大类。 MMIO内存映射 I/O（Memory mapping I/O，MMIO），通过将 I/O 端口映射到内存空间便于 CPU 访，在映射之后就可以实现 CPU 通过操控内存间接控制 I/O 设备，这样访问 AGP/PCI-E 显卡上的帧缓存、BIOS、PCI 设备等就可以使用读写内存一样的汇编指令完成，简化了程序设计的难度和接口的复杂性。 从按下开关键那一刻开始上电在按下开机键之后，电源开始向计算机主板和其他设备供电，在芯片组检测到电源稳定供电后（一瞬间的事情）CPU 开始工作（即读取和执行指令）。 读取 BIOS注：这里涉及到一些汇编基础，我就不过多解释了 在刚开机初始阶段计算机内存中是没有任何内容的，此时 CPU 通过读取 CS 和 IP 寄存器的内容来获取自己需要执行的指令，而此时寄存器 CS 存储内容为 0xFFFF，寄存器 IP 存储内容为 0x0000，即计算机会从 0xFFFF:0x0000（实际对应地址为：0xFFFF0）开始读取并执行指令。0xFFFF0 正是 ROM 中 BIOS 经过 MMIO 后所对应的内存地址。 即计算机在开机初始阶段会先读取 BIOS 中内置的程序指令，而 BIOS 内置程序指令主要完成了以下工作： 硬件自检（Power-On Self-Test， POST）：查看计算机硬件能否满足运行的基本条件 启动顺序（Boot Sequence）：程序读取启动顺序表，按照内容依次尝试并在成功后停止继续尝试 主引导扇区主引导扇区（Main Boot Sector，MBR）：硬盘的第 0 扇面、第 0 磁道、第 1 扇区。 这里我们假设我们设置的启动顺序第一位是硬盘并且硬盘实际存在，BIOS 程序会硬盘的主引导扇区读入物理地址为 0x07C00 起始的内存区域并继续执行其中内容。 为什么是 0x07C00？貌似是历史原因，没什么特别之处，可以自己去百度了解一下。 主引导扇区共 512字节，只有在这 512字节的最后两个字节为 0x55 和 0xAA 时才能被用于计算机启动，如果不是就表明此硬盘不可用于计算机启动，BIOS 则会继续读取启动顺序中记录的下一个设备。 正常情况下这 512字节的主要作用为： 1-446字节：调用操作系统的机器码 447-510字节：分区表（Partition table） 511-512字节：主引导扇区签名（0x55AA） 分区表分区表的长度为 64字节，具体分为四项，每项 16字节。所以，一个硬盘最多可分为四个一级分区，又叫做「主分区」，每个主分区的 16字节由 6 部分组成： 第 1字节：如果是 0x80，标识主分区是激活分区，控制权要转交给这个分区（四个主分区里只能有一个是激活的）； 第 2-4 字节：主分区第一个扇区的物理位置（柱面，磁头、扇区号等）； 第 5字节：主分区类型； 第 6-8字节：主分区最后一个扇区的物理位置； 第 9-12字节：主分区的第一个扇区的物理位置； 第 13-16字节：主分区的扇区总数。 分出主分区后其余部分可以分成拓展分区，一般是剩下的部分全部分成拓展分区，也可以不全分，但剩下的部分就浪费了。拓展分区不能直接使用，必须分成若干逻辑分区，所有逻辑分区都是拓展分区的一部分。 磁盘的容量 = 主分区容量 + 拓展分区容量 + 空闲分区容量拓展分区容量 = 各个逻辑分区容量之和 + 空闲分区容量 硬盘启动卷引导记录如果操作系统安装在激活的主分区中，计算机会读取激活分区的第一个扇区，叫做「卷引导记录（Volume Boot Record，VBR）」。 卷引导记录负责告诉计算机操作系统在这个分区的具体位置，然后计算机就会加载操作系统完成开机行为。 拓展分区和逻辑分区我们一般不将操作系统安装在拓展分区或逻辑分区中，如果有这种情况一般也采用下面一种启动方式。 启动管理器在这种情况下，计算机读取主引导扇区的前 446字节后不再将控制权转交给某一个分区，而是运行事先安装好的启动管理器（Boor Loader），由用户选择具体启动哪一个操作系统。 操作系统进行完前面的流程后，进入操作系统启动流程，本文对这一部分不作出详细介绍，如果感兴趣的话可以自己百度搜索。 参考 百度百科：寻址空间 知乎：北极回答 百度百科：地址总线 CSDN-JeanChen：深入理解计算机系统…… CSDN-颇锐克：逻辑地址、线性地址和物理地址的关系 CSDN-langb2014：IO端口和IO内存的区别及分别使用的函数接口 MCU 中文技术社区-judy：详解io端口与io内存 知乎-围城：内存映射IO (MMIO) 简介 百度知道-笑脸蓝雨：电脑的开机原理是什么？ 思维之际：计算机加电后操作系统启动过程 阮一峰的网络日志：计算机是如何启动的？ Adam’s blog：计算机启动过程","tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"https://wiki.blanc.site/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"对比 C 和 CPP 中 struct class 和 union","date":"2020-11-11T00:00:00.000Z","path":"archives/ca916e4c.html","text":"C struct 与 CPP struct 对比定义方式C1234567891011121314// 第一种方式typedef struct A&#123; ...&#125;a;struct A test;a test1;// 第二种方式struct B&#123; ...&#125;;struct B test3; CPP123456789101112131415161718192021// 第一种方式typedef struct A&#123; ...&#125;a;struct A test;a test1;// 第二种方式struct B&#123; ...&#125;;struct B test3;// 第三种方式struct C&#123; ...&#125;;C test4; 结构体内容CPP 中 struct 可以有成员函数（构造函数、析构函数、常规函数和虚函数）和静态成员（静态成员函数和静态成员变量）。 其他CPP 中 struct 可以继承 class 和 struct，也可以被 class 和 struct 继承； CPP 中 struct 内可以使用 public proctected private 访问属性，默认为 public，C 中 struct 访问属性默认为 public 且不可修改； C 中 sizeof 空结构体结果为 1；CPP 中 sizeof 空结构体结果为 0。 CPP 中 struct 与 class 对比 struct 默认访问属性是 public，class 则是 private； struct 继承 struct 和 class 后默认访问属性是 public； class 继承 struct 和 class 后默认访问属性时 private； struct 如果没有定义构造函数或虚函数则可以使用 {} 进行初始化：struct 使用 {} 进行初始化时按照数据在内存中顺序从其实地址依次初始化的，在 struct 定义虚函数后 struct 其实地址首先是虚指针，在 struct 定义构造函数后则使用构造函数进行初始化； class 可用于定义模板参数，struct 不行。 CPP 中 union 特性 默认访问属性为 public； 不能继承也不能被继承； 所有元素（成员变量）共用一块内存，并且内存大小是成员变量中类型最大的值。 总结union 主要用来节省内存空间；struct 主要用来对某种结构进行封装；class 主要用来对某类对象进行封装； 参考 知乎-LWenlong：C++ union、struct 和 class 赵大寳：C/C++中结构体的定义以及实例化 拓扑梅尔-BlogUpdater：深度理解：struct和class的区别 CSDN-长空飞鸟：Thinking in C++: C++中关于union、struct、class的区别","tags":[{"name":"CPP","slug":"CPP","permalink":"https://wiki.blanc.site/tags/CPP/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"C&CPP","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/C-CPP","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/C-CPP/"}]},{"title":"数据结构笔记2-线性表","date":"2020-11-06T00:00:00.000Z","path":"archives/e3cbe031.html","text":"注：本人学习数据结构时是以 C++ 为编程语言 概念-名词解释线性表：线性存储结构，将具有「一对一」关系的数据「线性」地存储到物理空间中，这种存储结构就称为线性存储结构（简称：线性表）。 依据在计算机中的实际存储结构线性存储结构可以细分为一下两种： 顺序表：将线性表中所有元素按照其逻辑顺序依次存储到从计算机存储中指定存储位置开始的一块连续的存储空间中； 链表：线性表的元素存储在不连续的物理空间中，用指针表示结点间的逻辑关系。 表名、表项、表头、表尾、头结点、首元结点、直接前驱、直接后继、空表、有序表、无序表：会在后面的代码示例中解释 顺序表实现分析实现方案在 C 语言中，顺序表有两种实现方式： 点击显示/隐藏全部代码 123456789101112131415// 静态存储结构#define maxSize 100typedef int T;typedef struct &#123; T data[maxSize]; int len;&#125; SeqList; // 动态存储结构typedef int T;typedef struct &#123; T *data; int maxSize, len;&#125; SeqList; 在我所用的教科书里选用了在 C++ 中延续动态存储结构，这里我就顺着教科书走，后面的代码实现也是使用 C++ 配合动态存储结构实现顺序表。 常见属性列举 用来存放数据的数组变量； 用来存放表容量的整型变量； 用来存放当前表已占用容量的整型变量； 常见方法列举 通过传入容量变量构造实例的构造函数； 复制构造函数； 析构函数； 返回表容量的函数； 返回表当前已占用容量的函数； 头插 | 尾插 | 任意位置插入； 搜索 X 在表中的位置； 获取第 i 项 | 修改第 i 项 | 删除第 i 项 判空 | 判满 格式化输出 动态改变表容量的方法； 代码实现 点击显示/隐藏全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194//// Created by ryoma on 2020/11/8.//template&lt;class T&gt;class SeqList &#123; public: SeqList(int capacity = 10); // 构造函数 SeqList(SeqList&lt;T&gt; &amp;TheSqlList); // 复制构造函数 ~SeqList() &#123; delete[] data_; &#125; // 析构函数 void HeadInsert(T &amp;element); // 头插 void LastInsert(T &amp;element); // 尾插 void Insert(int index, T &amp;element); // 任意位置插入 int Search(T &amp;element); // 搜索 x 在表中的位置 T GetData(int index); // 获取第 i 项的值 void SetData(int index, T &amp;element); // 将第 i 项更新为 x void DeleteData(int index); // 删除第 i 项 bool IsFull(); // 判满 bool IsEmpty(); // 判空 void FormatOutput(); // 格式化输出 int capacity() const &#123; return capacity_; &#125; // 获取表容量 int size() const &#123; return size_; &#125; // 获取表当前占用容量 protected: T *data_; // 表成员数组指针 int size_; // 表当前占用容量 int capacity_; // 表容量 void ResetCapacity(int new_capacity); // 重置表容量&#125;;template&lt;class T&gt;SeqList&lt;T&gt;::SeqList(int capacity) &#123; if (capacity &gt; 0) &#123; capacity_ = capacity; size_ = 0; data_ = new T[capacity_]; if (data_ == NULL) &#123; cerr &lt;&lt; \"memory allocation failed!\" &lt;&lt; endl; exit(1); &#125; &#125; else &#123; cerr &lt;&lt; \"sequential list capacity set error!\" &lt;&lt; endl; exit(1); &#125;&#125;template&lt;class T&gt;SeqList&lt;T&gt;::SeqList(SeqList&lt;T&gt; &amp;TheSqlList) &#123; capacity_ = TheSqlList.capacity(); size_ = TheSqlList.size(); T value; data_ = new T[capacity_]; if (data_ == NULL) &#123; cerr &lt;&lt; \"memory allocation failed!\" &lt;&lt; endl; exit(1); &#125; for (int i = 0; i &lt; size_; i++) &#123; TheSqlList.GetData(i); data_[i] = value; &#125;&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::ResetCapacity(int new_capacity) &#123; // 判断给出顺序表容量是否合法 if (new_capacity &lt;= capacity_) &#123; cerr &lt;&lt; \"sequential list capacity set error!\" &lt;&lt; endl; return; &#125; // 创建扩容后的数组用来存放顺序表元素 T *new_array = new T[new_capacity]; if (new_array == NULL) &#123; cerr &lt;&lt; \"memory allocation failed!\" &lt;&lt; endl; return; &#125; // 将旧顺序表数组的内容同步到新顺序表中 for (int i = 0; i &lt; size_; ++i) &#123; new_array[i] = data_[i]; &#125; // 替换属性 delete[] data_; data_ = new_array; capacity_ = new_capacity;&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::HeadInsert(T &amp;element) &#123; // 判满 | 如果顺序表满则扩容 if (size_ == capacity_) &#123; ResetCapacity(2 * capacity_); &#125; // 将顺序表内所有元素向后移动一位 for (int i = size_; i &gt; 0; --i) &#123; data_[i] = data_[i - 1]; &#125; data_[0] = element; size_++;&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::LastInsert(T &amp;element) &#123; // 判满 | 如果顺序表满则扩容 if (size_ == capacity_) &#123; ResetCapacity(2 * capacity_); &#125; data_[size_] = element; size_++;&#125;// 将给出的元素值插入到当前顺序表的第 index 个元素前template&lt;class T&gt;void SeqList&lt;T&gt;::Insert(int index, T &amp;element) &#123; // 判断 index 是否正确 if (index &gt; size_ || index &lt; 1) &#123; cerr &lt;&lt; \"index input error!\" &lt;&lt; endl; return; &#125; // 判满 | 如果顺序表满则扩容 if (size_ == capacity_) &#123; ResetCapacity(2 * capacity_); &#125; // 将顺序表 index 之后的全部元素向后平移一位 for (int i = size_; i &gt; index; --i) &#123; data_[i] = data_[i - 1]; &#125; data_[index - 1] = element; size_++;&#125;// 从当前顺序表搜索给出的元素值// 如果元素值存在，返回元素值第一次出现在当前顺序表的第几个元素// 如果不存在返回 0template&lt;class T&gt;int SeqList&lt;T&gt;::Search(T &amp;element) &#123; for (int i = 0; i &lt; size_; ++i) &#123; if (data_[i] == element) &#123; return i + 1; &#125; &#125; return 0;&#125;// 获取当前顺序表的第 index 个元素template&lt;class T&gt;T SeqList&lt;T&gt;::GetData(int index) &#123; if (index &gt; size_ || index &lt; 1) &#123; cerr &lt;&lt; \"index input error!\" &lt;&lt; endl; exit(1); &#125; return data_[index - 1];&#125;// 将当前顺序表的第 index 个元素修改为给出的元素值template&lt;class T&gt;void SeqList&lt;T&gt;::SetData(int index, T &amp;element) &#123; if (index &gt; size_ || index &lt; 1) &#123; cerr &lt;&lt; \"index input error!\" &lt;&lt; endl; return; &#125; data_[index - 1] = element;&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::DeleteData(int index) &#123; if (size_ == 0 || index &gt; size_ || index &lt; 1) &#123; cerr &lt;&lt; \"index input error!\" &lt;&lt; endl; return; &#125; for (int i = index - 1; i &lt; size_; ++i) &#123; data_[i] = data_[i + 1]; &#125; size_--;&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::FormatOutput() &#123; if (size_ == 0) &#123; return; &#125; for (int i = 0; i &lt; size_; ++i) &#123; cout &lt;&lt; data_[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125;template&lt;class T&gt;bool SeqList&lt;T&gt;::IsFull() &#123; return size_ == capacity_;&#125;template&lt;class T&gt;bool SeqList&lt;T&gt;::IsEmpty() &#123; return size_ == 0;&#125; 效率分析123456789void HeadInsert(T &amp;element); // O(n)void LastInsert(T &amp;element); // O(1)void Insert(int index, T &amp;element); // O(n)int Search(T &amp;element); // O(n)T GetData(int index); // O(n)void SetData(int index, T &amp;element); // O(n)void DeleteData(int index); // O(n)void FormatOutput(); // O(n)void ResetCapacity(int new_capacity); // O(n) 单链表实现分析根据链表的组成，通常会使用结点类和链表类协同表示链表。 一个链表包含零个或多个结点，因此一个类型为 List 的对象包括零个或多个类型为 LinkNode 的对象。这种关系在面向对象方法中叫做「聚合关系」，或者叫做「整体-部分关系」。 为了简化问题，设一个单链表的每一个结点中的数据元素为一个整型数据，有4 种方法设计数据结构。 实现方案 方案一：复合类 12345678910111213141516class List; // List 类的前视声明class LinkNode &#123; // 结点类定义 friend class List; // 声明 List 类为友元类 private: int data; // 数据元素域 LinkNode *link; // 链指针域&#125;;class List &#123; // List 类定义 public: // 链表操作 ... private: LinkNode *first; // 链表头指针 &#125;; 方案二：嵌套类 123456789101112class List &#123; public: // 链表操作 ... private: class LinkNode &#123; public: int data; LinkNode *link; &#125;; LinkNode *first;&#125;; 方案三：基类和派生类 12345678910111213class LinkNode &#123; protected: int data; LinkNode *link;&#125;;class List: public class LinkNode &#123; private: LinkNode *first; public: //链表操作 ...&#125; 方案四：用 struct 定义 LinkNode 类 123456789101112struct LinkNode &#123; int data; LinkNode *link;&#125;;class List &#123; private: LinkNode *first; public: // 链表操作 ...&#125;; 后面我将采用「方案四：用 struct 定义 LinkNode 类」来实现链表以及其一些列变种。 常见属性列举 结点类中存放数据的变量； 结点类中存放此结点所指向的下一结点的指针变量； 带头指针的链表类所包含的指向头结点的指针变量； 常见方法列举 构造函数 复制构造函数 析构函数 置空函数 返回链表当前大小的函数 头插 | 尾插 | 任意位置插入 搜索 X 在表中的位置 获取第 i 项 | 修改第 i 项 | 删除第 i 项 判空 格式化输出 代码实现 点击展示/隐藏全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274//// Created by ryoma on 2020/11/11.//template&lt; class T&gt;struct Node &#123; T data; // 数据域 Node&lt;T&gt; *next; // 指针域 Node(Node&lt;T&gt; *ptr = NULL) &#123; next = ptr; &#125; Node(const T &amp;element, Node&lt;T&gt; *ptr = NULL) &#123; data = element; next = ptr; &#125;&#125;;template&lt;class T&gt;class SingleLinkedList &#123; public: SingleLinkedList(); // 构造函数 SingleLinkedList(SingleLinkedList&lt;T&gt; &amp;theSingleLinkedList); // 复制构造函数 ~SingleLinkedList(); // 析构函数 void MakeEmpty(); // 置空函数 void HeadInsert(T &amp;element); // 头插 void LastInsert(T &amp;element); // 尾插 void Insert(int index, T &amp;element); // 在第 index 项之后插入 int Search(T &amp;element); // 搜索 element 在链表中的位置，找到返回位置，找不到返回 0 T GetData(int index); // 获取链表中第 index 项的值 void SetData(int index, T &amp;element); // 将链表中第 index 项的值更改为 element void DeleteData(int index); // 删除链表的第 index 项 bool IsEmpty(); // 判空 void FormatOutput(); // 格式化输出链表元素 int length() const &#123; return length_; &#125; // 返回链表长度 Node&lt;T&gt; *first() const &#123; return first_; &#125; // 返回头指针 protected: int length_; // 链表长度 Node&lt;T&gt; *first_; // 链表头指针&#125;;template&lt;class T&gt;SingleLinkedList&lt;T&gt;::SingleLinkedList() &#123; length_ = 0; first_ = new Node&lt;T&gt;;&#125;template&lt;class T&gt;SingleLinkedList&lt;T&gt;::SingleLinkedList(SingleLinkedList&lt;T&gt; &amp;theSingleLinkedList) &#123; T value; Node&lt;T&gt; *old_first = theSingleLinkedList.first(); Node&lt;T&gt; *new_first = first_ = new Node&lt;T&gt;; if (new_first == NULL) &#123; cerr &lt;&lt; \"memory allocation failed!\" &lt;&lt; endl; exit(1); &#125; // 将原实例中所有结点复制到新实例中 while(old_first-&gt;next != NULL) &#123; value = old_first-&gt;next-&gt;data; new_first-&gt;next = new Node&lt;T&gt;(value); new_first = new_first-&gt;next; old_first = old_first-&gt;next; &#125; new_first-&gt;next = NULL;&#125;template&lt;class T&gt;SingleLinkedList&lt;T&gt;::~SingleLinkedList&lt;T&gt;() &#123; MakeEmpty();&#125;template&lt;class T&gt;void SingleLinkedList&lt;T&gt;::MakeEmpty() &#123; Node&lt;T&gt; *temp_node; // 遍历整个单链表，逐个删除结点 while(first_-&gt;next != NULL) &#123; temp_node = first_-&gt;next; first_-&gt;next = temp_node-&gt;next; delete temp_node; &#125; first_-&gt;data = NULL; length_ = 0;&#125;template&lt;class T&gt;void SingleLinkedList&lt;T&gt;::HeadInsert(T &amp;element) &#123; if (length_ == 0) &#123; first_-&gt;data = element; length_++; return; &#125; Node&lt;T&gt; *new_node = new Node&lt;T&gt;(element, NULL); if (new_node == NULL) &#123; cerr &lt;&lt; \"memory allocation failed!\" &lt;&lt; endl; exit(1); &#125; Node&lt;T&gt; *old_head = first_; first_ = new_node; first_-&gt;next = old_head; length_++;&#125;template&lt;class T&gt;void SingleLinkedList&lt;T&gt;::LastInsert(T &amp;element) &#123; if (length_ == 0) &#123; first_-&gt;data = element; length_++; return; &#125; Node&lt;T&gt; *new_node = new Node&lt;T&gt;(element, NULL); if (new_node == NULL) &#123; cerr &lt;&lt; \"memory allocation failed!\" &lt;&lt; endl; exit(1); &#125; Node&lt;T&gt; *current = first_; while(current-&gt;next != NULL) &#123; current = current-&gt;next; &#125; current-&gt;next = new_node; length_++;&#125;template&lt;class T&gt;void SingleLinkedList&lt;T&gt;::Insert(int index, T &amp;element) &#123; if (length_ == 0 &amp;&amp; index == 1) &#123; first_-&gt;data = element; length_++; return; &#125; // 判断 index 输入正确性 if (index &gt; length_ || index &lt; 1) &#123; cerr &lt;&lt; \"index input error!\" &lt;&lt; endl; return; &#125; Node&lt;T&gt; *new_node = new Node&lt;T&gt;(element, NULL); if (new_node == NULL) &#123; cerr &lt;&lt; \"memory allocation failed!\" &lt;&lt; endl; exit(1); &#125; Node&lt;T&gt; *current = first_; int current_index = 1; while (current-&gt;next != NULL &amp;&amp; current_index &lt; index) &#123; current = current-&gt;next; current_index++; &#125; Node&lt;T&gt; *next_node = current-&gt;next; current-&gt;next = new_node; new_node-&gt;next = next_node; length_++;&#125;template&lt;class T&gt;int SingleLinkedList&lt;T&gt;::Search(T &amp;element) &#123; Node&lt;T&gt; *current = first_; int current_index = 0; while (current-&gt;next != NULL) &#123; if (current-&gt;data == element) &#123; return current_index; &#125; current = current-&gt;next; current_index++; &#125; return 0;&#125;template&lt;class T&gt;T SingleLinkedList&lt;T&gt;::GetData(int index) &#123; // 判断 index 输入正确性 if (index &gt; length_ || index &lt; 1) &#123; cerr &lt;&lt; \"index input error!\" &lt;&lt; endl; exit(1); &#125; Node&lt;T&gt; *current = first_; int current_index = 0; while (current-&gt;next != NULL) &#123; if (current_index == index) &#123; return current-&gt;data; &#125; current = current-&gt;next; current_index++; &#125;&#125;template&lt;class T&gt;void SingleLinkedList&lt;T&gt;::SetData(int index, T &amp;element) &#123; // 判断 index 输入正确性 if (index &gt; length_ || index &lt; 1) &#123; cerr &lt;&lt; \"index input error!\" &lt;&lt; endl; return; &#125; Node&lt;T&gt; *current = first_; int current_index = 0; while (current-&gt;next != NULL) &#123; if (current_index == index) &#123; current-&gt;data = element; &#125; current = current-&gt;next; current_index++; &#125;&#125;template&lt;class T&gt;void SingleLinkedList&lt;T&gt;::DeleteData(int index) &#123; // 判断 index 输入正确性 if (index &gt; length_ || index &lt; 1) &#123; cerr &lt;&lt; \"index input error!\" &lt;&lt; endl; return; &#125; if (index == 1) &#123; Node&lt;T&gt; *old_head = first_; first_ = first_-&gt;next; delete old_head; length_--; return; &#125; Node&lt;T&gt; *current = first_; int current_index = 0; while (current-&gt;next != NULL) &#123; if (current_index == index - 1) &#123; Node&lt;T&gt; *node_to_be_deleted = current-&gt;next; current-&gt;next = node_to_be_deleted-&gt;next; node_to_be_deleted-&gt;next = NULL; delete node_to_be_deleted; length_--; return; &#125; current = current-&gt;next; current_index++; &#125;&#125;template&lt;class T&gt;bool SingleLinkedList&lt;T&gt;::IsEmpty() &#123; return length_ == 0;&#125;// TODO 代办 针对复杂的 T 应该给 Node 单独定义 FormatOutput 函数并在输出结点内容时调用template&lt;class T&gt;void SingleLinkedList&lt;T&gt;::FormatOutput() &#123; if (length_ == 0) &#123; return; &#125; Node&lt;T&gt; *current = first_; while (current-&gt;next != NULL) &#123; cout &lt;&lt; current-&gt;data &lt;&lt; \"-&gt;\"; current = current-&gt;next; &#125; cout &lt;&lt; current-&gt;data &lt;&lt; endl;&#125; 效率分析12345678void HeadInsert(T &amp;element); // O(n)void LastInsert(T &amp;element); // O(n)void Insert(int index, T &amp;element); // O(n)int Search(T &amp;element); // O(n)T GetData(int index); // O(n)void SetData(int index, T &amp;element); // O(n)void DeleteData(int index); // O(n)void FormatOutput(); // O(n)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wiki.blanc.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-数据结构和算法","slug":"3-计算机科学/1-理论计算机科学/1-数据结构和算法","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"zsh 历史文件损坏","date":"2020-10-17T00:00:00.000Z","path":"archives/2025325c.html","text":"系统因为某些原因强行重启的时候有很大可能损坏 zsh 的历史记录文件，导致下次使用时提示：zsh: corrupt history file /path/to/.zsh_history 理论上来说直接删除 .zsh_history 是可以消除报错的，但会导致之前的命令历史被删除，正确的解决方法是： 123cp .zsh_history zsh_history // 复制损坏的历史记录文件rm .zsh_history // 删除原来的历史记录strings zsh_history &gt; .zsh_history // 通过 strings 命令修复此文件","tags":[{"name":"zsh","slug":"zsh","permalink":"https://wiki.blanc.site/tags/zsh/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"zsh","slug":"2-软件使用/zsh","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/zsh/"}]},{"title":"cpp 中的声明和定义","date":"2020-10-13T00:00:00.000Z","path":"archives/154e48dc.html","text":"区分声明和定义C++ 程序由各种实体（例如变量、函数、类型和命名空间）组成。必须先声明其中的每个实体才能使用这些实体。 除了声明以外，还必须定义一些实体，包括函数、类、枚举和常量变量。定义为编译器提供了在程序中使用该实体时生成计算机代码所需要的所有信息。无论定义的是函数还是变量，编译器都要为他们在定义点分配存储空间。 基本类型变量的声明和定义（初始化）时同时产生的，而对于对象或其他复杂类型变量来说声明和定义时分开的。 简而言之：定义动作会分配存储空间，而声明动作则不会。 扩展：局部变量被定义时，系统不会对其初始化，必须手动初始化；定义全局变量时系统会自动进行如下初始化。 数据类型 初始化默认值 int 0 char &#39;\\0&#39; float 0 double 0 pointer NULL 参考 声明和定义（c + +） CSDN-飞天絮血：变量定义和声明的区别（整理） 菜鸟教程-C++","tags":[{"name":"CPP","slug":"CPP","permalink":"https://wiki.blanc.site/tags/CPP/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"C&CPP","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/C-CPP","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/C-CPP/"}]},{"title":"数据结构笔记1-概论","date":"2020-10-08T00:00:00.000Z","path":"archives/f3c5e08e.html","text":"基本概念数据数据是信息的载体，是描述客观事物的数、字符以及所有能输入到计算机中并被计算机程序识别和处理的符合的集合。 数据大致可分为两类，一类是数值性数据，包括整数、浮点数、复数、双精度数等，主要用于工程和科学计算，以及商业事务处理；另一类是非数值性数据，主要包括字符和字符串，以及文字、图形、图像、语音等数据。 数据元素数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可以有若干个数据项组成，数据项是数据元素的不可分割的最小单位。例如：学生记录作为一个数据元素，它由学号、姓名、性别等数据项组成。 数据对象数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 数据类型数据类型是一个值的集合和定义在此集合上一组操作的总称。 原子类型：其值不可在分割的数据类型； 结构类型：其值可以在分割成若干成分的数据类型； 抽象数据类型：抽象数据组织和与之相关的操作。 抽象数据类型（ADT: Abstract Data Type）一个数学模型以及定义在该模型上的一组操作。 抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。通常用数据对象（D)、 数据关系（S)、基本操作集（P)这样的三元组来表示抽象数据类型。 数据结构数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所釆用的存储结构。 数据结构是由某一数据元素的集合和该集合中数据元素之间的关系组成的。 Data_Structure = {D, R} D 是某一数据元素的集合，R 是该集合中所有数据元素之间的关系的有限集合。 有关数据结构的讨论主要涉及数据元素之间的关系，不涉及数据元素本身的内容。 数据的逻辑结构数据的逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据，与数据的存储无关。 逻辑结构的第一种分类方式依据元素之间关系的不同，数据的逻辑结构分为两大类：线性结构和非线性结构。 逻辑结构的第二种分类方式线性结构：数据元素之间存在一对一的关系树形结构：数据元素之间存在一对多的关系图形结构：数据元素之间存在多对多的关系集合结构：数据元素属于同一个集合 数据的存储结构数据的存储结构是指数据结构在计算机中的具体表示（又称映像），也成物理结构。包括数据元素的表示和数据元素间关系的表示。数据的存储结构是数据的逻辑结构用计算机语言实现的。它依赖于计算机语言。主要有如下四种结构： 顺序存储结构：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元里，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。 链式存储结构：不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针表示元素之间的逻辑关系。其优点是不会出现碎片现象，充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，并且只能实现顺序存取。 索引存储结构：在存储元素信息的同时，还建立附加的索引表。索引表中的每一项称为索引项，索引项的一般形式是：（关键字，地址）。其优点是检索速度快；缺点是增加了附加的索引表，会占用较多的存储空间。另外，在增加和删除数据时要修改索引表，因而会花费较多的时间。 散列存储结构：根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。其优点是检索、增加和删除结点的操作都很快；缺点是如果散列函数不好可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。 数据的运算施加再数据上的运算包括运算的定义和实现。运算的定义时针对逻辑结构的，之处运算的功能；运算的实现是针对存储结构的，之处运算的具体操作步骤。 算法算法的基本概念算法（algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。 算法的特性 有穷性：总是（对任何合法的输入值）在执行又穷步之后结束，且每一步都可在有穷时间内完成 确定性：每一条指令必须有确切的含义，读者理解时不会产生二义性。即对于相同的输入只能得出相同的输出（幂等性？） 可行性：算法中描述的操作都是已经实现的基本操作执行有限次来实现的 输入：有零个或多个输入 输出：有一个或多个输出 算法的性能标准 正确性：正确的执行预定的功能和性能要求 可读性 健壮性：输入非法数据时也能适当的做出反应进行处理。 效率和低存储量需求 算法效率的度量算法效率的度量可分为事前估计和后期测试。 时间复杂度一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记作 T(n)，它是该算法问题规模 n 的函数，时间复杂度主要分析 T(n) 的数量级。算法中的基本运算（最深层循环内的语句）的频度与 T(n) 同数量级，所以通常釆用算法中基本运算的频度 f(n) 来分析算法的时间复杂度。因此，算法的时间复杂度也记为：T(n)=O(f(n)) 上式中 O 的含义是 T(n) 的数量级，其严格的数学定义是：若 T(n) 和 f(n) 是定义在正整数集合上的两个函数，则存在正常数 C 和 n_0，使得当 n &gt;= n_0 时，都满足 0 &lt;= T(n) &lt;= C * f(n)。 注意：取 f(n) 中随 n 增长最快的项将其系数置为 1 作为时间复杂度的度量。例如，fi(n) = a * n^3 + b * n^2 + c * n，则其时间复杂度为 O(n^3)。 算法的时间复杂度不仅依赖于问题的规模 n，也取决于待输入数据的性质（如输入数据元素的初始状态）。 一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。 在分析一个程序的时间复杂性时，有以下两条规则： 加法规则：T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))) 乘法规则：T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O( f(n) * g(n) ) 常见的渐近时间复杂度有：O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 空间复杂度算法的空间复杂度 S(n)，定义为该算法所耗费的存储空间，它是问题规模 n 的函数。渐近空间复杂度也常简称为空间复杂度，记作 S(n)=O(g(n))。 一个上机程序除了需要存储空间来存放本身所用指令、常数、变量和输入数据外，也需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间，若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。 算法原地工作是指算法所需辅助空间是常量，即 O(1)。 参考 数据结构C语言版：经典数据结构与算法分析教程 知乎-码匠：数据结构与算法是什么？","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wiki.blanc.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-数据结构和算法","slug":"3-计算机科学/1-理论计算机科学/1-数据结构和算法","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"Django 中有趣又有用的代码设计","date":"2020-08-30T00:00:00.000Z","path":"archives/5d9ebead.html","text":"通用代码片段初始化类时通过 setattr 和 **kwargs 自动设置实例属性1234567# django.views.generic.base.pyclass View: def __init__(self, **kwargs): for key, value in kwargs.items(): setattr(self, key, value) 通过字典进行 Model.objects.get | Model.objects.filter1234567891011121314# rest_framework.generics.pyclass GenericAPIView(views.APIView): def get_object(self): queryset = self.filter_queryset(self.get_queryset()) lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field # 通过 url 传参动态获取对象 filter_kwargs = &#123;self.lookup_field: self.kwargs[lookup_url_kwarg]&#125; obj = get_object_or_404(queryset, **filter_kwargs) self .check_object_permissions(self.request, obj) return obj","tags":[{"name":"Django","slug":"Django","permalink":"https://wiki.blanc.site/tags/Django/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Django","slug":"2-软件使用/Django","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Django/"}]},{"title":"MySQL8 Grant check the manual that corresponds to your MySQL server version for the right syntax to use.m","date":"2020-08-26T00:00:00.000Z","path":"archives/16f6299.html","text":"错误重现：OS: Windows 10MySQL version: 8.0.21 PS：我已经将 MySQL 的加密规则修改为 mysql_native_password 1grant all on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;testpassword&#39;; 11064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;IDENTIFIED BY &#39;testpassword&#39; at line 1 问题解决最开始判断为加密规则的问题后续检查后发现之前已经就该过加密规则了，因此排除这一错误原因。谷歌搜索后找到了 一篇文章 给出了解决方案： 123create user &#39;root&#39;@&#39;%&#39; identified by &#39;testpassword&#39;;grant all on *.* to &#39;root&#39;@&#39;%&#39;; 根据文章给出的解释：似乎是 MySQL 放弃了对这个简写版的支持，现在需要一个稍长一点的版本来代替。 参考 @mattiasgeniar-MySQL 8 removes shorthand for creating user + permissions","tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://wiki.blanc.site/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"MySQL","slug":"MySQL","permalink":"https://wiki.blanc.site/tags/MySQL/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Django admin 笔记","date":"2020-08-11T00:00:00.000Z","path":"archives/8bf18292.html","text":"记一下内容是我阅读 Django 官方文档 admin 相关内容时随手翻译的，内容未经整理 Overviewadmin 的 requirements： 添加 dango.contrib.admin 和它依赖的 django.contrib.auth django.contrib.contenttypes django.contrib.messages django.contrib.sessions 到 INSTALLED_APPS 通过在项目设置项 TEMPLATES 的选项 OPTIONS 的选项 context_processors 下添加 django.contrib.auth.context_processors.auth 和 django.contrib.messages.contxet_processors.messages 来配置 DjangoTemplates 如果是自定义的 MIDDLEWARE 设置项， django.contrib.auth.middleware.AuthenticationMiddleware 和 django.contrib.messages.middleware.MessageMiddleware 必须被包括在其中 配置 admin URL 到项目 URLconf 在进行这些配置后可以通过访问绑定的 url 访问 admin（默认是 /admin/） 可以使用默认的 createsuperuser 命令来创建一个用来登录的用户。一般来说用户需要将 is_superuser 和 is_staff 属性都设置为 True 才能登录 admin。 最后，确定应用程序的哪些模型可以在展示在 admin 中。按照 ModelAdmin 中的描述，在管理员处注册它们。 ModelAdminModelAdmin 类是 model 在 admin 接口中的表达方式。通常这些内容会存储在应用下的 admin.py 文件下。 Discovery（发现） of admin files当把 django.contrib.admin 加入到 INSTALLED_APPS，Django 会在 app 目录中自动查找 admin 模块并引用它 class apps.AdminConfig这是 admin 的默认的 AppConfig 类。它会在 Django 启动时调用 autodiscover() 方法 class apps.SimpleAdminConfig和上面的类似，但是不调用 autodiscover default_site一个点状的导入路径，用于导入默认的管理站点的类或返回站点实例的可调用类 默认为’django.contrib.admin.sites.AdminSite’ autodiscove() 该功能试图在每个安装的应用程序中导入一个 admin 模块，这样的模块被期望向 admin 注册模型。 通常情况下，你不需要直接调用这个函数，因为当Django启动时，AdminConfig会调用它。 如果你使用的是自定义的 AdminSite，通常会将所有的 ModelAdmin 子类导入到你的代码中，并将它们注册到自定义的AdminSite中。 在这种情况下，为了禁用自动发现， 你应该在INSTALLED_APPS设置中加入’django.contrib.admin.apps.SimpleAdminConfig’而不是’django.contrib.admin’。 ModelAdmin optionsModelAdmin 非常灵活。它有几个选项来处理自定义界面。所有选项都定义在 ModelAdmin 子类上。 ModelAdmin.action | 展示页在 change list page 提供的操作列表 ModelAdmin.actions_on_top | 展示页 ModelAdmin.actions_on_botton | 展示页控制动作栏在哪个位置出现，默认 top ModelAdmin.actions_selection_counter | 展示页是否在 action dropdwon 下显示计数器（默认显示） ModelAdmin.date_hierarchy | 展示页将此选项设置为 Modle 中某一个 DateField 或 DateTimeFile 字段，在 List 页面的顶部会显示一个时间选择条 ModelAdmin.emty_value_display | 展示页当某个值为空的时候填充什么 ModelAdmin.exclued | 详情页（新增，更改）给定一个字段名称的列表或元组，将其中的字段从详情页中排除 ModelAdmin.fields | 详情页（新增，更改）fields 能够接受与 list_display 同类型的值，只是不能接受可调用项 model 和 model admin methods 只能在 readonly_fields 字段上可用 如果要将多项内容放在一行，需要将所需选项放入一个元组中（不知道列表行不行） 如果 fields 和 fieldsets 选项都不存在，Django 将默认在单个 fieldset 中显示每一个不是 AutoField 且 editable = True 的字段，顺序与在 model 中顺序相同 ModelAdmin.fieldsets | 详情页（新增，更改）field set =》 字段 集合，管理字段集合的一个选项 一个二元元组的元组（列表应该也行吧），其中每个二元元祖代表页面上的一组字段 二元元祖格式：(name, field_options)name 表示字段集标题的字符串field_options 关于字符集信息的字典，包括要在其中显示的字段列表 field_options 字段可配置的键： * fields：字段名称的元组，与 fields 参数相同，必须 * classes 一个包含额外应用到此 fieldset 上的 CSS 类的元组或列表，有两个默认的选项 coolapse 和 wide * description：描述内容，现实在字段集合顶部标题下，可以直接写HTML ModelAdmin.filter_horizontal | 新增或更改页面为 ManyToManyFields 添加选择框 12345# person admin.py@register(Person)class PersonAdmin(admin.ModelAdmin): filter_horizontal = (\"task\",) TODO 插入图片 ModelAdmin.filter_vertical | 展示页 和 filter_horizontal 类似，只是 从横向变成纵向 ModelAdmin.form | 新增或修改页面默认情况下会为 Model 动态创建一个 ModelForm。用于创建在新增或修改页面展示。 可以通过这个属性提供一个自己的表单来覆盖表单行为，或者可以使用自定义默认表单而不是自动生成（请看 Adding custom validation to the admin） 如果 ModelForm 和 ModelAdmin 都定义了 excude ModelAdmin 优先 ModelAdmin.formfield_overrides | 每太看懂不过感觉用不上This provides a quick-and-dirty way to override some of the Field options for use in the admin ModelAdmin.inlines略 ModelAdmin.list_display | 展示页一个字段名元组（列表也行），选择需要在 List 页面展示哪些字段 可以自定义一些 callable 对象然后赋值给它用来展示 12345678910111213141516171819202122232425262728293031323334def upper_case_name(obj): return (\"%s %s\" % (obj.first_name, obj.last_name)).upper()# 通过这个属性来设置展示名称upper_case_name.short_description = 'Name'class PersonAdmin(admin.ModelAdmin): list_display = (upper_case_name,)#-----------class PersonAdmin(admin.ModelAdmin): list_display = ('upper_case_name',) def upper_case_name(self, obj): return (\"%s %s\" % (obj.first_name, obj.last_name)).upper() upper_case_name.short_description = 'Name'#----------------from django.contrib import adminfrom django.db import modelsclass Person(models.Model): name = models.CharField(max_length=50) birthday = models.DateField() def decade_born_in(self): return self.birthday.strftime('%Y')[:3] + \"0's\" decade_born_in.short_description = 'Birth decade'class PersonAdmin(admin.ModelAdmin): list_display = ('name', 'decade_born_in') 关于 list_dispaly 的一些特殊情况： 如果字段是 ForeignKey，Django 会显示该字段的 str ManyToManyField 不能被写在这里面，因为这需要对表中的每一个执行一个单独的 SQL 语句。如果你确实想这么做，可以提供一个 model 自定义方法，并且将这个方法名写在 list_display 中 如果是布尔值，Django将显示一个 on 或 off 的图标 如果是给定 model ModelAdmin 或callable，Django会对输出进行 HTML转义 12345678910111213141516171819from django.contrib import adminfrom django.db import modelsfrom django.utils.html import format_htmlclass Person(models.Model): first_name = models.CharField(max_length=50) last_name = models.CharField(max_length=50) color_code = models.CharField(max_length=6) def colored_name(self): return format_html( '&lt;span style=\"color: #&#123;&#125;;\"&gt;&#123;&#125; &#123;&#125;&lt;/span&gt;', self.color_code, self.first_name, self.last_name, )class PersonAdmin(admin.ModelAdmin): list_display = ('first_name', 'last_name', 'colored_name') 通常，list_display 中不是实际数据库字段的元素不能用于排序，但如果 list_display 的元素表示某个数据库字段，则可以通过设置项的 admin_order_field 属性来表明。 12345678910111213141516171819from django.contrib import adminfrom django.db import modelsfrom django.utils.html import format_htmlclass Person(models.Model): first_name = models.CharField(max_length=50) color_code = models.CharField(max_length=6) def colored_first_name(self): return format_html( '&lt;span style=\"color: #&#123;&#125;;\"&gt;&#123;&#125;&lt;/span&gt;', self.color_code, self.first_name, ) colored_first_name.admin_order_field = 'first_name'class PersonAdmin(admin.ModelAdmin): list_display = ('first_name', 'colored_first_name') list_display 中的字段名将作为 css class 出现在 HTML 中 Django 将按照以下顺序 interpret 每一个 list_display 上的元素： model 的字段 callable ModelAdmin 属性字符串 model 属性字符串 ModelAdmin.list_display_links | 展示页规定 list_display 中哪个字段链接到对应对象的更改页面，默认是列表的第一列 可以设置多个，但必须在 list_display 中，也可以置空 ModelAdmin.list_editable | 展示页 元组（列表），必须包含在 list_display 中不能喝 list_display_links 重合 允许在展示页直接对某些元素进行修改 ModelAdmin.list_filter | 展示页元组（列表），必须包含在 list_display 中 在展示页右侧新增一个通过规定内容进行过滤的过滤器 允许是以下类型之一： 字段名，可以通过双下划线进行跨关系查找 继承自 django.contrib.admin.SimplateFilter 的类，需要提供 title 和 parameter_name 属性重写 lookups 和 queryset 方法 元组，第一个元素是字段名，第二个是 django.contrib.admin.SimplateFilter 类的子类 ModelAdmin.list_max_show_all | 展示页 管理 show all admin change list page 可以显示多少项，默认200只有当总数少于设置项时才会显示 show all 按钮 ModelAdmin.list_per_page | 展示页 展示页每页显示数目，默认100 ModelAdmin.list_select_related | 展示页？ select_related主要针一对一和多对一关系进行优化。select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。 设置 list_select_related 告诉 Django 使用 select_related() 在更改页面检索对象列表时 布尔值，列表或元组，默认为 False当时 True 时，始终调用 select_related；False时，查看 list_display 在存在 ForeignKey 时调用 select_related 使用元组（或列表）进行更细粒度的控制，空元组会阻止 Django 使用 select_related，任何其他的元组都会直接传递给 select_related 作为参数 如果需要根据请求指定一个动态值，可以实现一个get_list_select_related（）方法。 ModelAdmin.ordering | 展示页 设置排序，列表或元组如果需要指定动态顺序（例如根据用户或语言），可以实现get_ordering（）方法。 ModelAdmin.paginator | 展示页 规定要用于分页的 paginator 类 默认 django.core.paginator.Paginator 自定义分页类需要继承 django.core.paginator.Paginator 而却需要提供 ModelAdmin.get_paginator() ModelAdmin.prepopulated_fielads 将预填充字段设置为字典，将字段名称映射到应预填充的字段 ModelAdmin.preserve_filters | 展示页面 站点会在创建、编辑或删除对象后在列表视图中保留过滤器。 ModelAdmin.radio_fields | 创建或修改 默认情况下，Django的管理员对 ForeignKey 或设置了选项的字段使用选择框界面（）。如果一个字段出现在 radio_fields 中，Django 将使用一个单选按钮接口。 字典形式，有HORIZONTAL 和 VERTICAL 两个选项 1radio_fields = &#123;\"field_name\": admin.VERTICAL&#125; ModelAdmin.autocomplete_fields | 新增，修改 元组或列表，里面放入一对多或多对多字段，在新增或修改的时候可以通过异步搜索查找需要的选项 ModelAdmin.raw_id_fields | 新增，修改 元组或列表，里面放入一对多或多对多字段，默认情况下一对多或多对多会使用下拉菜单，但如果将他们放入这个选项中将取消他们的下拉菜单直接给出一个输入框供用户手动输入，并且给出一个查找图标，点击图标后可以通过一个弹出页面查看全部选项并进行选择 ModelAdmin.readonly_fields | 新增，修改 元组或列表，放置在此选项的字段会从新增或修改页面消失 ModelAdmin.save_as | 修改页面 默认为 False 默认情况下修改页面会显示：保存并增加另一个、保存并继续编辑、保存三个按钮，如果为True会将保存并新增另一个修改为保存为新对象 ModelAdmin.save_as_continue | 修改页面 默认为 True 如果为 False 在修改对象之后重定向到 changelist view ModelAdmin.save_on_top | 新增 | 修改 一般来说保存按钮在底部，如果设为 True 底部和顶部都有 默认为 False ModelAdmin.search_fields | 展示页 元组或列表 设置此选择项后会在展示页显示一个搜索栏 被填入的字段应该是文本字段，也可以使用双下划线来查找 ForeignKey 或 ManyToManyField 的内容 using the icontains lookup example, if search_fields is set to [‘first_name’, ‘last_name’] and a user searches for john lennon, Django will do the equivalent of this SQL WHERE clause: 12WHERE (first_name ILIKE &#39;%john%&#39; OR last_name ILIKE &#39;%john%&#39;)AND (first_name ILIKE &#39;%lennon%&#39; OR last_name ILIKE &#39;%lennon%&#39;) 如果不想使用icontains作为查找，可以通过将其附加到字段来使用任何查找。例如，您可以通过将search_fields设置为 [&#39;first_name_uuexact&#39;] 来使用 exact。 ModelAdmin.show_full_result_count | 展示页 是否在展示页显示全部的结果数，默认为 True，默认情况下会产生一个额外的查询，而且如果数据量特别大的话这个查询会很消耗资源 ModelAdmin.sortable_by | 展示页 如果要对某些列禁用排序，请将sortable_by设置为要排序的list_display子集的集合（例如list、tuple或set）。空集合将禁用所有列的排序。 如果需要动态指定此列表，请改为实现get_sortable_by（）方法。 ModelAdmin.view_on_site | 新增，修改 此属性用来控制是否显示 View on stie 连接，这个链接会把你带到一个可以显示保存对象的URL custom template options使用以下选项覆盖ModelAdmin视图使用的默认模板： ModelAdmin.add_form_template Path to a custom template, used by add_view(). ModelAdmin.change_form_template Path to a custom template, used by change_view(). ModelAdmin.change_list_teimplate Path to a custom template, used by changelist_view(). ModelAdmin.delete_confirmation_template Path to a custom template, used by delete_view() for displaying a confirmation page when deleting one or more objects. ModelAdmin.delete_selected_confirmaton_template Path to a custom template, used by the delete_selected action method for displaying a confirmation page when deleting one or more objects. See the actions documentation. ModelAdmin.object_history_template Path to a custom template, used by history_view(). ModelAdmin.popup_response_template Path to a custom template, used by response_add(), response_change(), and response_delete(). ModelAdmin methods ModelAdmin.save_model(request, obj, form, change) 此方法需要传入一个 HttpRequest 一个 model 实例 一个 ModelForm 实例 一个决定此操作是新增还是修改的布尔值 重写这个方法允许做一些前置或者后置保存操作，调用 super().save_model() 使用 Model.save() 来保存对象 ModelAdmin.delete_model(request, obj) 此方法需要传入一个 HttpRequest 对象和一个 model 实例 重写此方法允许做一些前置或后置操作 调用 super().delete_model() 使用 Model.delete() 来删除对象 ModelAdmin.delete_queryset(request, queryset) 重写此方法以自定义 删除选定对象 操作的删除过程 ModelAdmin.save_formset(request, form, formset, change) 此方法需要传入一个 HttpRequest 一个 父类 ModelForm 实例 和一个决定是执行新增操作还是执行修改操作的布尔值 ModelAdmin.get_ordering(request) 返回一个类似 ordering 参数的列表或元组 ModelAdmin.get_search_results(request, queryset, search_term) 此方法提供使用 search 组件的搜索结果。接受一个 request和一个queryset使用当前filter和用户提供的搜索内容。还接受一个布尔值用来规定结果中是否允许重复值 ModelAdmin.save_related(request, form, formsets, change) Here you can do any pre- or post-save operations for objects related to the parent. Note that at this point the parent object and its form have already been saved. ModelAdmin.get_autocomplete_fields(request) return a list or tuple of field names that will be displayed with an autocomplete widget as described above in the ModelAdmin.autocomplete_fields section. ModelAdmin.get_readonly_fields(request, obj=None) ModelAdmin.get_prepopulated_fields(request, obj=None) ModelAdmin.get_list_display(request) ModelAdmin.get_list_display_links(request, list_display) ModelAdmin.get_exclued(reqquest, obj=None) ModelAdmin.get_fields(request, obj=None) ModelAdmin.fields(request, obj=None) ModelAdmin.getfieldsets(request, obj=None) ModelAdmin.get_list_filter(request) ModelAdmin.get_list_select_related(request) ModelAdmin.get_search_fields(request) ModelAdmin.get_sortable_by(request) ModelAdmin.get_inline_instances(request, obj=None) ModelAdmin.get_urls() The get_urls method on a ModelAdmin returns the URLs to be used for that ModelAdmin in the same way as a URLconf. ModelAdmin.get_form(reqeust, obj=None, **kwargs) Returns a ModelForm class for use in the admin add and change views, see add_view() and change_view(). ModelAdmin.get_formsets_with_lines(request, obj=None) ModelAdmin.formfield_for_foreignkey(db_field, request, **kwargs) ModelAdmin.formfield_for_manytomant(db_field, request, **kwargs) ModelAdmin.fromfield_for_choice_field(db_field, request, **kwargs) ModelAdmin.get_changelist(request, **kwargs) ModelAdmin.get_changelist_form(request, **kwargs) ModelAdmin.get_changelist_formset(request, **kwargs) ModelAdmin.lookup_allowed(lookup, value) ModelAdmin.has_view_permission(request, obj=None) ModelAdmin.has_add_permission(request) ModelAdmin.has_change_permission(request, obj=None) ModelAdmin.has_delete_permission(request, obj=None) ModelAdmin.han_module_permission(request) ModelAdmin.get_queryset(request) ModelAdmin.message_user(request, message, level=meeesages.INFO, extra_tags=”, fail_silently=False) ModelAdmin.get_paginator(request, queryset, per_page, orphans=0, allwo_empty_first_page=True) ModelAdmin.response_add(request, obj, post_url_continu=None) ModelAdmin.response_change(request, obj) ModelAdmin.request_delete(request, obj) ModelAdmin.get_changeform_inital_data(request) ModelAdmin.get_deleted_objects(objs, request) Other methods ModelAdmin.add_view(request, form_url=””, extra_context=None) ModelAdmin.change_view)request, object_id, form_url=””, extra_context=None) ModelAdmin.changelist_view(request, extra_context=None) ModelAdmin.delete_view(request, object_id, extra_context=None) ModelAdmin.history_view(request, object_id, extra_context=None) ModelAdmin asset definitions123456class ArticleAdmin(admin.ModelAdmin): class Media: css = &#123; \"all\": (\"my_styles.css\",) &#125; js = (\"my_code.js\",) jQueryAdding custom validation to the adminInlineModelAdmin objects123class InlineModelAdminclass TabularInlineclass StackedInline 123456789from django.contrib import adminclass BookInline(admin.TabularInline): model = Bookclass AuthorAdmin(admin.ModelAdmin): inlines = [ BookInline, ] InlineModelAdmin options略 Working with a model with two or more foreign keys to the same parent model略 Working with many-to-may models略 Working with many-to-many intermediary models略 Using generic relation as an inline略 Overrding admin templates覆盖管理模块用于生成管理站点的各种页面的许多模板相对容易。您甚至可以为特定的应用程序或特定模式覆盖其中的一些模板 If you have customized the ‘loaders’ option, be sure ‘django.template.loaders.filesystem.Loader’ appears before ‘django.template.loaders.app_directories.Loader’ so that your custom templates will be found by the template loading system before those that are included with django.contrib.admin. 如果要修改 my_app 目录下全部 model 视图列表可以复制文件到 templates/admin/my_app 如果想要添加一个 tool 在 change list 视图仅仅为一个叫 Page 的 model。可以赋值相同文件到 templates/admin/my_app/page 中 Set up your projects admin template directoriesfirst create an admin directory in your project’s templates directory. Overriding vs replacing an admin template通常不建议替换整个模板，最好只覆盖需要更改的模板部分 Templates which may be overridden per app or model略 Root and login templates略 AdminSite Object一个 Django 管理站点由 django.contrib.admin.sites.AdminSite 的实例来表示，默认情况下，这个类的实例被创建为 django.contrib.admin.site，你可以用它来注册你的模型和 ModelAdmin 实例。 可以通过覆盖它来自定义默认的管理站点。 当构造 AdminSite 实例时，可以使用构造函数的 name 参数提供一个唯一的实例名。这个实例名是用来识别实例的，特别是在 reversing admin URLs。如果没有提供，将使用名人的 admin AdminSite attributes site_header放在页面顶部的文字作为 H1 内的内容，默认：Django 管理 site_title页面 title 结尾处放置的文字，默认：Django 站点管理员 site_url管理页面顶部 查看站点 链接的 URL，默认：/，设为 None 可以删除该链接 index_title管理站点首页顶部展示的文字，默认：网站管理 index_templatewill be used by the admin site main index view. app_index_templatewill be used by the admin site app index view. empty_value_display用于在 change list 显示空值，默认为破折号。也可以被 ModelAdmin.empty_value_display 覆盖 login_templatewill be used by the admin site login view. login_formwill be used by the admin site login view. logout_templatePath to a custom template that will be used by the admin site logout view. password_change_templatewill be used by the admin site password change view. password_change_done_templatewill be used by the admin site password change done view. AdminSite methods AdminSite.each_context(request)返回变量字典，用来放在 admin site 中每个页面的模板上下文中 默认情况下包括以下变量和值： site_header:Adminsite.site_header site_title:AdminSIte.site_title site_url:AdminSite.site_url has_permission:Admin.has_permission() available_apps: 当前用户可以使用的应用程序注册表中的应用程序列表。列表中的每个条目都是一个代表 application 的字典，其键如下： app_label: 应用的 label app_url：应用在 admin 中的 index URL has_module_perms：表示是否允许当前用户显示和访问模块 index 页面的布尔值 models：应用程序中可用模型列表，每个 model 都是一个字典，包含以下几个键 object_name：model 的类名 name：复数名 perms：一个跟踪添加、更改、删除和查看权限的字典 admin_url：admin changelist URL for the model add_url：admin URL to add a new model instance AdminSite.has_permission(request)如果 HttpRequest 提供的用户邮权限查看管理员站点中至少一个页面，返回 True。默认要求 User.is_active 和 User.is_staff 为 True。 AdminSite.register(model_or_iterable, admin_class=None, **options)admin_class 默认是 ModelAdmin。如果给定关键字参数，会作为选项应用到 admin 类 如果一个模型是抽象的，会引发 ImproperlyConfigured 如果模型已经注册，会引发 django.contrib.admin.sites.AlreadyRegistered Hocking AdminSite instances into your URLconf略 Customizing the AdminSite class略 Overriding the default admin site略 Multiple admin sites in the same URLconf略 Adding views to admin sites略 Adding a password reset feature略 LogEntry objectsLogEntry类跟踪通过管理接口完成的对象的添加、更改和删除。 LogEntry attributes LogEntry.action_time The date and time of the action. LogEntry.user The user (an AUTH_USER_MODEL instance) who performed the action. LogEntry.content_type The ContentType of the modified object LogEntry.object_id The textual representation of the modified object’s primary key. LogEntry.object_repr The object`s repr() after the modification. LogEntry.ation_flag The type of action logged: ADDITION, CHANGE, DELETION. LogEntry.change_message The detailed description of the modification. LogEntry methods LogEntry.get_edited_object() A shortcut that returns the referenced object. LogEntry.get_change_message() Reversing admin URLsAdminSite Page URL name Parameters Index index Login login Logout logout Password change password_change Password change done password_change_done i18n JavaScript jsi18n Application index page app_list app_label Redirect to object’s page view_on_site content_type_id, object_id ModelAdmin Page URL name Parameters Changelist __changelist Add -_add History -_history object_id Delete -_delete object_id Change -_change object_id UserAdmin Page URL name Parameters Password change auth_user_password_change user_id The staff_member_required decorator","tags":[{"name":"Django","slug":"Django","permalink":"https://wiki.blanc.site/tags/Django/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://wiki.blanc.site/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Django","slug":"2-软件使用/Django","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Django/"}]},{"title":"Django app 笔记","date":"2020-08-11T00:00:00.000Z","path":"archives/44c1e81d.html","text":"记以下内容是我阅读 Django 官方文档 app 相关内容时随手翻译的，内容未经整理 源码分析django.appsinit.py向外部提供 AppConfig apps 两个属性 模块 提供内容 config.py AppConfig registry.py apps config.py提供一个 AppConfig 类 registry.py提供一个 Apps 类 ApplicationDjango 包含一个已安装 apps 的注册表，它存储配置信息并提供 introspection。它还维护着一个可用模型的列表。 这个注册表简称为 apps，在 django.apps 中可以找到： 12from django.apps import appsapps.get_app_config('admin').verbose_name 项目和应用（projects and applications）Project 一词描述了一个 Django Web Application。 一个 projects 的根目录（包含 manage.py 的目录）通常是一个存放所有 projects 中未单独安装的 applications 的容器 Applications 一词描述了一个提供一些功能集的 Python package。Applications 可以在不同 projects 中重复使用。 Applications 是由 models views templates tempalte tags static files URLs middleware等模块自由组合而成。它们一般是用过写入 INSTALLED_APPS 配置相中或一些其他机制（如 URLconfis MIDDLEWARE 设置或模板继承）连接到项目中。 理解 Django applications 是一组与框架各部分交互的代码 很重要。实际上并不存在 Application 对象。然而，在某些情况下 Django 需要和已安装的 Application 进行交互，主要是为了配合，有时也为了 introspection。这也是为什么应用注册表为每个安装的应用在 AppConfig 实例中维护元数据。 Django 没有限制一个 project package 不能同时作为一个 Application，并拥有 models 等。（如果真的把 project package 也当做一个应用，需要将它添加到 INSTALLED_APPS 里） 配置应用（Configuring applications）要配置一个 application，就需要子类化 AppConfig，并在 INSTALLED_APPS 中配置该子类的路径。 当 INSTALLED_APPS 中包含一个应用模块的路径时，Django 会检查该模块中是否存在 default_app_config 变量 如果有，它就是该应用对应的的 AppConfig 子类 如果没有，Django 就使用基础的（默认的）AppConfig 类 default_app_config 允许 Django.contrib.admin 等早于 Django 1.7 的应用选择加入 AppConfig 功能，而不需要用户更新他们的 INSTALLED_APPS。 新的应用程序应该避免使用 default_app_config。相反，他们应该要求在 INSTALLED_APPS 中明确配置相应的 AppConfig 子类的虚线路径。 对于 application 创建者如果正在创建一个叫做 Rock 的可插拔 app，下面这个例子描述了如何为 admin 提供一个合适的名字 ： 1234567# rock/apps.pyfrom django.apps import AppConfigclass RockConfig(AppConfig): name = \"rock\" verbose_name = \"Rock\" 可以通过下面的代码将 application 加载到 AppConfig 子类中： 123# rock/__init__.pydefault_app_config = \"rock.apps.RockConfig\" 这样就可以实现只需要在 INSTALLED_APPS 中设置 “rock” 就可以将 RockConfig 导入。这样就可以在不需要用户更新 INSTALLED_APPS 设置的情况下使用 AppConfig 功能。除了这个使用场景（用例）之外最好避免使用 default_app_config，而在 INSTALLED_APPS 中指定 app config class，如下。 当然，同样可以在 INSTALLED_APPS 中添加 rock.apps.RockConfig 实现同样的效果。甚至可以提供多个不同行为的 AppConfig 子类，让用户荣国 INSTALLED_APPS 设置选择其中某一个。 推荐将配置类放在 application 目录下名为 apps 的模块中。但是 Django 并没有强制要求。 配置中必须包含 name 属性来确定这个配置适用于那个应用。 对于 application 用户略 Application configraution123# django.app.configclass AppConfig: pass Configurable attributes AppConfig.nameApplication 完整的 Python 路径，例如：django.contrib.admin它在 Django project 中必须是唯一的 AppConfig.labelApplication 的短一点的名字，例如：admin AppConfig.verbose_nameApplication 人类可读的名字，例如：Administration AppConfig.path指向 Application 文件的完整路径 Read-only attributes AppConfig.moduleApplication 的跟模块，例如：&lt;module ‘django.contrib.admin’ from ‘django/contrib/admin/init.py’&gt; AppConfig.models_module包含 model 的模块中，例如：&lt;module ‘django.contrib.damin.models’ from ‘django/contrib/admin/models.py&gt;如果 Application 不包含 models 模块，则可能是 None。需要注意：pre_migrate 和 post_migrate 等与数据库相关的信号支队有 models 模块的应用发出 Methods AppConfig.get_models()返回这个 Application 的 Model iterable AppConfig.get_model(model_name, require_ready=True)根据给出的 model_name.model_name 返回 Model（不区分大小写） 如果 Application 中不存在这个模块抛出 LookupError 除非 require_ready 参数为False，否则要求 app 注册表被完全填充。require_ready的行为与app.get_model()中的行为完全相同。 AppConfig.ready()子类可以重写这个方法来执行初始化任务，比如注册信号。一旦注册表被完全 populated 它就会被调用 123456789from django.db.models.signals import pre_savedef ready(self): # importing model classes from .models import MyModel # or... MyModel = self.get_model('MyModel') # registering signals with the model's string label pre_save.connect(receiver, sender='app_label.MyModel') 虽然可以像上面描述的一样访问模型类，但要避免在 ready 中与数据库进行交互 通常情况下 ready 只会被调用一次。但是在某些特殊情况下（特别是在测试中）会被调用不止一次。在这种情况下，要么写idempotent方法，要么在你的AppConfig类上加一个标志，以防止重新运行那些应该被精确执行一次的代码。 Namespace packages as apps略 Application registry apps.ready布尔值，在注册完全 populated 并且所有 AppConfig.ready() 函数被调用后设为 True apps.get_app_configs()返回一个 AppConfig 实例 iterbale apps.get_app_config(app_label)通过给出的 app_label 返回 Application 的 AppConfig，如果不存在的话抛出 LookupError apps.is_installed(app_name)检查给出的 app 是否存在于注册表。app_name 是完整名字，例如：django.contrib.admin apps.get_model(app_label, model_name, require_ready=True)通过给出的 app_label 和 model_name 返回 Model。 Initialization processHow applications are loaded当 Django启动，django.setup() 负责填充应用程序注册表 setup(set_prefix=True) 通过以下内容配置 Django： Loading the settings setting up logging 如果set_prefix为True，如果定义了URL解析器脚本前缀，则将其设置为FORCE_SCRIPT_NAME，否则为/。 初始化应用程序注册表 此函数会在一下情况下被自动调用： 当通过 Django WSGI 运行 HTTP 服务时 当运行一个管理命令时在其他情况下，例如在 Python scripts 中，必须显示调用该函数 应用程序注册表的初始化分为三个阶段。在每个阶段，Django都会按照INSTALLED_APPS的顺序处理所有的应用程序。 首先，Django导入INSTALLED_APPS中的每个项目。 如果是应用配置类，Django会导入应用的根包，由其name属性定义。如果是一个Python包，Django会创建一个默认的应用配置。 在这个阶段，你的代码不应该导入任何模型! 换句话说，你的应用程序的根包和定义应用程序配置类的模块不应该导入任何模型，即使是间接导入。 严格来说，Django允许在加载应用配置后导入模型。但是，为了避免对INSTALLED_APPS的顺序进行不必要的限制，强烈建议不要在这个阶段导入任何模型。 一旦这个阶段完成，对应用配置进行操作的API，如get_app_config()就可以使用了。 然后Django会尝试导入每个应用的models子模块，如果有的话。 你必须在你的应用程序的models.py或models/init.py中定义或导入所有模型。否则，应用程序注册表可能在此时没有完全填充，这可能导致ORM故障。 一旦这个阶段完成，对模型进行操作的API，如get_model()就可以使用了。 最后Django会运行每个应用配置的ready()方法。","tags":[{"name":"Django","slug":"Django","permalink":"https://wiki.blanc.site/tags/Django/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://wiki.blanc.site/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Django","slug":"2-软件使用/Django","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Django/"}]},{"title":"所谓 WSGI","date":"2020-06-24T00:00:00.000Z","path":"archives/7a294715.html","text":"注意 如果你也想阅读 WSGI 相关的 PEP 规范，建议直接阅读 PEP 3333，因为 PEP 3333 对 PEP 333 是向下兼容的，也可以说 PEP 3333 是对 PEP 333 的补充。 何为 WSGI？ This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application portability across a variety of web servers. 本文档详细描述了一个建议用在 Web 服务器和 Python Web 应用或框架之间的标准接口，以提升 Web 应用在各类 Web 服务器之间的可移植性。 from PEP 3333 从 PEP 3333 的这段总结来看，WSGI 就是一个 Python 官方建议用在 Web 服务器和 Python Web 应用框架之间的标准接口。 何为 Web 服务器首先，什么是服务器（server）？一般来说，server 有两重意思： 有时 server 表示硬件，也就是一台机器，也可称为「主机」； 更多的时候 server 表示软件程序，这种程序主要用来对外提供某种服务，比如：邮件服务、FTP 服务、数据库服务、网页服务等等。 作为开发者，一般提到 server 时指的都是后者，即一个长时间运行的软件程序。 所以，什么是 Web Server？通俗的来讲 Web Server 就是一个提供 Web 服务的应用程序。常见的符合 WSGI 规范的 Web Server 有 uWSGI、gunicorn 等等。 何为 Web 应用或框架Web 框架在如今是比较常见的，比较知名的 Python Web 框架有：Django、Flask、Pyramid等等。反倒是 Web 应用不太常见，（个人理解）一般情况下只有在本地测试的时候会写一些简单的 Python Web 应用，平时的开发大多还是使用开源（或公司内部）的 Web 框架。 为什么需要 WSGI作为一个近两年刚接触到 Python Web 编程的新手，在日常的编程过程中完全没有见过所谓的 WSGI，但是我依然可以写好一个完整的 Web 应用，这是为什么？WSGI 有存在的必要嘛？ 答案肯定是：有存在的必要。 首先解释一下为什么我在过去两年的过程中没有见过 WSGI 却依旧可以进行 Web 编程：因为现在的大多数框架都已经帮我们将 WSGI 标准封装在框架底层。甚至，我用的 Django REST Framework 框架连 HTTP Request 和 HTTP Response 都帮我封装好了。所以，就算我完全不了解 WSGI 这种偏底层的协议也能够进行日常的 Web 开发。 那 WSGI 到底解决了什么问题？这个在 PEP 3333 中有详细的解释，简单的说一下我的理解：在 WSGI 诞生之前，就已经存在了大量使用 Python 编写的 Web 应用框架，相应的也存在很多 Web 服务器。但是，各个 Python Web 框架和 Python Web 服务器之间不能互相兼容。夸张一点说，在当时如果想要开发一个 Web 框架说不定还得单独为这个框架开发一个 Web 服务器（而且这个服务器别的框架还不能用）。为了解决这一现象 Python 社区提交了 PEP 333，正式提出了 WSGI 这个概念。 简单的理解：只要是兼容 WSGI 的 Web 服务器和 Web 框架就能配套使用。开发服务器的程序员只需要考虑在兼容 WSGI 的情况下如何更好的提升服务器程序的性能；开发框架的程序员只需要考虑在兼容 WSGI 的情况下如何适应尽可能多业务开发逻辑（以上只是举例并非真的这样）。 WSGI 解放了 Web 开发者的精力让他们可以专注于自己需要关注的事情。 WSGI 做了什么事情？注：为了简练而写成了 WSGI 做了什么事情，实际上 WSGI 只是一个规范并不是实际的代码，准确的来说应该是「符合 WSGI 规范的 Web 体系做了什么事情？」 上面已经提到，WSGI 通过规范化 Web 框架和 Web 服务器之间的接口，让兼容了 WSGI 的框架和服务器能够自由组合使用…… 所以，WSGI 究竟做了什么，让一切变得如此简单？ 在 PEP 3333 中对 WSGI 进行了一段简单的概述，这里我结合看过的 一篇博文 进行简单的概括： （简单来说）WSGI 将 Web 分成了三个部分，从上到下分别是：Application/Framework, Middleware 和 Server/Grageway，各个部分之间高度解耦尽可能的做到不互相依赖。 （通常情况下）客户端（一般为浏览器）会向 Server 发送 HTTP 请求以获取数据。 符合 WSGI 规范的 Server 在接收到请求之后会调用指定的符合 WSGI 规范的 Web Application，并传入 environ 和 start_response 两个参数（并不强制命名，只是一般会这么命名）。 Web Application 在接收到请求后会生成一个打包好的 HTTP Response 传给 start_response。 Server 会将 HTTP Response 进行汇总待请求处理完且没有错误时将整个 HTTP Response 内容返回给客户端。 Middleware 属于三个部分中最为特别的一个，对于 Server 他是一个 Application，对于 Application 它是一个 Server。通俗的来说就是 Middleware 面对 Server 时能够展现出 Application 应有的特性，而面对 Application 时能够展现出 Server 应有的特性，由于这一特点 Middleware 在整个协议中起到了承上启下的功能。在现实开发过程中，还可以通过嵌套 Middleware 以实现更强大的功能。 WSGI 是如何工作的？通过上一小节能够大概的了解到 WSGI 在一次完整的请求中究竟做了什么。下面再来介绍一下一个完整的 WSGI Web 体系是如何工作的。 一个符合 WSGI 规范的 Python Web 项目实例为了方便展示先来构建一个符合 WSGI 规范的 Python Web 项目示例： 源码注：示例基于 Python3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# 本示例代码改自参考文章 5：# Huang Huang 的博客-翻译项目系列-让我们一起来构建一个 Web 服务器# /path_to_code/server.py# Examples of wsgi serverimport sysimport socket# 根据系统导入响应的 StringIO 模块# StringIO：用于文本 I/O 的内存数据流try: from io import StringIOexcept ImportError: from cStringIO import StringIOclass WSGIServer(object): request_queue_size = 1 # 请求队列长度 address_family = socket.AF_INET # 设置地址簇 socket_type = socket.SOCK_STREAM # 设置 socket 类型 def __init__(self, server_address): # Server 初始化方法（构造函数） # Create a listening socket self.listen_socket = listen_socket = socket.socket( self.address_family, self.socket_type ) # 设置 socket 允许重复使用 address listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # Bind 绑定端口 listen_socket.bind(server_address) # Activate 激活 listen_socket.listen(self.request_queue_size) # 获取并记录 server host 和 port host, port = self.listen_socket.getsockname()[:2] self.server_name = socket.getfqdn(host) self.server_port = port # Return headers set by Web framework/application self.headers_set = [] def set_app(self, application): # 将传入的 application 设置为实例属性 self.application = application def server_forever(self): # 开启 server 循环函数 listen_socket = self.listen_socket while True: # 获取 client socket 参数 | client_connection 是 client socket 实例 # 这里会创建一个阻塞，直到接受到 client 连接为止 self.client_connection, client_address = listen_socket.accept() # 调用 handle_one_request 方法处理一次请求并关闭 client 连接然后继续等待新的连接进入 self.handle_one_request() def handle_one_request(self): # 处理请求的入口方法 | 用来处理一次请求 # 从 client socket 中获取 request data self.request_data = request_data = self.client_connection.recv(1024) # 调用 parse_request 方法， 传入接收到的 request_data 并对其进行解析 self.parse_request(request_data) # 通过已有数据构造环境变量字典 environ = self.get_environ() # 调用 application，传入已经生成好的 environ 和 start_response，返回一个可迭代的 Response 对象 result = self.application(environ, self.start_response) # 调用 finish_response 方法，构造一个响应并返回给客户端 self.finish_response(result) def parse_request(self, text): # 取行 request_line = text.splitlines()[0] # 打碎请求行到组件中 (self.request_method, self.path, self.request_version ) = request_line.split() def get_environ(self): env = &#123;&#125; env[\"wsgi.version\"] = (1, 0) env[\"wsgi.url_scheme\"] = \"http\" env[\"wsgi.input\"] = StringIO(self.request_data.decode(\"utf-8\")) env[\"wsgi.errors\"] = sys.stderr env[\"wsgi.multithread\"] = False env[\"wsgi.multiprocess\"] = False env[\"wsgi.run_once\"] = False # Required CGI variables env[\"REQUEST_METHOD\"] = self.request_method env[\"PATH_INFO\"] = self.path.decode(\"utf-8\") env[\"SERVER_NAME\"] = self.server_name env[\"SERVER_PORT\"] = str(self.server_port) return env def start_response(self, status, response_headers, exc_info=None): # 按照 WSGI 规范提供一个 start_response 给 application # Add necessary必要的 server headers server_headers = [ (\"Date\", \"Tue, 31 Mar 2020 12:51:48 GMT\"), (\"Server\", \"WSGIServer 0.2\") ] self.headers_set = [status, response_headers + server_headers] # 按照 WSGI 协议，应该在这里返回一个 write()，但这里为了简便就省略了 # 会在后续分析 wsgiref 源码时提及此处 def finish_response(self, result): # 通过现有参数整理出一个响应体 try: status, response_headers = self.headers_set # 响应第一部分：HTTP 协议以及状态码 response = f\"HTTP/1.1 &#123;status&#125;\\r\\n\" # 响应第二部分：将生成好的响应头递归式的传入响应体内 for header in response_headers: response += \"&#123;0&#125;: &#123;1&#125;\\r\\n\".format(*header) # 通过 \\r\\n 进行空行 response += \"\\r\\n\" # 响应第三部分：将响应主题信息追加到响应体内 for data in result: response += data # 通过 senall 将响应发送给客户端 # 注意：在 Python3 下，如果你构建的响应体为 str 类型，需要进行 encode 转换为 bytes self.client_connection.sendall(response.encode()) finally: # 关闭连接 self.client_connection.close() 1234567891011121314# /path_to_code/middleware.py# Examples of wsgi middlewareclass TestMiddleware(object): def __init__(self, application): self.application = application def core(self, environ, start_response): old_response = self.application(environ, start_response) new_response = old_response + [\"middleware add this message\\n\"] return new_response def __call__(self, environ, start_response): return self.core(environ, start_response) 1234567# /path_to_code/application.py# Examples of wsgi applicationdef application(environ, start_response): status = \"200 OK\" response_headers = [(\"Content-Type\", \"text/plain\")] start_response(status, response_headers) return [\"hello world from a simple WSGI application!\\n\"] 12345678910111213141516# /path_to_code/run.py# running Examplefrom server import WSGIServerfrom application import applicationfrom middleware import TestMiddleware# 规定 server host 和 server portserver_address = (host, port) = \"\", 8888# 创建 server 实例server = WSGIServer(server_address)# 设置本 server 对应的 middleware 以及 applicationserver.set_app(TestMiddleware(application))# 输出提示性语句print(f\"WSGIServer: Serving HTTP on port: &#123;port&#125;...\\n\")# 进入 server socket 监听循环server.server_forever() 运行将四段代码分别复制到同一目录的四个文件（如果没有按照示例给出的命名记得更改一下 run 模块中相应的 import 的模块名）中。 注：以下操作默认你完全按照示例代码中给出的命名进行文件命名 启动 server：python /path_to_code/run.py 通过浏览器浏览 127.0.0.1:8888 查看效果 通过 curl 命令 curl -v http://127.0.0.1:8888 查看完整输出 对比 curl -v https://baidu.com 的输出查看区别 分析代码运行流程分析上面我根据 WSGI 协议编写了三个文件（模块）：server.py middleware.py application.py，分别对应 WSGI 里 server middleware application 这三个概念。然后通过 run.py 引入三个模块组成了一个完整的 server-middleware-application Web 程序并监听本地 8888 端口。 通过 run.py 中的代码我们能够清晰的看到一个 WSGI 类型的 Web 程序的运行流程： 创建 wsgi server socket 实例对象（调用 server.__init__ 方法） 将准备好的 middleware 以及 application 对象导入给 server 实例（调用 server.set_app 方法） 运行 server 监听指定端口（调用 server.server_forever 方法） 通过 server.py 中的代码能够清晰的看到一个 WSGI 类型的 Web 程序是如何处理 HTTP 请求的： 通过 server_forever 监听到客户端请求并记录请求信息 调用 handle_one_request 方法处理此请求 通过请求 socket 获取请求数据 通过 parse_request 方法将请求数据解析成所需格式 通过 get_environ 方法利用现有数据构造环境变量字典 将生成好的 environ 参数和 start_response 方法传给 application 对象（也可能是 middleware 伪装的 application 对象），并获取响应结果 将响应结果传给 finish_response 方法构造一个可迭代的响应对象返回给客户端并结束本次请求 通过 middleware.py 中的代码就能够理解一个 WSGI 中间件是如何工作的： 通过在 __init__ 方法中接收一个 application 将自己伪装成一个 server 通过在 __call__ 方法中接收 environ 和 start_response 参数将自己伪装成一个 application通过这两点伪装 middleware 能够很好的粘合在 server 和 application 之间完成中间逻辑处理，在 PEP 3333 中指明了中间件的几点常见用途。 至于 application.py 在这里就真的只是一个简单的单文件 WSGI 应用。当然也可以尝试用写好的 server.py 和 middleware.py 对接像 Django 这样的框架，但需要对代码做一些修改，这里就不展开讨论了，有兴趣可以自己尝试。 浏览器结果分析在运行 run.py 之后使用浏览器浏览 127.0.0.1:8888 并查看结果如下： 通过控制台可以清晰地看到响应头和响应主体的内容是符合我们预期的 curl 结果分析通过 curl http://127.0.0.1:8888 可以看到响应主体： 通过 curl -v http://127.0.0.1:8888 可以看到详细的请求和响应内容： 通过 curl -v https://baidu.com 获取百度首页的响应内容以作比较： 可以看到目前浏览网页常用的正常请求要比自己构建的测试示例要复杂的多，这也是为什么经常使用 Web 框架而非单文件应用来处理这些请求的原因。 解读 PEP-3333 中的某些细节PEP 3333 我只读到了 Buffering and Streaming 章节，并且没能很好的理解此章节所描述的东西，因此在下面的细节分析中大都是此章节之前的一些内容。 可迭代对象和可调用对象可迭代对象（callable）和可迭代对象（iterable）在 PEP 3333 中最常见的两个词汇，在 WSGI 规范中它们分别代表：实现了 __call__ 的对象和实现了 __iter__ 的对象。 Unicode | bytes | str这是一组比较基础的概念： Unicode 是一种字符编码标准 bytes 和 str 是 Python 中两种不同的数据类型 Python3 中字符串的默认类型是 str，在内存中以 Unicode 表示。如果要在网络中传输或保存为磁盘文件，需要将 str 转换为 bytes 类型。 Unicode | UCS | UTF Unicode（万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。Unicode 伴随着通用字符集的标准而发展，同时也以书本的形式对外发表。 UCS（Universal Character Set，通用字符集）是由ISO制定的ISO 10646（或称ISO/IEC 10646）标准所定义的标准字符集。 UTF（Unicode Transformation Format），Unicode 定义了两种映射方式：一种叫 the Unicode Transformation Format (UTF) 编码, 还有一种叫 Universal Character Set (UCS) 编码。一种编码映射一定范围（可能是子集）的 Unicode 码点（code points ）成代码值（code value）的序列。编码名字后面的数字代表一个代码值的位数（UTF使用位数，UCS 使用字节数）,UTF-8 和UTF-16是最常使用的编码。 bytes | str Python3 里面的 str 是在内存中对文本数据进行使用的，bytes 是对二进制数据使用的。 str 可以 encode 为 bytes，但是 bytes 不一定可以 decode 为 tr。实际上 bytes.decode(‘latin1’) 可以称为 str，也就是说 decode 使用的编码决定了 decode() 的成败，同样的，UTF-8 编码的 bytes 字符串用 GBK 去 decode() 也会出错。 bytes一般来自网络读取的数据、从二进制文件（图片等）读取的数据、以二进制模式读取的文本文件(.txt, .html, .py, .cpp等) from 知乎-猿人学-Python 3 中str 和 bytes 的区别 WSGI 中的 StringWSGI 中规定了两种 String： Native String（常说的 str）用来表示 request/response headers and metadata ByteString（Python3 中用 byte type 来表示）用于 request/response 的 body（例如：PUT/POST 输入和 HTML 页面输出） 在 PEP 3333 中有对这部分的详细说明。 三个主要组成部件了解了以上基础概念之后再具体的看一下 WSGI 的三个主要组成部件： Application/Framework | 下文简称 application application 是一个必须且只能接收两个参数的 callable，形如 application(environ, start_response)。而且这两个参数只能以位置参数的形式被传入。 environ 和 start_response 只是习惯性命名，对于具体传入的对象名称没有做要求。 application 必须可被多次调用，因为所有的 server/gateway（CGI 除外）都会发出此类的重复请求。 environ 是一个字典参数，包含了 CGI 风格的环境变量。必须使用内置的 Python 字典类型（不能是子类或自定义的 UserDict），并且允许 application 以任何它想要的方式修改。字典还包括某些 WSGI 变量，并且还可能包括 server 特定的拓展参数，它们的命名需要遵守相应规范。 start_response 参数也是一个 callable，接收两个必要的未知参数和一个可选参数，三个参数依次默认命名为：status, response_headers, exc_info，即 start_response(status, response_headers, exc_info=None)。 status 是一个状态字符串（str），例如：&quot;200 OK&quot; response_headers 是一个描述 HTTP Response Headers 的 (header_name, header_value) 元组列表。 可选参数 exc_info 只有当 application 捕获到错误并且视图向浏览器（客户端）显示时才会调用。 start_response callable 必须返回一个 write(body_data) callable，这个 callable 需要一个位置参数：一个要作为 HTTP 响应体一部分的 bytestring（注意：wirte callabel 只是为了支持某些现有框架的必要输出 API 而提供的；如果可以避免的话，新的 application/gateway 应该避免使用它）。 当 callable（如果实现了 write 这个 callable 指的就是 write；如果没有，这个 callable 指的就是 start_response 本身）被 server 调用时，必须返回一个产生零个或多个字符串的 iterable。可以通过多种方式实现，如：一个字符串列表、application 是一个 generator 函数或 application 是一个实现了 __iter__ 的对象。无论如何，application 必须返回一个能够产生零个或多个字符串 iterable。 application 应该负责确保被写入的字符串是适合 client 的格式的。 如果 len(iterable) 能够被成功执行（这里的 iterable 指的是第 10 条中的 iterable）则其返回的必须是一个 server 能够信赖的结果。也就是说 application 返回的 iterable 如果提供了一个有效的 __len__ 方法就必须能够获得准确值。 如果 application 返回的 iterable 有 close 方法，server 必须在当前请求完成后调用它，无论请求是否正常完成（为了支持 application 释放资源）。 application 应该检查其所需要的变量是否存在并对变量不存在的情况做好处理方案。 Server/Gateway | 下文简称 server server 必须以无缓冲（unbuffered）的方式将 yielded bytestrings 传输到 client，在下一次请求之前完成每一个 bytestring 的传输。换句话说 application 应该自己实现缓存。（对于这部分我理解的不是很透彻，大多都是直译的 PEP 3333） server 不能直接使用 application 返回的 iterable 的其他属性。 server 应该尽可能多的提供 CGI 变量。 符合 WSGI 规范的 server 应该记录所提供的变量。 Middleware middleware 是一个单独的对象，可能在一些 application 中扮演 server 同时在一些 server 中扮演 application。 WSGI 中的坑 要确定在那些地方使用 str，在那些地方使用 bytes Python wsgiref 官方库源码分析可以参考我的开源库 read-python 中 practices/for_wsgiref 目录下的 server.py 文件。 在这个文件中我提取了 Python wsgiref 官方库的必要代码汇聚成一个文件实现了一个和 wsgiref.WSGIServer 大致同样功能的 WSGIServer 类。 Python wsgiref 官方库对 WSGI 规范的实现更加抽象，加上一些历史原因使得代码分布在多个官方库中，我在抽离代码的过程中学到了很多但是同样也产生了很多困惑，我在源码中使用 TODO 疑惑 XXX 的形式将我的困惑表达出来了，如果你感兴趣并且恰好知道解决我疑惑的方法，欢迎直接给我的代码仓库提交 Issues。 参考 PEP 333 Python Web Server Gateway Interface v1.0 PEP 3333 Python Web Server Gateway Interface v1.0.1 知乎-方应杭-「每日一题」什么是 Web 服务器（server） Skyline75489-Python WSGI学习笔记 Huang Huang 的博客-翻译项目系列-让我们一起来构建一个 Web 服务器 掘金- liaochangjiang-Python Web开发：开发wsgi中间件 维基百科-Unicode 维基百科-通用字符集 知乎-猿人学-Python 3 中str 和 bytes 的区别 Python 官方文档-术语对照表","tags":[{"name":"WSGI","slug":"WSGI","permalink":"https://wiki.blanc.site/tags/WSGI/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Python","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Python","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Python/"}]},{"title":"Shell 区分不同 Unix 系统","date":"2020-04-29T00:00:00.000Z","path":"archives/b422aa7d.html","text":"区分 macOS 和 Linux12345OS=`uname -s`if [ $&#123;OS&#125; == \"Darwin\" ];then sudo brew install gitelif [ $&#123;OS&#125; == \"Linux\" ];then ... 区分不同 Linux 系统在 Linux 系统中有一个记录 OS 的发行版本的 os-release 文件，位置在 /etc/os-release。可以利用 source /etc/os-release 将文件中的 key-value 数据导入到上下文中，然后通过不同系统 ID 值不同的特性进行区分。 12345678910111213141516source /etc/os-releasecase $ID in debian|ubuntu|devuan) sudo apt-get install git ;; centos|fedora|rhel) yumdnf=\"yum\" if test \"$(echo \"$VERSION_ID &gt;= 22\" | bc)\" -ne 0; then yumdnf=\"dnf\" fi sudo $yumdnf install -y git ;; *) exit 1 ;;esac 参考 温欣爸比：如何判断 Unix 系统 OS 版本 The Linux Command Line：流程控制：case 分支","tags":[{"name":"Shell","slug":"Shell","permalink":"https://wiki.blanc.site/tags/Shell/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Shell","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Shell","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Shell/"}]},{"title":"echo","date":"2020-04-28T00:00:00.000Z","path":"archives/17043032.html","text":"简介echo 命令用于在 shell 中打印 shell 变量的值，或者直接输出指定的字符串。 语法：echo [SHORT-OPTION]... [STRING]... 详情SHORT-OPTION -n：不输出换行 -e：开启对反斜线转移的解释 -E：取消对反斜线转义的解释（默认开启） 常见反斜线转义 表达方式 含义 \\a 发出警告声 \\b 删除前一个字符 \\c 最后不加上换行符号 \\f 换行但光标仍旧停留在原来的位置 \\n 换行且光标移至行首 \\r 光标移至行首，但不换行 \\t 插入 tab \\v 与 \\f 相同 \\\\ 插入 \\ 字符 \\nnn 插入 nnn（八进制）所代表的 ASCII 字符 具体问题实现 echo 不换行输出使用场景 编写 shell 脚本编写用户输入提示 方法一：利用参数 -e12# test.shecho -e \"hello world\\c\" 方法二：利用参数 -n12# test.shecho -n \"hello world\" 参考 lllxy：echo不换行的实现 man echo Linux 命令大全-echo 命令","tags":[{"name":"Shell","slug":"Shell","permalink":"https://wiki.blanc.site/tags/Shell/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Shell","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Shell","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Shell/"}]},{"title":"通过 shell 文件激活 pyenv virtualenv 虚拟环境失败","date":"2020-04-27T00:00:00.000Z","path":"archives/911a03cb.html","text":"错误复现12# test.shpyenv acitvate env_name 123456&gt;./test.shFailed to activate virtualenv.Perhaps pyenv-virtualenv has not been loaded into your shell properly.Please restart current shell and try again. 错误原因pyenv 和 pyenv-virtualenv 未加入环境变量 解决方案1234# test.sheval \"$(pyenv init -)\"eval \"$(pyenv virtualenv-init -)\"pyenv acitvate env_name 参考 笨小康：pyenv激活虚拟环境失败 沥川：使用 pyenv 和 pyenv-virtualenv 配置虚拟环境","tags":[{"name":"pyenv","slug":"pyenv","permalink":"https://wiki.blanc.site/tags/pyenv/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"pyenv","slug":"2-软件使用/命令行工具/pyenv","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/pyenv/"}]},{"title":"vim 创建文件时根据文件类型自动添加内容","date":"2020-04-27T00:00:00.000Z","path":"archives/211d6e8d.html","text":"原理修改 .vimrc 文件，利用 autocmd 命令在创建文件时运行指定函数 实现12345678910111213&quot; 以 shell 文件为例&quot; 添加函数func SetShellNote() call setline(1, &quot;&#x2F;usr&#x2F;bin&#x2F;env bash&quot;)endfuncfunc SetTitle() call SetShellNote()endfunc&quot; 使用 autocmd 自动调用autocmd BufNewFile *.sh exec &quot;:call SetTitle()&quot; 参考 halazi100：vim创建程序文件自动添加头部注释","tags":[{"name":"vim","slug":"vim","permalink":"https://wiki.blanc.site/tags/vim/"},{"name":"效率工作","slug":"效率工作","permalink":"https://wiki.blanc.site/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E4%BD%9C/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"vim","slug":"2-软件使用/命令行工具/vim","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/vim/"}]},{"title":"Shell 获取当前脚本的绝对路径","date":"2020-04-26T00:00:00.000Z","path":"archives/8f9d5c85.html","text":"1. dirname + pwd1root_absolute_dir=$(cd \"$(dirname \"$0\")\";pwd) 2. readlink1root_absolute_dir=$(dirname $(readlink -f \"$0\")) 注意macOS 中使用 readlink -f 命令会有如下报错： 12readlink: illegal option -- fusage: readlink [-n] [file ...] 可以安装 greadlink 代替 readlink 1234# 这里仅提供使用 Homebrew 安装方法brew install greadlink# 可以修改 bash_profile 文件，添加 alias readlink=greadlink# 使用 greadlink 代替 readlink 参考 10km：bash shell:获取当前脚本的绝对路径(pwd/readlink) orientlu：shell 当前工作目录的绝对路径 macos - 如何在Mac上获取GNU的readlink -f的行为？","tags":[{"name":"Shell","slug":"Shell","permalink":"https://wiki.blanc.site/tags/Shell/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Shell","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Shell","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Shell/"}]},{"title":"自用 MongoDB 手册","date":"2020-04-20T00:00:00.000Z","path":"archives/b880b012.html","text":"原子操作命令$set指定一个键并更新键值，若键不存在则创建 $unset","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://wiki.blanc.site/tags/MongoDB/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"6-数据库","slug":"3-计算机科学/2-计算机系统/6-数据库","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"3-计算机科学/2-计算机系统/6-数据库/MongoDB","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"}]},{"title":"Django 时间字段中 auto_now 和 auto_now_add 的区别","date":"2020-04-18T00:00:00.000Z","path":"archives/dfb4f33e.html","text":"auto_now相应字段在被保存时会自动保存为当前时间。 注：每次对其实例执行 save() 操作时都令当前字段保存为当前时间。 auto_now_add无论是否赋值，相应实例第一次保存的时都会保存为当前时间。 注：之后可以手动修改。","tags":[{"name":"Django","slug":"Django","permalink":"https://wiki.blanc.site/tags/Django/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Django","slug":"2-软件使用/Django","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Django/"}]},{"title":"各种软件配置文件规范","date":"2020-04-16T00:00:00.000Z","path":"archives/4fcffd79.html","text":"MongoDBMongoDB 官方文档-配置文件选项 注：注意在文档左侧边栏最上方选择自己正在使用的版本","tags":[],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"解决 macOS 下 VOX 中文乱码问题","date":"2020-04-14T00:00:00.000Z","path":"archives/aeea741e.html","text":"环境介绍123操作系统：macOS Mojave系统版本：10.14.6软件版本：3.3.17(Build 3398.3) 解决方案⌘ + , 打开 VOX Preferences 勾选 Enable auto-charset detection，如图：","tags":[{"name":"VOX","slug":"VOX","permalink":"https://wiki.blanc.site/tags/VOX/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"VOX","slug":"2-软件使用/VOX","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/VOX/"}]},{"title":"利用本地缓存解决 pyenv 下载缓慢问题","date":"2020-04-13T00:00:00.000Z","path":"archives/22859f2b.html","text":"从 python ftp 网站 下载好需要目标版本的 Python 压缩包，然后将其放在 ~/.pyenv/cache 中。 再使用 pyenv intsall 指令，pyenv 就会判断下载已完成，自动开始进行安装。","tags":[{"name":"pyenv","slug":"pyenv","permalink":"https://wiki.blanc.site/tags/pyenv/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"pyenv","slug":"2-软件使用/命令行工具/pyenv","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/pyenv/"}]},{"title":"TypeScript 名词理解","date":"2020-04-01T00:00:00.000Z","path":"archives/e7cd2bef.html","text":"接口 | interfaces个人理解接口是一种描述，它不涉及任何代码实现，而是用来描述和规范某个在代码实现过程中需要用到的「概念」。 名词关系概念实现接口为某一概念创建接口 泛型 | Generics个人理解泛型是一种约束，它不涉及任何代码实现，并且能在各种概念之间传递 能够保持准确性","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://wiki.blanc.site/tags/TypeScript/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"TypeScript","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/TypeScript","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/TypeScript/"}]},{"title":"JetBrains 系列软件如何在 macOS 下快速创建文件","date":"2020-03-30T00:00:00.000Z","path":"archives/e82cc623.html","text":"操作系统：macOS使用软件：JetBrains 系列 IDE 软件操作流程： command + ↑ 使用 ← → 选择目标目录 command + n 创建文件或目录","tags":[{"name":"JetBrains","slug":"JetBrains","permalink":"https://wiki.blanc.site/tags/JetBrains/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"JetBrains","slug":"2-软件使用/JetBrains","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/JetBrains/"}]},{"title":"Vue Router 实现动态路由和常见问题解决方案","date":"2020-03-05T00:00:00.000Z","path":"archives/341c107a.html","text":"何为动态路由个人理解：动态路由不同于常见的静态路由，可以根据不同的「因素」而改变站点路由列表。常见的动态路由大都是用来实现：多用户权限系统不同用户展示不同导航菜单。 如何利用Vue Router 实现动态路由Vue 项目实现动态路由的方式大体可分为两种： 前端将全部路由规定好，登录时根据用户角色权限来动态展示路由； 路由存储在数据库中，前端通过接口获取当前用户对应路由列表并进行渲染； 第一种方式在很多 Vue UI Admin 上都实现了，可以去读一下他们的源码理解具体的实现思路，这里就不过多展开。第二种方式现在来说也比较常见了，因为近期项目正好用到所以单独讲一下，这里我使用的方案是利用 Vue Router 的一些特性实现后端主导的动态路由。 使用到的功能特性Vue Router 全局前置守卫官网解释 这里我们主要借助全局前置守卫的「前置」特性，在页面加载前将当前用户所用到的路由列表注入到 Router 实例中，注入使用到的方法则是下面的 router.addRoutes 方法。 Vue Router router.addRoutes 实例方法官网解释 router.addRoutes 方法可以为 Router 实例动态添加路由规则，刚好为我们实现动态路由提供了注入方法。 Vue Router 路由懒加载官网解释 懒加载这个功能不是动态路由的必要功能，但既然提供了这一特性，所以就直接在项目中使用了。 具体思路基础信息准备前端代码实现基本静态路由，例如：登录页路由，服务器错误页路由等（这里有一个坑，后面讲）。数据库存储全部动态路由信息。 数据库如何存储动态路由信息？我选择的方案是现将路由引用的对象字符串化，再将路由列表转化为 JSON 格式传输给后端，经后端处理后存储到数据库里。总之在前后端进行传递的是 JSON 格式的路由列表信息。 如何将路由中引用的对象字符串化？我遇到的实际问题是：使用的 UI 组件提供了布局方案，需要引用布局组件并在子路由处引用具体页面。我选择的解决方案是：区别对待需要引用布局组件的 component 属性，使用简短字符串代替布局组件，使用文件路径字符串代替页面引入。具体实现可以看后面的代码实例。 利用全局前置守卫对路由信息进行判断1-判断用户是否登录1.1-若未登录，跳转至登录页面1.2-若已经登录，判断是否已获取路由列表1.2.1-若未获取，从后端获取、解析并保存到 Vuex 中1.2.2-若已获取，跳转至目标页面 这里我没做太多考察，直接将取到数据存储到了 Vuex 中，在实际项目应用的过程中应考虑数据存储的安全性。 如何实现路由列表解析？ 将 JSON 格式的路由信息解析为 JavaScript 列表对象； 利用列表对象的 filter 方法实现解析函数，通过 component 判断是否为布局组件； 若为布局组件，使用布局组件代替 component 字符串； 若为具体页面，使用 loadView 函数加载对应的具体页面； 利用 router.addRoutes 方法动态添加路由这一步就很简单了，将解析好的路由列表通过 router.addRoutes 方法添加到 Router 实例中即可。 简单的实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// router/index.jsimport Vue from 'vue'import store from '@/store'import Router from 'vue-router'import &#123; getToken &#125; from '@/lib/util'Vue.use(Router)// 定义静态路由const staticRoutes = [ &#123; path: '/login', name: 'login', meta: &#123; title: '登录页面', hideInMenu: true &#125;, component: () =&gt; import('@/view/login/login.vue') &#125;, &#123; path: '/401', name: 'error_401', meta: &#123; hideInMenu: true &#125;, component: () =&gt; import('@/view/error-page/401.vue') &#125;, &#123; path: '/500', name: 'error_500', meta: &#123; hideInMenu: true &#125;, component: () =&gt; import('@/view/error-page/500.vue') &#125;]// 定义登录页面名称（为了方便理解才定义的）const LOGIN_PAGE_NAME = 'login'// 实例化 Router 对象const router = new Router(&#123; routes: staticRoutes, mode: 'history'&#125;)// 定义全局前置守卫（里面有两个坑要注意）router.beforeEach((to, from, next) =&gt; &#123; // 通过自定义方法获取用户 token 用来判断用户登录状态 const token = getToken() if (!token &amp;&amp; to.name !== LOGIN_PAGE_NAME) &#123; // 如果没有登录而且前往的页面不是登录页面，跳转到登录页 next(&#123; name: LOGIN_PAGE_NAME &#125;) &#125; else if (!token &amp;&amp; to.name === LOGIN_PAGE_NAME) &#123; // 如果没有登录而且前往的页面是登录页面，跳转到登录页面 // 这里有一个坑，一定要注意这一步和上一步得分开写 // 如果把前两步判断合并为 if (!token) next(&#123; name:login &#125;) // 则会形成登录页面无限刷新的错误，具体成因后面解释 next() &#125; else &#123; // 如果登录了 if (!store.state.app.hasGetRoute) &#123; // 如果没有获取路由信息，先获取路由信息而后跳转 store.dispatch('getRouteList').then(() =&gt; &#123; router.addRoutes(store.state.app.routeList) // 这里也是一个坑，不能使用简单的 next() // 如果直接使用 next() 刷新后会一直白屏 next(&#123; ...to, replace: true &#125;) &#125;) &#125; else &#123; // 如果已经获取路由信息，直接跳转 next() &#125; &#125;&#125;)export default router 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// store/index.jsimport router from '@/router'import Main from '@/components/main'import &#123; getToken &#125; from '@/lib/util'import &#123; getRoute &#125; from '@/api/app'const loadView = (viewPath) =&gt; &#123; // 用字符串模板实现动态 import 从而实现路由懒加载 return () =&gt; import(`@/view/$&#123;viewPath&#125;`)&#125;const filterAsyncRouter = (routeList) =&gt; &#123; return routeList.filter((route) =&gt; &#123; if (route.component) &#123; if (route.component === 'Main') &#123; // 如果 component = Main 说明是布局组件 // 将真正的布局组件赋值给它 route.component = Main &#125; else &#123; // 如果不是布局组件就只能是页面的引用了 // 利用懒加载函数将实际页面赋值给它 route.component = loadView(route.component) &#125; // 判断是否存在子路由，并递归调用自己 if (route.children &amp;&amp; route.children.length) &#123; route.children = filterAsyncRouter(route.children) &#125; return true &#125; &#125;)&#125;export default &#123; state: &#123; routeList: [], token: getToken(), hasGetRoute: false &#125;, mutations: &#123; setRouteList(state, data) &#123; // 先将 JSON 格式的路由列表解析为 JavaScript List // 再用路由解析函数解析 List 为真正的路由列表 state.routeList = filterAsyncRouter(JSON.parse(data)) // 修改路由获取状态 state.hasGetRoute = true &#125; &#125;, atcions: &#123; getRouteList(&#123; state, commit &#125;) &#123; return new Promise((resolve) =&gt; &#123; const token = state.token getRoute(&#123; token &#125;).then((res) =&gt; &#123; let data = res.data.data // 注意这里取出的是 JSON 格式的路由列表 commit('setRouteList', data) resolve() &#125;) &#125;) &#125; &#125;&#125; 常见问题页面卡在登录页面而且不断刷新这个问题的解决方案在「实现代码」中已经提到了，只需要在判断登录状态的时候注意不要将两种未登录状态混为一谈即可。但这样治标不治本，因为同样的问题可以由不同形式的代码导致，那导致问题的原因是什么那？让我们慢慢分析： 我们先假设不小心把两种未登录的状态混在一起判断： 123if (!token) &#123; next(&#123; name: LOGIN_PAGE_NAME &#125;)&#125; 这里的 next({ name: LOGIN_PAGE_NAME }) 方法会再一次激活全局前置守卫，从而导致再一次进入判断并触发 next({ name: LOGIN_PAGE_NAME })，如此递归调用下去，页面就会卡主并且不断刷新。 动态路由配合路由懒加载实现这一目的的方案也在代码示例中展示了： 123const loadView = (viewPath) =&gt; &#123; return () =&gt; import(`@/view/$&#123;viewPath&#125;`)&#125; 这里是运用了一个 JavaScript 不太常用的特性：字符串模板，使用此特性让不支持字符串拼接的 import 操作能够实现动态 import 不同的模块。 动态路由刷新后 404这应该是本方案中最常见的一个错误之一，其原意是很多人在创建「基本静态路由」的时候回把 404 页面的路由也加入在里面，从而导致页面加载初期动态路由还没有加入到路由实例中，匹配范围最广的 404 页面就会跳出来。解决方法就是将 404 页面的路由也加入到动态路由中。 动态路由刷新后变空白页造成这一问题的原因有很多，我这里遇到的问题是使用 参考文章3 解决的，但具体原理我还没弄清楚，等我做一下研究再来更新。 动态路由页面刷新时 Title 不稳定造成这一问题的原因很简单：因为页面刷新的时候路由信息还没加载进来，所以根本没有标题信息可供加载。但是我还没找到比较好的解决方案，同样等我研究一下再更新。 参考 大师兄：Vue 动态路由的实现…… Vue Router 文档页面 rambo：vue router 动态路由 刷新后变空白页","tags":[{"name":"Vue","slug":"Vue","permalink":"https://wiki.blanc.site/tags/Vue/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Vue","slug":"2-软件使用/Vue","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Vue/"}]},{"title":"写给小白的 ShadowSocks 全平台客户端使用说明","date":"2020-01-20T00:00:00.000Z","path":"archives/42f2446d.html","text":"前言自己搭了一个 SSR 服务器，平时周围的朋友想要翻墙的时候也都会来找我，他们和我一起承担服务器费用，我教他们学会翻墙，大家一起心系自由，本来是挺好的一个事情，但是每当有一个新朋友要加入的时候我就得手把手的教他一遍，还得尽可能的通俗的描述。 基于以上原因，我写下了本篇文章，本意是给我身边想要翻墙却比较电脑小白的朋友，如果也恰好帮助了你，便也是缘分吧。 Windows教程截图来自本人的 Win10 系统，其他 Windows 系统也是类似的 我本人常用的是来自 shadowsocks.org 的 shadowsocks-win 可以点击 此链接 到 Github 下载最新版本（下载速度会比较慢） 也可以点击 此链接，提取码: jaf7 到我的百度云盘分享下载（版本是我写这篇文章时的最新版本） 以上链接如果都无法下载请 Email 我：ryomahan1996@gmail.com 获取到软件压缩包后将里面的内容解压到一个文件夹中 我一般会使用压缩软件的解压此压缩包到 XX 文件夹中 打开解压好的文件夹就能看到我们翻墙所需要的客户端了（切记就算你的解压文件没有压缩到 xx 文件夹这个功能也要在解压后第一时间将此程序放置在一个空的文件夹中，因为程序在运行过程中会产生一些配置文件，如果直接裸露的放在桌面你的桌面会变得一团糟） 双击运行客户端，就能看到程序界面，并且在底部右侧状态栏中能看到灰色小飞机的图标（没有的话可能是被隐藏在不活跃程序里了） 将 SSR 服务提供方（也就是我）给出的配置内容填写在对应位置，点击确定按钮 然后右键底部状态栏里的灰色小飞机图标，将鼠标指向 系统代理 点击 PAC模式 也可以顺手勾选上 开机启动 到此就可以正常使用SSR 服务啦，快打开浏览器输入 google.com 看看吧 全局模式与PAC模式的区别简单地说，在全局模式下，所有网站默认走代理。而 PAC模式 是只有被墙的才会走代理，推荐 PAC模式，如果 PAC模式 无法访问一些网站，就换全局模式试试，一般是因为 PAC 更新不及时（也可能是 GFWList 更新不及时）导致的。 Mac教程截图来自本人的黑苹果，其他 macOS 系统也是类似的 我本人常用的是来自 shadowsocks.org 的 ShadowsocksX-NG 可以点击 此链接 到 Github 下载最新版本（下载速度会比较慢） 也可以点击 此链接，提取码: 8tgr 到我的百度云盘分享下载（版本是我写这篇文章时的最新版本） 以上链接如果都无法下载请 Email 我：ryomahan1996@gmail.com 获取到软件之后将其移动至应用程序文件夹 从启动台打开应用后软件会在后台运行并在菜单栏显示图标，左键小飞机图标就能看见菜单： 而后将鼠标移动至「服务器」栏目并选择「服务器设置」然后点击「+」按钮来添加你的 Shadowsocks 配置： 在几处必填选项填写上 SSR 服务提供方给出的配置内容，并在备注处填写一个自己喜欢的名称，然后点击确定按钮即可： 配置完成后再次左键小飞机图标打开菜单移动到「服务器」栏目并选择你刚刚添加上的服务器配置： 然后就可以选择打开 Shadowsocks 开始你的自由之旅啦~ 全局模式与 PAC模式 的区别参考 Windows 章节。 Android手里暂时没有机器，以后再说吧。 IOS教程截图来自本人的 iPhone X IOS13 ，其他机型也是类似的 如果想在 IOS 设备上使用 Shadowsocks 的话，首先你需要有一个非大陆的 apple ID 用来下载软件，至于如何获取非大陆的 apple ID 可以自己去百度，这里我也给出一个连接：点击这里查看 首先在 App Store 里登录你的非大陆账号（主需要在 App Store 里登录就行）： 选择一个免费的 Shadowsocks 客户端，这里我推荐使用 Potatso Lite，免费而且好用： 现在完成之后打开软件进行配置： 配置完成后进入软件主界面选择自己的配置然后点击小飞机图标就可以运行啦： 这里还有一个小技巧，Potatso Lite 软件自带了一个 IOS 小工具，可以在手机的负页（主界面再往左滑一下）进行添加： 这样我们只需要在使用的时候进入到负页开启就行了，不用再进入软件进行操作。 LinuxLinux 系统我就不多说了，你都能用 Linux 了还不会配置 SSR 客户端的话就说不过去了","tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://wiki.blanc.site/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"各个平台的包管理器","date":"2019-12-07T00:00:00.000Z","path":"archives/f2b92668.html","text":"前言作为一个程序员，在进行日常工作的时候经常要进行操作系统的切换，就我而言我个人的笔记本是 Windows 10 + macOS 双系统，公司电脑是 Windows 10 + VMware目前已经更换为台式机：Hackintosh + Windows 10，每当进行系统重装或者新环境部署的时候都需要面临各类（软件）包的安装。Windows 下还比较好说，基本上都是打包好的安装包，只需要找到下载方法，下载并安装即可。而处理剩下的这些 类 Unix 系统就比较头疼了，不同体系的系统（使用不同的软件包管理器）有不同的软件包安装方式。 本文主要介绍常用的几种包管理器： 包管理器 典型适用系统 Yum CentOS apt Ubuntu homebrew MacOS Windows为了方便理解我们先介绍一下最为普遍的 Windows 系统是如何进行包安装的： 确定需要安装的软件包 找到一个提供目标软件包下载服务的（url）地址 下载目标软件包 双击目标软件包根据提示安装目标软件 在后面的介绍过程中我会将不同包管理器的使用类比这里的四个步骤方便理解 2021.04.18 补充：Windows 也出现了很多包管理工具：Chocolatey、Scoop 以及微软自家推出的WinGet 类 UnixRPM Package Manager(RPM) RPM 包管理员（简称 RPM，全称为 The RPM Package Manager）是在 Linux 下广泛使用的软件包管理器。RPM 此名词可能是指 .rpm 的文件格式的软件包，也可能是指其本身的软件包管理器(RPM Package Manager)。最早由 Red Hat 研制，现在也由开源社区开发。RPM 通常随附于 Linux 发行版，但也有单独将 RPM 作为应用软件发行的发行版（例如Gentoo）。RPM 仅适用于安装用 RPM 来打包的软件，当前是 GNU/Linux 下软件包资源最丰富的软件包类型之一。 RPM软件包 分为二进制包（Binary）、源代码包（Source）和 Delta 包三种。二进制包可以直接安装在计算机中，而源代码包将会由 RPM 自动编译、安装。源代码包经常以 .rpm 作为后缀名。 —— RPM 维基百科 The RPM Package Manager(RPM) is a powerful package management system capable ofbuilding computer software from source into easily distributable packagesinstalling, updating and uninstalling packaged softwarequerying detailed information about the packaged software, whether installed or notverifying integrity of packaged software and resulting software installation —— rpm.org RPM 包管理器是一个强大的包管理系统，它能够做到： 将电脑软件从源码构建成可分发包 安装、更新和删除打包好的软件包 查询软件包的详细信息，无论是否安装 验证软件包的完整性和软件的安装情况 原理[RPM 打包原理][] 写完之后会更新链接 命令简介1234567891011121314# From man rpm# Querying and verifying packages | 查询和验证包rpm &#123;-q | --query&#125; [select-options] [query-options]rpm --querytagsrpm &#123;-V | --verify&#125; [select-options] [verify-options]# Installing, upgrading and removing packages | 安装、更新、删除rpm &#123;-i | --install&#125; [install-options] PACKAGE_FILE ...# 更新包，如果未安装则安装rpm &#123;-U | --upgrade&#125; [install-options] PACKAGE_FILE ...# 如果包已安装则更新rpm &#123;-F | --freshen&#125; [install-options] PACKAGE_FILE ...rpm &#123;--reinstall&#125; [install-options] PACKAGE_FILE ...rpm &#123;-e | --erase] [--allmatches] [--justdb] [--nodeps] [--noscripts] [--notriggers] [--test] PACKAGE_NAME ... Yum | DNF Yum（Yellow dog Updater, Modified） 是由 Duke University 团队修改 Yellow Dog Linux 的 Yellow Dog Updater 开发而成，是一个基于 RPM 包管理的字符前端软件包管理器。能够从指定的服务器自动下载 RPM 包并且安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。被 Yellow Dog Linux 本身，以及 Fedora, Red Hat Enterprise Linux 采用。 —— Yum 维基百科 运行原理Yum 可以简单的分为「服务器」和「客户端」两个部分 服务器 | 以下简称 YumS所有要发行的 RPM 包都放在 YumS 上以供别人下载，RPM 包根据 Kernel 和 CPU 的版本分别编译发布。YumS 使用 FTP 或 HTTP 等形式提供下载服务。YumS 还有一个重要的功能即整理出每个 RPM 包的基本信息，包括：版本号、conf 文件、binary 信息以及最关键的依赖信息等。 YumS 上提供了 createrepo 工具，来把 RPM 包的基本概要信息做成一张「清单」，这张「清单」就是描述每个 RPM 包的 spec 文件。 客户端 | 以下简称 YumC客户端每次调用 yum install 或者 yum search 命令时，都会去解析 /etc/yum.repos.d 下面所有以 .repo 结尾的配置文件，这些配置文件指定了 YumS 的地址。 YumC 会定期从 YumS 更新 RPM 包清单，然后把清单下载保存到 YumC 的缓存里，根据 /etc/yum.conf 的配置，每次调用 yum install 的时候都会去缓存目录下去找这个清单，根据清单来确定安装包的名字、版本号、所需要的依赖包等信息，再去 YumS 下载相应包进行安装（前提是该包的缓存不在本地缓存中）。 Yum 与 DNF由于 Yum 在更新迭代的过程中积累了很多问题没有解决，例如：性能差、内存占用多、依赖解析速度慢等等。 因此在 RedHat 系列 Linux 系统在进行大版本更新时使用 DNF 替代料 Yum，例如在 Centos7 升级到 Centos8 之后 yum 命令就是一个指向 dnf 命令的软连接。 DNF 使用 libsolv 进行依赖解析，由 SUSE 开发和维护，旨在提高性能。 DNF 代表 Dandified Yum 是 Yum 的下一代版本，最早出现在 Fedora18 中，并在 Fedora22、RHEL8 中替代了 yum。 dnf 的命令格式与 yum 基本一致。 图片来自：知乎：linux中国-DNF 和 Yum 的区别……内容是译自：2daygeek：Magesh Maruthamuthu-What is… 命令简介参考 维基百科：Yum firefoxbug-深入理解yum工作原理 知乎：linux中国-DNF 和 Yum 的区别……","tags":[{"name":"包管理器","slug":"包管理器","permalink":"https://wiki.blanc.site/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"格式化 curl 输出的 json 内容","date":"2019-11-21T00:00:00.000Z","path":"archives/41e09627.html","text":"在 API 调试过程中除了使用 GUI 工具（类似：Postman）我最常使用的就是 curl 命令了 ，简单快捷，但是 curl 的输出结果不是特别友好，特别是 json 格式，会在命令行里输出成一个长字符串，如何解决那？ 使用 Python 工具格式化1curl https:&#x2F;&#x2F;test.com&#x2F;api&#x2F;test | python -m json.tool 使用 npm json 包格式化12npm install -g jsoncurl https:&#x2F;&#x2F;test.com&#x2F;api&#x2F;test | json 隐藏 curl 统计信息在使用上面的格式化命令时，curl 会在输出结果前先输出一段统计信息类似： 123 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 427 100 427 0 0 17300 0 --:--:-- --:--:-- --:--:-- 17791 我们可以使用 curl 的 -s 参数来隐藏这段统计信息： 123curl -s https:&#x2F;&#x2F;test.com&#x2F;api&#x2F;test | python -m json.toolcurl -s https:&#x2F;&#x2F;test.com&#x2F;api&#x2F;test | json 参考 简书-流水不腐小夏-格式化Curl返回的Json字符","tags":[{"name":"命令行工具","slug":"命令行工具","permalink":"https://wiki.blanc.site/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"curl","slug":"curl","permalink":"https://wiki.blanc.site/tags/curl/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"curl","slug":"2-软件使用/命令行工具/curl","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/curl/"}]},{"title":"homebrew tap","date":"2019-11-20T00:00:00.000Z","path":"archives/819175d6.html","text":"homebrew 简介homebrew 是使用 ruby 开发的 macOS 软件包管理器 一般来说我们可以直接使用 brew install xx 命令安装我们需要的软件包，但也会有一些软件并没有包括在 homebrew 的核心库中，因此我们就需要一个命令来为 homebrew 添加第三方仓库源：brew tap 就是这个命令。 brew tap 可以将更多存储库添加到 brew 跟踪，更新和安装的列表中。 注：tap 是 third-party repositories 第三方库的简写 brew tap 使用方式12# 不带任何参数直接使用命令时会列出当前使用的存储库brew tap 1234# 默认情况下 brew 会对 https:&#x2F;&#x2F;github.com&#x2F;user&#x2F;repo 下的仓库进行浅拷贝# 使用此命令之后我们就可以随意的使用 brew [un]install repo 安装和卸载软件包# 也可以使用 brew update repo 进行软件包更新brew tap &lt;user&gt;&#x2F;&lt;repo&gt; 123# 在本地对 URL 的仓库进行浅拷贝# URL 可以是非 GitHub 的仓库也不需要必须是 HTTP 协议 只要是 Git 能够拉取的就行brew tap &lt;user&gt;&#x2F;&lt;repo&gt; URL 12# 取消 brew 对给出仓库的监听brew untap &lt;user&gt;&#x2F;&lt;repo&gt; [&lt;user&gt;&#x2F;&lt;repo&gt; &lt;user&gt;&#x2F;&lt;repo&gt; ...] 更多场景的操作详情可以参考 brew 文档 给出的介绍 参考 brew 文档 segmentfault-一步-homebrew的tap功能详解","tags":[{"name":"homebrew","slug":"homebrew","permalink":"https://wiki.blanc.site/tags/homebrew/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"homebrew","slug":"2-软件使用/命令行工具/homebrew","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/homebrew/"}]},{"title":"pip 自动生成或安装 requiremen 依赖","date":"2019-10-09T00:00:00.000Z","path":"archives/b47b33aa.html","text":"生成 requirements.txt 文件 1pip freeze &gt; requirements.txt 安装 requirements.txt 依赖 1pip install -r requirements.txt","tags":[{"name":"pip","slug":"pip","permalink":"https://wiki.blanc.site/tags/pip/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"pip","slug":"2-软件使用/命令行工具/pip","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/pip/"}]},{"title":"MySQL GRANT 授权语句","date":"2019-09-26T00:00:00.000Z","path":"archives/466aea21.html","text":"在服务器创建完 MySQL 数据库后经常需要给角色分配远程连接的权限，一般会在初始化的时候选择禁用远程连接，然后再通过 GRANT 给固定 IP 开启远程连接数据库的权限。 GRANT 语句基本语法123GRANT privilege[,privilege,...] ON database.table -&gt; TO username@user_ip [IDENTIFIED BY password_you_want]-&gt; [REQUIRE tsl_option] [WITH [GRANT_OPTION] resource_option]]; 上面为一整句 GRANT 语句，为了方便阅读我做了分行处理。 第一行为权限分配： GRANT 关键字后紧跟着需要分配的权限，其中 privilege 有很多可选项（后面会单独讲），也可以设置为 ALL 表示给予全部权限； ON 关键字后紧跟着针对哪个数据库和数据表，其中 database 可以为任意数据库名，也可以使用通配符 * 表示全选；table 可以为任意数据表名，同样可以使用通配符 * 表示全选，因此 *.* 则表示全部数据库的全部表； 第二行为用户指定： TO 关键字后指定权限分配指向的 MySQL 用户和 IP 地址，两者使用 @ 隔开，其中 username 可以已经是已经存在的用户也可以是还不存在的用户（该命令会自动创建所需用户），也可以使用通配符 % 表示全选；设置 IP 是可以在任意 IPV4 的 IP 段使用通配符 % 表示全选，例如 192.168.0.%，也可以直接设置为 % 表示全选； INDENTIFIED BY 为可选字段，后面跟随想要设置的用户登录密码 第三行为详细配置项： REQUIRE 为可选项，用来设置数据库安全连接； WITH GRANT OPTION 为可选项，用来做一些附加设置，这里就不详细展开了； MySQL GRANT 语句示例12345# 赋予通过 localhost 登录的 root 用户全部数据库和数据表的全部权限GRANT ALL ON *.* TO &#39;root&#39;@&#39;loaclhost&#39;;# 赋予通过任意 ip 登录的 test_user 用户查看 testdb 数据库下全部数据表的权限GRANT select ON testdb.* to &#39;test_user&#39;@&#39;%&#39;; GRANT 相关命令12345# 查看除了 ALL 以外其他可选择的 privilege 选项SHOW privileges;# 查看已经分配给某个特定用户的 GRANT 语句SHOW GRANTS FOR username@user_ip 参考易百教程-MySQL授予权限（Grant语句）简书-Rick_Ji-mysql的grant权限","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wiki.blanc.site/tags/MySQL/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"6-数据库","slug":"3-计算机科学/2-计算机系统/6-数据库","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"3-计算机科学/2-计算机系统/6-数据库/MySQL","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}]},{"title":"解决 Vue CSS 样式重复载入，为 Vue 添加全局 less 或 sass 基础样式库","date":"2019-08-27T00:00:00.000Z","path":"archives/793400e.html","text":"诉求项目开发使用了 iView 组件库，在开发过程中想自定义 iView 主题但是按照 iView 官方推荐「变量覆盖」方法配置完后会出现 CSS 样式重复载入的情况，如下图： 网上包括 Vue CLI 官方都是推荐使用 style-resources-loader 进行「开发环境」自动化导入，但是你会发现按照给出的方法配置完之后还是会出现 CSS 样式重复的情况，折腾了好久最终通过比较 iView 官方的「变量覆盖」教程和 Vue CLI 官方的自动导入教程发现了问题所在： 发现错误iView 推荐的「变量覆盖」方法是这样的： 实质上就是新建一个 less 文件，引入 iview 的 less 入口文件，覆盖官方提供的可覆盖变量，然后在 mian.js 中引用自定义的 less 文件代替引用 iview less 入口文件。 而 Vue CLI 提供的自动化导入教程是这样的： 实质上就是在每个文件（全局）导入我们提供的样式文件（示例中是 ./src/styles/imports.styl&#39; 文件） 正常来说按照 Vue CLI 官方给出的自动化导入教程配置就可以在开发环境下为全局导入「基础样式库」，但我因为先使用了 iView 官方提供的「变量覆盖」方法修改了基础样式，又把带有引入 iview less 入口文件命令的自定义 less 文件当成基础样式库导入到了全局，这就造成了全局每一个页面都导入了一次 iview 样式从而引发前面所说的 CSS 样式重复载入。 我当时的错误配置如下： 解决方案正确的配置方法是将原本糅杂的样式文件分离成「全局样式入口文件」和「基础样式库文件」两个文件： 「全局样式入口文件」用来引入需要的文件（在我的项目中是「iview less 入口文件」和「基础样式库文件」）;「基础样式库文件」用来存放项目的基础样式（一般为 less sass 变量和公用函数等等）; 修改后的配置如下： 注：我的「自动化导入」部分是参考 码路芽子-Vue Cli3.0 全局引入 less 变量 进行设置的。 效果如下： 参考 码路芽子-Vue Cli3.0 全局引入 less 变量 Vue CLI 官方文档-CSS 相关-自动化导入","tags":[{"name":"Vue","slug":"Vue","permalink":"https://wiki.blanc.site/tags/Vue/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Vue","slug":"2-软件使用/Vue","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Vue/"}]},{"title":"macOS 访达常用快捷键","date":"2019-08-26T00:00:00.000Z","path":"archives/26aeca3.html","text":"快捷键 描述 Shift-Command-点（.） 显示系统（隐藏）文件 Shift-Command-D 打开「桌面」文件夹 Shift-Command-G 打开「前往文件夹」窗口 Shift-Command-H 打开当前用户的「个人文件夹」 Shift-Command-I 打开「iCloud 云盘」 Shift-Command-O 打开「文稿」文件夹 Option-Command-L 打开「下载」文件夹 Option-Command-P 隐藏或显示「路径栏」 Option-Command-S 隐藏或显示「侧边栏」 Command–斜线 (/) 隐藏或显示「状态栏」 Command-I 显示所选文件的「显示简介」窗口 Command-N 打开一个新的窗口 Shift-Command-N 新建一个文件夹 Command-R 显示所选替身的原始文件 Command–左中括号 ([) 前往「上一文件夹」 Command–右中括号 (]) 前往「下一文件夹」 Command–上箭头 打开「前一级文件夹」 Command–下箭头 打开「下一级文件夹」 Command-Backspace 将所选项移动到废纸篓 Shift-Command-Backspace 清空废纸篓 Option-Shift-Command-Delete 清空废纸篓且不显示确认对话 Command-1到4 切换文件显示形式（图标、列表、分栏、封面） Command-Option-1 将文件以「名称」为标准排序 Command-Option-2 将文件以「种类」为标准排序 Command-Option-5 将文件以「修改日期」为标准排序 Command-Option-6 将文件以「大小」为标准排序 Command-Option-7 将文件以「标签」为标准排序 以上是我常用的访达快捷键，搭配「TotalFinder」能够显著提升文件操作效率 以下是我的访达配置： 参考Ihch102：Mac 键盘快捷键","tags":[{"name":"macOS","slug":"macOS","permalink":"https://wiki.blanc.site/tags/macOS/"},{"name":"效率","slug":"效率","permalink":"https://wiki.blanc.site/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"2-操作系统","slug":"3-计算机科学/2-计算机系统/2-操作系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"macOS","slug":"3-计算机科学/2-计算机系统/2-操作系统/macOS","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/macOS/"}]},{"title":"软件版本号命名规则","date":"2019-08-23T00:00:00.000Z","path":"archives/c7ab70f8.html","text":"命名格式：0.0.0 详细含义： 第一位：主版本号，主版本号为 0 一般表示还在开发阶段，主版本号大于 0 则表示软件能够基本稳定运行； 第二位：次版本号，一般在软件新增功能时增加； 第三位：修订号，只要对软件进行了更改（哪怕是不可见更改）就增加；","tags":[],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"鸭子类型","date":"2019-08-23T00:00:00.000Z","path":"archives/6f328d06.html","text":"正文学习 Python 的时候经常看到一个名词：鸭子类型，网上最常见的解释是：如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子（If it walks like a duck and quacks like a duck, it must be a duck）。但仅仅通过这一解释并没有办法让我很好的理解到底何为鸭子类型，于是我从网上找了一些案例来更好的理解： Python 中任何实现了 __iter__ 和 __next__ 方法的对象都可以成为迭代器。 123456789101112131415# python3# 例子来源：FOOFISH-PYTHON 之禅class Foo: def __iter__(self): pass def __next__（self): passfrom collections import Iterablefrom clooections import Iteratorprint(isinstance(Foo(), Iterable)) # Trueprint(isinstance(Foo(), Iterator)) # True 通过实例解释后我自己的理解是：所谓鸭子类型就是一种荣誉或者说称呼，被称为「鸭子」的对象本身是很么类型不重要，重要的是它完成了「鸭子」所能完成的一切，所以它就配得上「鸭子」这个称呼。举个现实的例子：某男子在路边捡到一个遗孤，细心照顾把遗孤养大，虽然男子没有在血缘和法律上继承「父亲」的名号，但是他尽到了「父亲」该尽的职责，因此我们就可以称这个男子是遗孤的「父亲」，而男子并没有继承「父亲」的称呼，但是男子尽到了我们认为「父亲」该尽的职责。同理到例子中，Foo 类是没有继承「迭代器」，但是它完成了我们认为「迭代器」该完成的功能。 所以我认为（不要你以为，我要我以为，哈哈）：在（任何语言的）编程中能够套用上面逻辑的对象都可以成为鸭子类型。 参考 FOOFISH-PYTHON之禅-Python：动态语言与鸭子类型","tags":[{"name":"鸭子类型","slug":"鸭子类型","permalink":"https://wiki.blanc.site/tags/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Excel 利用函数获取行号、列号、当前行的上一行","date":"2019-08-23T00:00:00.000Z","path":"archives/6cc2e3a0.html","text":"获取行号=ROW() 获取列号=COLUMN() 获取上一行的内容=INDIRECT(&quot;A&quot;&amp;ROW()-1)","tags":[{"name":"Excel","slug":"Excel","permalink":"https://wiki.blanc.site/tags/Excel/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Excel","slug":"2-软件使用/Excel","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Excel/"}]},{"title":"「转载」互联网产品研发流程概论","date":"2019-08-03T00:00:00.000Z","path":"archives/f15c2f60.html","text":"原文地址：人人都是产品经理：互联网产品研发流程概论转载过程中有所删减，本文不代表原文作者观点。 产品研发流程大体分为：立项阶段、设计阶段、开发阶段、测试阶段、上线阶段、磨合阶段、运营阶段、总结阶段。 立项阶段从分解公司战略开始，先通过市场调研获取客户需求，然后梳理产品方向形成产品提案给项目负责人审批，审批通过后正式进入产品研发阶段。 市场调研市场调研就是通过调研筛选典型客户，并对这些客户的需求细节进行汇总和梳理。 典型用户一般都是通过用户画像的形式进行描述。对已有产品可以直接通过数据统计部门拿到用户画像数据。用户画像一般都是通过抽样方法，随机抽取一批客户进行问卷调查。 新产品则需要先约定大致客户群特征，然后针对这个群体做抽样问卷调查。问卷设计一般由产品经理完成，然后可以找专业调研公司实施。 客户需求调研客户需求分析就是将调研过程中涉及的需求信息，根据需求重要程度分级，优先满足客户基础需求，即用户痛点。 在拿到一个新的产品以前，产品经理应该把需求进行一次整理，看哪些是真需求？哪些是边缘需求？哪些是伪需求？进而把功能点、产品卖点思路整理清晰。 一定要注重需求层次，并不是所有的需求都要满足，重点是：解决用户痛点行程产品卖点。 编写产品提案（BRD）立项阶段主要是输出产品提案，提交给公司项目负责人决策。产品提案也就是「商业需求文档」简称 BRD(Business Requirement Document)，是基于商业目的或价值所描述的商业需求。其核心用途在于能够在产品投入研发之前为企业高层提供决策评估依据。其内容涉及：产品概述、市场需求、竞争环境、重要性、成功要素、营销策略、盈利预测等内容，一般比较短小精炼，不包含产品细节，PPT 形式居多。 产品设计（设计阶段）产品设计分为输出概念设计、输出功能清单、输出需求概要文档、输出需求详情文档等步骤。 产品概念设计概念设计是非常关键的产品环节，简单明确的概念不仅让客户更容易理解，也让产品研发过程思路清晰、少走弯路。而且，概念设计也是软件架构师将产品概念转化为技术对象化模型的关键环节。 以支付宝产品为例，就是采用了「钱包」概念模型。钱包里有现金、银行卡，也可以放身份证、名片、照片、小票、发票等。区分好需求层级，产品交互体验的层次和用力程度自然就出来了。 确定产品功能组合根据产品概念模型和需求优先级，确认关键性的功能要点。 确定功能清单对功能进行树状化梳理，把所有功能点都整理到一个列表里。 这些功能点后续都作为需求点加入项目管理系统中，方便团队所有成员沟通和完善这个功能清单。形成功能清单初稿后，产品经理需要先在产品团队中组织讨论完善，然后再找运营团队沟通完善，然后是找交互视觉团队补充完善，最后再找研发项目经理、研发、测试、运维等角色沟通完善。 这个过程既是帮产品经理完善的过程，也是形成团队共识、激发团队热情的过程。 输出需求概要文档概要文档明确某个功能模块下的功能介绍，一般是多个功能点的描述。需求概要一般由产品经理负责撰写，不包含功能细节描述。为了方便与产品设计师们沟通需求，可以将主要功能界面草稿加入该文档中，用原型草图能更好地描述主要功能。 有了某个模块的需求概要文档后，研发项目经理组织团队沟通需求概要。产品经理首先介绍需求概要然后由其他团队成员提出自己关心的专业问题。会前产品经理提前分享文档，并收集准备大家的问题点。 会后主架构师根据需求概要做架构设计框架，研发工程师也可以针对自己负责的模块做技术预研。有经验的工程师，往往在这个阶段就开始试着做个Demo，把主体功能流程跑通，这样在正式进入研发时就会比较轻松，专注于细节完善和产品质量。 输出需求详情文档需求详情文档由产品设计师负责编写。需求概要中的需求点，每个都需要单独编写需求详情文档，而不是把所有的需求详情都写在一个文档里。这样会导致需求详情文档非常长，内容庞杂，这个会导致后续很多问题。需求点最好都能拆分到1周内能完成研发测试比较好，这样才能有效实现敏捷开发。 需求文档并不是产品设计师一个人闭门造车就能写出来的。产品设计师需要频繁与交互、运营、视觉、用户研究（UER）、架构师、测试经理、开发、运维等人员沟通。沟通的过程更多是产品设计师学习和融合各个角色思考的过程，同时也让各个角色的工作更加明确。 一般需求文档的编写分成以下步骤： 第一步：根据需求概要设计用户操作流程图。 第二步：根据用户操作流程拆分各个界面，绘制主界面草图加入文档，再分别描述每个界面的主要元素和功能点，再描述界面之间交互的逻辑，最后加上交互背后涉及的业务逻辑。 第三步：找运营沟通需求，根据运营人员的建议补充营销位、运营后台工具等内容。 第四步：找交互设计师沟通交互细节，根据交互设计师的疑问补充界面中的交互逻辑。交互设计师完成交互设计稿后，将交互稿截图并加入文档，并完善交互逻辑说明。 第五步：找视觉设计师沟通视觉细节，提醒视觉设计师突出重点。视觉设计师完成设计稿后，将设计稿截图并加入文档，并完善视觉界面说明。 第六步：找架构师沟通算法和技术逻辑，根据架构师提出的疑问完善业务逻辑。 第七步：找测试经理沟通测试用例，根据测试经理提出的疑问完善功能细节。因为测试经理需要写测试用例，测试用例是以需求文档为蓝本，如果需求文档不清楚必然会导致测试用例不完善，因此测试经理往往对产品设计师的帮助很大，甚至会比产品设计师更了解产品细节。 第八步：找 UER 做功能调研。UER 将需求文档转化为调研文档，然后通过产品体验群、邀请客户当面体验等方式找出产品设计中的问题。然后 UER 反馈给产品经理，产品设计师合并优化成产品需求详情文档。有的公司 UER 调研也是由产品设计师承担，但是专业性上有可能难以保障。 第九步：找产品经理、研发项目经理、运维确认需求文档，并初步确定排期。 需求评审如果之前编写过程与每个角色都有了充分的沟通，需求评审就会变得很轻松愉快。否则，产品经理和产品设计师将会陷入无止境的辩论中，往往动辄就让整个团队消耗了几个小时还无法形成结论。 因此，需求评审的关键就是产品设计师事先做好评审会的一切准备。提前准备好所有资料并提前发给团队所有成员，并事先与所有角色都逐一确认过关键问题，而且得到了产品经理和研发项目经理的确认。在评审会上，先讲总体，再讲重要细节，再讲次重要细节，并层层确认。 对于会议上争议较大的问题点，5分钟 后还没结论的马上记录下来，会后再单独讨论。如果问题点太多，就说明产品设计师还没考虑清楚，那就尽早结束会议，重新修改后再召开评审。这种情况会严重影响产品团队的声誉，因为耽误的是所有人的时间。为了减少这种风险，需求评审一定要提前 1-2周 召开，而不要等到开发前夕才进行评审。 交互设计交互设计主要是将产品经理的功能设计，用原型图和交互流程的形式展现出来，方便与用户及团队进行沟通。交互设计原型将产品经理提供的产品原型草图具象化，减少了需求不确定性，保证产品功能可用性。 交互设计需求分析交互设计需求分析主要是要回答以下问题： 重点是给哪些角色看？ 涉及交互稿的角色很多，几乎每个角色都需要，但是只要有专业细致的交互稿，也就能满足所有角色的需求了，无需针对每个人提供不同的交互稿版本。 产品经理：产品经理需要将交互稿截图合并到需求文档，提供给各个角色作为需求源。 视觉设计师：需要以交互设计稿为基础，设计出每个界面的 PSD 文档。 研发经理：需要通过交互设计稿，判断需要调配哪些角色参与，大概需要多少时间。 架构师：需要通过交互设计稿，梳理出软件架构设计，特别是功能流程设计与软件架构和网络架构设计紧密相关。 Web 前端开发：需要通过交互设计稿，确认网页界面是如何串联起来的。这里不仅涉及功能流程设计，也包括交互细节。 APP 客户端开发：需要通过交互设计稿，确认 APP 软件界面是如何串联起来的。这里不仅涉及功能流程设计，也包括交互细节。 后台开发：需要通过交互设计稿，确认采用哪种后台调用方式，以及如何通过交互设计让用户在面对网络延迟等情况时体验更佳。 测试：需要通过交互设计稿，编写功能测试用例，以及每个交互体验细节的测试用例。 用户研究：需要通过交互设计稿，访谈客户，让客户更容易理解产品功能，从而获得更有效的反馈。 用户场景是什么？ 确定是要做什么场景下的交互设计。具体包括用户画像、主要功能流程等。 采用什么样的形式？ 交互文档大多都采用 Axure 进行设计，一般都采用线框稿的形式。 要达到什么标准？ 一般衡量交互水平的指标，是整个功能操作流程的流量转化率。 以注册登录为例，可以通过抽样监测从进入注册到登录完成每个步骤进行数据跟踪，然后得出转化率数据值，然后再跟竞品或类似产品进行对比，不断提升这个转化率。 功能交互设计功能交互设计主要是将软件界面之间的跳转关联关系表达清楚。 交互细节设计交互细节涉及点非常多，不同公司、不同类型的产品都会有自己不同的交互设计风格和细节处理方式。为了保证产品交互细节上的统一和规范，互联网公司一般都会制定自己的交互设计规范，以便指导设计师完成交互设计。 交互细节设计，一般涉及交互控件元素、交互文案、装饰图形等内容。 每个看似很小的功能细节，都往往需要花费大量精力去做细。为了节省成本，在这样的功能开发出来后，都最好对象化模块化，其他场景只需调用这个模块即可快速创建类似的功能。 视觉设计视觉设计需求分析视觉设计需求分析主要是明确视觉设计需要达到的目的。 以 Logo 设计为例，最常见的需求要点是两个：明确表义、吸引视线。因此在设计过程中，通过把竞品和不同设计方案可以放到一起，从而找到最优的设计方案。 视觉概念设计视觉概念设计建立在视觉风格推导基础上，用以描绘出产品视觉风格的基本方向。 该步骤需要确定产品风格，为后续确 定设计元素、明度、色调、质感等设计细节奠定基础。 主界面设计主视觉设计师拿到交互稿后，针对主要功能界面设计风格定位稿。 视觉细节设计针对界面中的每个控件，都按照像素级标准进行绘制。 每个空间的分层素材都需要通过 PSD 文档进行保留，色块区域的颜色值需要标注，按钮的每个状态都需要单独设计，每个控件的尺寸也需要明确标注。交互设计中的每个细节设计状态，也都应该有对应的设计稿。 视觉设计规范与交互设计类似，视觉设计涉及点也非常多。为了保证产品视觉细节上的统一和规范，互联网公司一般都会制定自己的产品视觉设计规范，以便指导设计师完成视觉设计。 架构设计架构设计是架构师对各个子系统关系的抽象模型，用于指导大型系统的开发和运维。 架构设计主要包括三项工作：系统架构设计、软件架构设计、网络架构设计三个部分。 系统架构设计一般都会采用 MVC(Model-View-Controller) 模型，将业务逻辑模型、软件界面、控制器逻辑层进行分层处理，然后通过控制器逻辑层确保业务逻辑层和软件界面层的同步。MVC 模型的好处是在优化界面及用户交互的同时，无需重新编写业务逻辑。同时也有助于管理复杂的应用程序，可以在不依赖业务逻辑的情况下专注于视图设计，不同开发人员可以同时开发界面、控制器逻辑和业务逻辑，同时也让测试变得更加容易。 系统架构设计如果整个系统研发是从零开始的，架构设计则需要从概况图开始梳理，然后再补充各个模块的架构图。这部分一般由首席架构师牵头，属于整个产品技术架构的总纲。 一般而言，子系统名称都会与产品概念保持一致。子系统不论是应用前台还是后台，通过公共服务层、业务逻辑层、基础业务逻辑层关联到一起。这种对象化的架构设计方法，会让整个团队使用同一种语言在沟通， 相互理解起来更容易，有利于提高协作效率 。 软件架构设计软件架构设计一般采用分层架构设计模型。 软件首先分为两个大层次：前端和后台。前端应用负责提供与用户交互的软件，分成 Web 应用，PC 客户端应用、移动 APP 应用等场景；后台负责实现所有业务相关的操作和服务，分成接口层、业务逻辑层、基础逻辑层。 软件架构设计时，需要主要做到以下几点：支持模块化、高内聚、低耦合、可伸缩性，同时也要防止过度设计。已上线软件如果要新增某个功能，则需要针对该功能进行软件架构设计，并最终形成软件架构设计图。 然后针对这个软件架构图进行细化，先明确系统涉及的所有基础逻辑层模块（对象），以及该模块的输入和输出项，并明确模块内部的基本处理逻辑。这些模块有的有可能已经存在，则无需再开发，单独标注出来即可；还没有开发的模块，则可以交给软件项目经理指派给工程师开发。 然后明确界面上可以直接调用的各个业务逻辑层模块（对象）名称，以及对应接口、属性、方法。 对于还未开发的接口，如果涉及到数据调用，则需要梳理相关的数据结构，并确定算法。 上面介绍的只是最基础的软件架构设计流程，为了保证软件的柔性可用，经常还会加入 RPC 服务组件（让网络分布式应用开发变得更容易）、消息中间件（将模块之间的交互异步化）等方案。 网络架构设计 运维架构 架构设计需要保证每个环节都能快速迭代配置，尤其是在服务器CPU、内存、存储、带宽几个方面需要做到高可用性。 以新零售个性化推荐动态 Feed 为例，我们梳理了整个网络结构设计的流程。首先需要根据业务数据分析网络系统需求。一般 Feed 信息流前 3页 访问量往往占了 90% 以上，因此在做缓存设计的时候，我们完全可以在缓存数据中只保存每个用户最近的 100条 数据，其他的需要用户下拉再从数据库中实时生成。 然后需要从技术上解决高并发和高性能的问题。因为 Feed 性能压力主要集中在查询请求量上，而且一条 Feed 数据经常是数百甚至上百万人访问，因此 Feed 很适合采用缓存系统。当访问压力不大时，采用单层缓存数据就可以了。如果日均访问量达到了百万人次而且峰值非常明显，则最好采用双层缓存机制以增加系统扩容的灵活性。当写入 Feed 量很小但是访问量暴增时，只需扩容 L1 层服务即可；写入量暴增，则对 L2 层服务快速扩容。缓存扩容主要是提升 QPS、带宽瓶颈以及缓存数据库性能。 如果希望降低研发成本，也可以考虑购买云个性化推荐服务，这些中间处理过程就全部交给云服务去处理，这样可以集中力量解决业务层问题。 Feed 中除了文本数据外，还会有大量图片甚至视频数据，此时可以采用该 CDN 做文件缓存。Local Cache + 分布式缓存，这是常见 CDN 缓存策略。此时比较经济的选择，是购买 CDN 云服务，发布 Feed 时，把这些图片和视频数据先 Post 到服务器，然后再同步到 CDN 云服务中去。 然后是数据库的分布式架构。网络架构师拿到软件架构师的数据结构后，首先对 Feed 数据区分冷热数据。Feed 数据冷热一般都非常明显，可以按时间维度拆分做分表（例如每天 Feed 数据是独立一张分表）进行冷热数据分离，并对冷热数据采用不同的存储方案降低成本。Feed 数据还有快速检索的需求，因此需要通过建立索引提高检索速度。 服务拨测系统（服务器监控） 运维发布系统后，运维团队的压力才真正开始。随着用户量的不断增加，稳定性、性能和监控成了刚需。每个客户请求过来，都需要在后台不同机器之间不停地调用并返回。只要有 1个 接口出现问题，就会导致整个系统出现性能下降、服务延时甚至崩溃。 此时，就需要有效的服务追踪系统。对新零售企业而言，最经济有效的办法是采用云拨测系统。通过部署抽样接口到云拨测系统，特别是在高峰时段进行监测，即可通过手机短信或邮件监控服务异常。 日志统计系统 要考虑全链路压测、服务器登录安全性、运维权限分配、流量峰后降级预案、共享 Docker 集群资源等问题，确保系统可用性、安全性、单位成本。 创建版本计划当架构设计完成并评审后，研发项目经理开始对需求和架构进行切分，形成版本计划。 版本主要作用是用来明确研发节奏，方便团队协作，特别是方便测试和产品发布。 一般产品研发节奏都是按每周 1个 小版本，以便安排和协作。但是因为 APP 有发布周期和推广成本的考虑，因此会每隔几周发布一个大版本。 每个版本都包括若干需求点，因此自然就明确了测试范畴，这样测试范围就不会无限制蔓延，可以让产品节奏非常明确，形成快速迭代和敏捷开发的研发风格。 版本落地到代码管理层面上，关键就是代码管理系统（一般都选用 Git）中的 Trunk 版本。首先项目经理需要在 Git 中创建 Trunk 版本，并为每个研发人员创建分支版本。研发人员在分支版本中测试没有问题的版本代码，将由架构师或项目经理合并到 Trunk 版本中，这个版本经过编译后进行功能和系统测试，没问题后再同步到运维发布系统中发布。 开发阶段开发测试环境准备主要是部署 Web, APP 开发测试环境，以及部署需求管理系统、代码管理系统 Git 等。 开发设计文档开发工程师拿到架构师设计文档后，就可以将自己负责的部分拆分出来，然后提前对这部分的开发细节进行补充和完善，形成开发设计文档。开发设计文档主要用来提高软件开发效率，保证软件质量，并有利于后续产品客服文档的编写，也非常有利于后续的研发迭代和代码维护工作。 前端开发、APP 客户端开发、后台开发完善的内容和细节各不相同，但是内容主要集中在开发环境、开发语言、使用框架、对象属性方法、接口封装、数据结构设计、界面开发、编译发布等方面。 前端开发前端开发工程师通过使用 JavaScript 来编写和封装具有良好性能的前端交互组件，并通过 CSS + HTML 输出 Web 操作界面。前端工程师经常不仅要考虑前端实现，很多时候也需要了解后台研发，从而能不断优化前端代码分层架构，让 Web 产品的稳定性和可用性不断提升。 APP客户端开发App 客户端开发主要是指 IOS, Android、微信小程序的开发。 IOS 开发推荐使用 Xcode，需要运行在 Mac OS 上；Android 开发推荐使用 Eclipse；微信小程序开发需要使用微信开发者工具。 后台开发后台开发主要是指的服务器端的程序开发，包括 Web 后台开发、组件开发两类。两者之间其实本质上一体的，Web 后台可以看作是组件的前端。Web 后台解析了 HTTP 请求，然后通过层层转发给了后面分布式系统的多个组件并调用服务。 因为互联网公司的 Server 一般都是 Linux，因此还会涉及到 Shell 脚本 编写、Linux 环境编程等内容，需要熟悉 Linux/Unix 下各种环境编程的 API。 开发工程师自测开发工程师可以一边研发一边自测，完成所负责功能模块的开发后再进行完整功能模块的自测。 开发自测和测试的重点不一样，是为了减少不必要成本，而不是要替代测试工程师的工作。因为代码是开发自己写的，自测可以发现的问题，就完全没必要让测试工程师去发现。而且发现问题马上就可以自己修改自己验证，减少了沟通和返工成本。 测试阶段从需求详情文档经过评审，测试工作就开始了。 测试用例测试经理组织测试工程师，根据需求详情文档撰写测试用例。 测试用例是软件测试质量稳定的保障，用于指导测试的实施、规划测试数据、设计测试脚本、评估测试结果、分析缺陷标准等。测试用例一般都详细记录测试工程师应该有的操作信息，这样可以帮助测试工程师参与测试。 测试用例文档一般包括修订记录、测试用例、测试数据等内容。测试用例可以直接在项目管理系统中批量创建。 有很多常见模块可以归纳成测试用例库，然后不断优化完善，这样可以减少重复设计测试用例。相当于把测试工作也组件化，减少低效沟通提高效率。例如注册功能测试用例，每隔一段时间就更新一次，以后出现需要测试注册功能的时候测试工程师即可按照此规范进行测试，而无需针对这个功能重复编写测试用例。 功能体验测试功能测试就是对产品功能进行验证，根据功能测试用例逐项测试，检查产品功能是否达到用户要求。功能测试主要采用黑盒测试方法，把测试对象看作黑盒子，主要测试功能而不考虑软件内部结构及代码。一般从软件产品的界面、架构出发，按照需求编写出来的测试用例，输入数据在预期结果和实际结果之间进行评测，进而提出更加使产品达到用户使用的要求。 黑盒测试试图发现以下类型的错误：功能错误或遗漏、界面错误、数据结构或外部数据库访问错误、性能错误、初始化和终止错误等。 这部分测试除了测试工程师需要参与外，产品、交互、视觉设计师也需要深度参与，因为很多隐性信息都很难在需求文档中写得无一遗漏，但是产品设计师一看就能看出很多的问题，而这些问题测试工程师却难以判断，因为他们经常不知道产品设计师怎么想的。 功能体验测试最好是与研发同步。Web 测试提供测试环境，产品设计团队通过配置 host 即可访问测试环境，随时能看到开发进展情况。对客户端的开发，则每天定时合并代码到 Trunk 并提供 daily build 版本，产品设计团队及时下载体验，并在下班前将体验问题通过工作群告知研发人员，以便研发人员第二天及时改进。这样可以及时纠偏，减少研发憋大招。这个地方看似很小的工作习惯改变，但是会产生天壤之别的结果。所谓敏捷开发，也体现在这些协作细节里。 性能测试性能测试关注软件完成特定功能的响应速度、稳定性和运维成本消耗。主要是为了优化系统容量、可扩展性、系统稳定性、资源利用率等指标。 性能测试一般采用压力测试的方法，通过给系统加载一定负荷的业务压力，让系统持续运行一段时间（一般为 7×24小时），检测系统是否能稳定运行。 性能测试主要步骤如下： 罗列主要用户场景及相应负载量 重点针对可能出现性能瓶颈的场景，逐项分解和预估负载量。 为了让系统抗压能力更大一些，一般都会多预估一定比例的负载量，以防出现意外情况。 识别稳定性的主要性能指标 然后根据每个场景的负载量，分解每个后台服务、APP、Web 端所需关注的系统指标，比如响应时间、CPU、内存使用率等。 单元性能测试与改进 在准备好测试环境后，使用测试工具对每个接口按照合法输入格式进行压力测试，确保在目标负载量都不会导致出现问题。比较常用的压力测试工具是 Loadrunner。 如果系统出现响应延迟或崩溃的情况，则需要运维和研发快速迭代。然后再次测试，直到系统性能指标达标为止。 客户端兼容性测试 Web 界面的兼容性测试，可以直接用 Chrome 内置开发工具即可完成。 APP 兼容性测试，最好借用第三方工具（例如 Testin云测），提交 APP 后，Testin 云测将会部署 APP 到数百款手机，然后自动输出兼容性稳定性报告。也可以根据测试工程师提供的测试用例，针对每款手机批量进行功能和体验测试。 整体系统测试与改进 当每个场景下的单元测试完成后，再针对整个系统进行完整的压力测试。 同样，如果出现响应延迟或崩溃的情况，则需要运维和研发快速迭代，找到出问题的后台接口或前台模块进行优化，直到系统性能指标达标为止。 数据初始化运营数据初始化首先是数据库工程师根据产品和运营人员的需求，对基础数据进行完善和补充，以达到能用户能正常使用的状态。 比较麻烦的是以往旧系统的数据迁移，由于旧系统和现有系统的字段，类型，日期格式，数字格式等差异，需要抽丝剥茧一层层把数据注入到对应的数据表里，特别是表间关系需要继续保留下来。 然后是运营人员通过运营后台，手动修改部分有问题的数据。 产品内部测试测试工程师完成所有测试用例的测试工作，研发人员将所有必须完成的 BUG 修正修正完成，其他待修正 BUG 完成转需求后，就可以启动产品内部测试了。 内部测试首先可以针对产品相关的所有员工，包括产品、研发、运营、市场、运维等各个角色。这个过程一方面是为了收集产品缺陷反馈，同时也是让相关人员有参与产品改进的机会，让大家能荣辱与共。同事对于产品的容忍度比用户要高得多，就算产品做得很烂，他们都会坚持着把产品所有功能都用一遍，而真实用户很可能看到一个不好的体验点转身就走。因此产品经理一定要高度重视同事反馈，同事发现每个的缺陷，都一定会导致大量用户流失。 员工反馈的问题如果是之前没有发现的缺陷，就需要尽快改进修正。如果对当前版本影响不大，就可以放到以后版本 BUG 转需求，并记录下反馈人信息和详细沟通结论。 等员工完成内测后，产品经理可以将产品内部测试版发到核心用户群里，以有奖测试的形式刺激大家提交缺陷。如果线上反馈不够深入，可以由 UER 调研小组邀请用户当面沟通交流，找到更深入的缺陷。这些问题汇总提交到 BUG 列表中，可以马上修正的尽快修正，可以放下个版本的 BUG 转需求。 发布上线阶段发布环境的搭建，包括预发布环境、生产环境、灰度发布环境的准备等工作。 而正式上线的工作，则包括数据库上线、程序文件上线等工作。 发布环境准备预发布环境准备：预发布环境是跟生产环境配置一模一样的系统，只是往往只有一个测试节点，但是它后面调用的是正式生产环境的资源（例如 DB, Cache、队列等）。 预发布环境主要是要在正式发布前，做一次完整回归测试。测试人员可以通过地址参数、Cookie、请求头参数、VPN 等工具，接入预发布环境进行系统整体回归测试。预发布环境下，最常见的 BUG 如下：生产环境代码已更新到最新版本了，但是数据库变更却忘了操作生产数据库。这个情况下，测试环境很可能都是正常的，但是预发布环境就可以很好的发现 BUG。 跟开发环境不同，预发布环境不允许开发人员直接接触，以防因为开发人员提交代码的瑕疵影响预发布环境里的系统。因为这是运维人员保障上线质量的最后一道屏障，运维标准也基本等同于生产环境。 正式生产环境准备：生产环境包括发布产品所需要的所有服务器资源，包括 Web 服务器、数据服务器、CDN 服务等。 灰度发布环境准备：每个项目一般都会部署到多台机器，所以一般会拿 1-3台 服务器看看是否可用，如果失败则只需要回滚这几台服务器，比较方便。灰度发布需要使用跳板机并进行域名绑定，这样才能保证用户访问到的只有最新代码的服务器。 数据库上线生成数据库项目时，可以先从测试环境导出数据库对象定义脚本，然后再将预先部署脚本、数据库对象定义和后期部署脚本合并为一个生成脚本，再将该脚本拿到主数据库服务器上生成数据库。然后通过主数据库备份到各台从属数据库。 如果系统对读取及时性要求非常高，则可在数据库层之上架构 Redis 这样的分布式缓存，其性能肯定远高于从数据库读取数据。 程序文件编译上线组件部署：将 C/C++ 或 Java 编写的组件编译，然后通过自动部署工具发布到所有 Web 服务器。 Web 前端部署：一般先将静态资源（例如图片、JavaScript 代码等）拆分出来，发布到 CDN 云服务。然后再通过 Git 将合并测试通过的 Trunk 版本发布到正式生产环境，再通过灰度发布工具同步到所有 Web 服务器。 IOS APP 发布：App Stores 是 iTunes Store 的一部分，是 iPhone, iPod Touch, iPad, Mac 唯一的正规下载渠道。企业用户申请证书后，即可上传并发布 IOS 应用。 Android APP 发布：推荐腾讯应用宝发布安卓版本的手机应用。应用宝提供防盗版功能，可有效帮助用户解决误下载山寨应用的问题。支持点击微信、QQ 分享链接，即可打开下载界面。因为没有唯一的安卓发布市场，因此建议主流安卓市场都能上线安卓的版本。 上线版本整体评估上线评估阶段需经过市场、产品、运营、开发、测试等对于上线做出整体评估后才能正式上线运营。这个过程一般是由产品经理先在全员群里提醒大家最后一次确认还有什么问题。 如果有任何问题，则需要在群里和相关人员评估是否要在当前版本解决，如果是则尽快解决以免影响版本发布计划，如果不是则转需求到后续版本。 如果每个人都没有提出异议则发出上线版本发布告知邮件，进入正式发布流程。 灰度发布Web 前端灰度发布：对比较小的 Web 应用，在页面 JavaScript 或服务器端实现分流即可。但对于大规模用户的 Web 应用，采用分流发布引擎很有必要。 组件灰度发布： IOS APP 灰度发布：常见做法是制作一个带数字签名的测试版，然后提供给测试用户使用。 Android APP 灰度发布：由于 Android 没有统一的发布渠道，因此只需逐个替换发布渠道的安装包即可。 优化阶段研发工作总结产品上线后需要对产品研发过程做总结，不论是产品上的还是流程配合上的，为后续加强沟通协作、产品运营打好基础。 产品流程也并不是一成不变的，不同的产品有不同的要求。对一些中小互联网公司而言，采用完整研发流程必然成本高昂，因此如何裁剪成自己需要的研发流程，是这类公司面临的关键问题。 上线后收集用户反馈对于产品做出优化，对于用户常见的问题及反馈做出调整，这阶段更多是产品与用户的磨合，做到更好的用户体验。 为了更好的收集用户反馈，需要在所有产品上都增加反馈入口，以便用户提交反馈内容。用户反馈的所有问题将出现在用户反馈平台中，以便产品和运营团队跟进。 一般每天的反馈量都数以万计，因此产品设计师每天都需要花费相当比例的时间去浏览，并将反馈建议转化产品需求点加入需求池。 产品体验可用性测试可用性测试常见方法是邀请一批真实的典型客户，针对典型场景使用产品，用户研究员在一旁观察、聆听、记录，从而发现产品中存在的可用性缺陷。 为什么需要可用性测试呢？这是因为产品运营团队的员工往往潜意识里会认为用户一定会怎样操作，但是事实上用户很大概率上都不会按照他们希望的进行操作，甚至会陷入茫然根本用不下去。而通过可用性测试，就可以找到问题点，通过优化体验设计降低用户使用门槛。 运维系统优化产品上线后运维工作才刚开始，具体包括升级版本上线工作、服务监控、应用状态统计、日常服务状态巡检、突发故障处理、服务日常变更调整、集群管理、服务性能评估优化、数据库管理优化、随着应用 PV 增减进行应用架构的伸缩、安全、运维开发等工作。","tags":[{"name":"转载","slug":"转载","permalink":"https://wiki.blanc.site/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"软件工程","slug":"软件工程","permalink":"https://wiki.blanc.site/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-软件工程","slug":"3-计算机科学/4-软件工程","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"macOS 如何删除自带 ABC 输入法","date":"2019-08-03T00:00:00.000Z","path":"archives/607dec48.html","text":"环境本人操作环境：电脑型号：联想 G50-80电脑系统：macOS Mojave 全驱动黑苹果 起因 macOS 自带的 ABC 输入法默认是不可删除的； 输入法切换快捷键没办法设置成 Shift； 所以如果用 ABC + 原生拼音输入法，切换太麻烦如果用可以通过 Shift 切换中英文的搜狗 + ABC 又总是会莫名其妙地被切换到 ABC 删除过程 下载一个能打开 .plist 文件的软件（PlistEdit Pro 或者 XCode 都行） 将当前输入法切换到 ABC 输入法 通过 PlistEdit Pro 或者 XCode 打开 ~/Library/Preferences/com.apple.HIToolbox.plist 依次点开 Root - AppleEnabledInputSources 会看到很多选项，如下图： 依次点开这些选项找到 Value 栏为 ABC 的选项删除掉 通过「访达」找到该文件，快捷键 Command + i 打开文件简介勾选「已锁定」 注销或重启 验证是否成功打开「系统偏好设置」-「键盘」-「输入法」查看是否已删除： 好了，删除成功了，可以开心的通过 Shift 切换中英文了 以上。","tags":[{"name":"macOS","slug":"macOS","permalink":"https://wiki.blanc.site/tags/macOS/"},{"name":"效率","slug":"效率","permalink":"https://wiki.blanc.site/tags/%E6%95%88%E7%8E%87/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"2-操作系统","slug":"3-计算机科学/2-计算机系统/2-操作系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"macOS","slug":"3-计算机科学/2-计算机系统/2-操作系统/macOS","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/macOS/"}]},{"title":"Django 不同环境下使用不同设置文件","date":"2019-07-24T00:00:00.000Z","path":"archives/55c5932a.html","text":"起因在使用 Django 开发项目的过程中总是会遇到生产环境和开发环境需要使用不同设置文件的情况，之前我都是在开发环境做完开发在后上传到服务器然后在服务器上修改设置文件，一来二去的就觉得很麻烦，恰巧昨天看到了这样一篇文章 Django 工程结构以及利用 Git 分支进行生产环境切换 里面描述了一种用利用 Git 分支在不同环境下切换设置文件的方法，但是说实话我没明白他这样做的意义，难道要为不同的环境创建不同的 Git 分支吗？可能是我 Git 学的不深不是很能理解，但是这篇文章还是给我提供了很好的思路。然后我又通过 Google 看到了另一篇文章 Django 开发环境与生产环境的区分，结合这两篇文章我自定义了下面的方案。 方案拆分设置文件，在不同环境下设置不同的环境变量然后通过 Python 的 os.environ.get 方法获取当前环境的环境变量，根据不同的环境变量 import 不同的设置文件，具体如下： 拆分设置文件在 Django 的 project 目录下新建 settings 目录，然后根据自己的需求在 settings 目录下创建诸如 base.py, dev.py, pro.py, test.py 之类的设置文件，我的需求比较简单只分了 base.py, dev.py, pro.py 三个文件，它们分别表示：基础设置，开发环境设置和生产环境设置。 给拆分后的设置文件设置入口一般情况下都是以 base.py 为拆分后的设置文件入口 1234567891011...# 根据环境变量导入不同设置文件# 如果环境变量中存在 ENV（具体值可行自定义）则判定为生产环境导入生产环境设置# 否则则判定为开发环境导入开发环境设置if os.environ.get('ENV', None): from .pro import *else: from .dev import *... 修改相关文件拆分完设置文件后需要修改那些引用了设置文件的文件：wsgi.py, manage.py 12345678910# wsgi.py# 修改此文件以确保通过 uwsgi 启动时程序能够正确的找到设置文件import osfrom django.core.wsgi import get_wsgi_application# 这一行是重点，意思是添加环境变量 DJANGO_SETTINGS_MODULE 为 backend.settings.bases# 具体值应根据个人项目的设置文件入口路径自行设置os.environ['DJANGO_SETTINGS_MODULE'] = 'backend.settings.base'application = get_wsgi_application() 1234567891011121314151617181920# manage.py# 修改此文件以确保通过 python manage.py runserver 启动时程序能够正确的找到设置文件#!/usr/bin/env pythonimport osimport sysif __name__ == '__main__': # 这一行是重点，意思是添加环境变量 DJANGO_SETTINGS_MODULE 为 backend.settings.bases # 具体值应根据个人项目的设置文件入口路径自行设置 os.environ['DJANGO_SETTINGS_MODULE'] = 'backend.settings.base' try: from django.core.management import execute_from_command_line except ImportError as exc: raise ImportError( \"Couldn't import Django. Are you sure it's installed and \" \"available on your PYTHONPATH environment variable? Did you \" \"forget to activate a virtual environment?\" ) from exc execute_from_command_line(sys.argv) 生产环境配置最后只需要在生产环境设置与入口文件匹配的环境变量即可： 1234# vim /etc/profile# 在最后一行添加：export ENV=\"SERVER\"# 随便设置什么值都行但是必须与入口文件匹配 开始使用做完以上配置以后就可以开始使用了，开发生产两套配置，不需要再上传后另外修改文件了。 总结通过方案能够看出整个过程的两个核心点是： 拆分设置文件 找到一个能通过 Python 区分不同环境的点 只要能完成以上两点就能自定义属于自己的方案。 参考EveryDay：Django 工程结构以及利用 Git 分支进行生产环境切换SmartKeyerror：Django 开发环境与生产环境的区分","tags":[{"name":"Django","slug":"Django","permalink":"https://wiki.blanc.site/tags/Django/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Django","slug":"2-软件使用/Django","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Django/"}]},{"title":"「转载」水晶头接法","date":"2019-07-22T00:00:00.000Z","path":"archives/4b35af27.html","text":"原文：网线怎么接 史上最全网线水晶头接法图解 (全文) 本文在不影响理解的前提下对原文内容进行了删减。 工具准备工具：网线钳、网线、水晶头、网线测试仪 网线制作好后，还需要测试下，是否能够正常使用，这就需要使用网线测线仪了。网线测线仪使用非常简单，以上是使用方法图解。 网线标准线序 标准568A：1绿白 ，2绿 ，3橙白 ，4蓝 ，5蓝白 ，6橙 ，7棕白 ，8棕标准586B：1橙白 ，2橙 ，3绿白 ，4蓝 ，5蓝白 ，6绿 ，7棕白 ，8棕 上网用到 1 2 3 6 其中 1 2 下传 3 6 上传电话用到 4 5 7 8 做为电源用 现在最常用的网线五类双绞线，它有 2 种接法，直通线和交叉线。 直通线直通线的两头都是 568B 标准，可以用于连接： 从 到 PC（电脑） HUB（集线器） PC（电脑） SWITCH（交换机） PC（电脑） ROUTER（路由器） HUB（集线器） HUB（集线器）的级连口 SWITCH（交换机） HUB（集线器）的级连口 SWITCH（交换机） SWITCH（交换机）级连口 SWITCH（交换机） ROUTER（路由器） 交叉线交叉线的一头是 568A，另一头是 568B，用来连接： 从 到 PC（电脑） PC（电脑） HUB（集线器） HUB（集线器） SWITCH（交换机） SWITCH（交换机） ROUTER（路由器） ROUTER（路由器） 总结一下：直通线就是两端线序相同的线，用于不同设备之间互连；交叉线就是两端线序不同线，用于同种设备之间互连。 网线水晶头制作步骤","tags":[{"name":"硬件相关","slug":"硬件相关","permalink":"https://wiki.blanc.site/tags/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Python 中的内置异常","date":"2019-07-22T00:00:00.000Z","path":"archives/4007339e.html","text":"基于 Python 3.7.4 中文文档-内置异常 在 Python 中，所有异常必须为一个派生自 BaseException 的类的实例。 基类 以下异常主要被用作其他异常的基类 BaseException所有内置异常的基类。 它不应该被用户自定义类直接继承 (Python 官方鼓励程序员从 Exception 类或它的某个子类而不是从 BaseException 来派生新的异常)。 如果在此类的实例上调用 str()，则会返回实例的参数表示，或者当没有参数时返回空字符串。 Exception所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。 ArithmeticError用于派生针对各种算术类错误而引发的内置异常: OverflowError, ZeroDivisionError, FloatingPointError。 BufferError与缓冲区相关的操作无法执行时将被引发。 LookupError用于派生映射或序列所使用的键或索引无效时引发的异常: IndexError, KeyError。 可以通过 codecs.lookup() 来直接引发。 具体异常 以下异常属于经常被引发的异常 AssertionErrorassert 语句失败时将被引发。 AttributeError属性引用或赋值失败时将被引发。 一个对象根本不支持属性引用或属性赋值时则将引发 TypeError。 EOFErrorinput() 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 另外，io.IOBase.read() 和 io.IOBase.readline() 方法在遇到 EOF 返回一个空字符串。 FloatingPointError目前未被使用。 GeneratorExit当一个 generator 或 coroutine 被关闭时将被引发。 它直接继承自 BaseException 而不是 Exception，因为从技术上来说它并不是一个错误。 ImportErrorimport 语句尝试加载模块遇到麻烦时将被引发。 from ... import 中的 from list 存在无法找到的名称时也会被引发。 ModuleNotFoundErrorImportError 的子类，当一个模块无法被定位时将由 import 引发。 在 sys.modules 中找到 None 时也会被引发。 IndexError序列抽取超出范围时将被引发。 切片索引会被静默截短到允许的范围；如果指定索引不是整数则 TypeError 会被引发。 KeyError在现有键集合中找不到指定的映射（字典）键时将被引发。 KeyboardInterrupt用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 BaseException 以确保不会被处理 Exception 的代码意外捕获，这样可以避免退出解释器。 MemoryError一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 malloc() 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。 NameError某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。 NotImplementedError此异常派生自 RuntimeError。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。 OSError一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如「文件未找到」或「磁盘已满」等（不包括非法参数类型或其他偶然性错误）。 OverflowError算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 MemoryError 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。 RecursionError此异常派生自 RuntimeError。 它会在解释器检测发现超过最大递归深度时被引发。 ReferenceError此异常将在使用 weakref.proxy() 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 RuntimeError检测到一个不归属于任何其他类别的错误时将被引发。关联的值是一个指明究竟发生了什么问题的字符串。 StopIteration由内置函数 next() 和 iterator 的 __next__() 方法所引发，用来表示该迭代器不能产生下一项。 该异常对象只有一个属性 value，它在构造该异常时作为参数给出，默认值为 None。 当一个 generator 或 coroutine 函数返回时，将引发一个新的 StopIteration 实例，函数返回的值将被用作异常构造器的 value 形参。 如果某个生成器代码直接或间接地引发了 StopIteration，它会被转换为 RuntimeError(并将 StopIteration 保留为导致新异常的原因)。 StopAsyncIteration必须由一个 asynchronous iterator 对象的 __anext__() 方法来引发以停止迭代操作。 SyntaxError解析器遇到语法错误时将被引发。 可以发生在 import 语句，对内置函数 exec() 或 eval() 的调用，或者读取原始脚本或标准输入（也包括交互模式）的时候。 IndentationError与不正确的缩进相关的语法错误的基类。 是 SyntaxError 的一个子类。 TabError缩进包含对制表符和空格符不一致的使用时将被引发。 是 IndentationError 的一个子类。 SystemError解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。 SystemExit此异常由 sys.exit() 函数引发。 它继承自 BaseException 而不是 Exception 以确保不会被处理 Exception 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。构造器接受的可选参数与传递给 sys.exit() 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 exit() 函数）；如果该值为 None，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。 TypeError一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。 UnboundLocalError在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。此异常是 NameError 的一个子类。 UnicodeError当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 ValueError 的一个子类。 UnicodeEncodeError在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子类。 UnicodeDecodeError当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子类。 UnicodeTranslateError在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 UnicodeError 的一个子类。 ValueError操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 IndexError 来描述时将被引发。 ZeroDivisionError除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。 版本兼容 下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 OSError 的别名。 EnvironmentError¶IOErrorWindowsError限在 Windows 中可用。 OS 异常 下列异常均为 ·OSError· 的子类，它们将根据系统错误代码被引发。 BlockingIOError一个操作会被某个设置为非阻塞操作的对象（例如套接字）所阻塞时将被引发。 对应于 errno EAGAIN, EALREADY, EWOULDBLOCK, EINPROGRESS。 ChildProcessError当一个子进程上的操作失败时将被引发。 对应于 errno ECHILD。 ConnectionError与连接相关问题的基类。 其子类有 BrokenPipeError, ConnectionAbortedError, ConnectionRefusedError, ConnectionResetError。 BrokenPipeError试图写入另一端已被关闭的管道，或是试图写入已关闭写入的套接字时将被引发。 对应于 errno EPIPE, ESHUTDOWN。 ConnectionAbortedError连接尝试被对端中止时将被引发。 对应于 errno ECONNABORTED。 ConnectionRefusedError连接尝试被对端拒绝时将被引发。 对应于 errno ECONNREFUSED。 ConnectionResetError连接被对端重置时将被引发。 对应于 errno ECONNRESET。 FileExistsError试图创建一个已存在的文件或目录时将被引发。 对应于 errno EEXIST。 FileNotFoundError所请求的文件或目录不存在时将被引发。 对应于 errno ENOENT。 InterruptedError系统调用被输入信号中断时将被引发。 对应于 errno EINTR。 IsADirectoryError请求对一个目录执行文件操作 (例如 os.remove()) 将被引发。 对应于 errno EISDIR。 NotADirectoryError请求对一个非目录对象执行目录操作 (例如 os.listdir()) 时将被引发。 对应于 errno ENOTDIR。 PermissionError在没有足够操作权限的情况下试图执行某个操作时将被引发 —— 例如缺少文件系统权限。 对应于 errno EACCES, EPERM。 ProcessLookupError给定的进程不存在时将被引发。 对应于 errno ESRCH。 TimeoutError一个系统函数发生系统级超时的情况下将被引发。 对应于 errno ETIMEDOUT。 警告 以下异常被用作警告类别。 Warning警告类别的基类。 ### UserWarning 用户代码所产生警告的基类。 DeprecationWarning如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。 PendingDeprecationWarning对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。 SyntaxWarning与模糊的语法相关的警告的基类。 RuntimeWarning与模糊的运行时行为相关的警告的基类。 FutureWarning如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。 ImportWarning与在模块导入中可能的错误相关的警告的基类。 UnicodeWarning与 Unicode 相关的警告的基类。 BytesWarning与 bytes 和 bytearray 相关的警告的基类。 ResourceWarning与资源使用相关的警告的基类。 会被默认的警告过滤器忽略。 异常层次结构内置异常的类层级结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError | +-- ModuleNotFoundError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError | +-- UnboundLocalError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- ReferenceError +-- RuntimeError | +-- NotImplementedError | +-- RecursionError +-- SyntaxError | +-- IndentationError | +-- TabError +-- SystemError +-- TypeError +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- ResourceWarning 参考Python 3.7.4 中文文档-内置异常","tags":[{"name":"内置异常","slug":"内置异常","permalink":"https://wiki.blanc.site/tags/%E5%86%85%E7%BD%AE%E5%BC%82%E5%B8%B8/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Python","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Python","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Python/"}]},{"title":"Python 中的异常处理","date":"2019-07-22T00:00:00.000Z","path":"archives/e0455099.html","text":"错误和异常目前在 Python 中（至少）有两种可区分的错误：语法错误和异常。 语法错误语法错误又称解析错误，可能是在学习 Python 时最容易遇到的错误： 12345&gt;&gt;&gt; while True print('Hello world') File \"&lt;stdin&gt;\", line 1 while True print('Hello world') ^SyntaxError: invalid syntax 异常在执行时检测到的错误被称为异常，大多数异常并不会被程序自动处理，此时会显示如下所示的错误信息： 123456789101112&gt;&gt;&gt; 10 * (1/0)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 4 + spam*3Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'spam' is not defined&gt;&gt;&gt; '2' + 2Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: Can't convert 'int' object to str implicitly 错误信息的最后一行告诉我们程序遇到了什么类型的错误。异常有不同的类型，而其类型名称将会作为错误信息的一部分中打印出来。这一行的剩下的部分根据异常类型及其原因提供详细信息。 错误信息的前一部分以堆栈回溯的形式显示发生异常时的上下文。通常它包含列出源代码行的堆栈回溯；但是它不会显示从标准输入中读取的行。 作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，但对于用户定义的异常则不一定如此（虽然这是一个有用的规范）。标准的异常类型是内置的标识符（而不是保留关键字）。 内置异常篇幅问题，请参考：Python 中的内置异常 异常处理异常处理工作由「捕获」和「抛出」两部分组成。「捕获」指的是使用 try ... except 包裹特定语句，妥当的完成错误流程处理。而恰当的使用 raise 主动「抛出」异常，更是优雅代码里必不可少的组成部分。 捕获try 语句的工作原理 首先，执行 try 子句（try 和 except 关键字之间的（多行）语句）。 如果没有异常发生，则跳过 except 子句并完成 try 语句的执行。 如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分。然后，如果异常的类型和 except 关键字后面的异常匹配，则执行 except 子句 ，然后继续执行 try 语句之后的代码。 如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个未处理异常，执行将停止并显示错误的消息。 一个 try 语句可能有多个 except 子句，以指定不同异常的处理程序，但最多会执行一个处理程序。处理程序只处理相应的 try 子句中发生的异常，而不处理同一 try 语句内其他处理程序中的异常。一个 except 子句可以将多个异常命名为带括号的元组，例如: 12... except (RuntimeError, TypeError, NameError):... pass 如果发生的异常和 except 子句中的类是同一个类或者是它的基类，则异常和 except 子句中的类是兼容的（但反过来则不成立）。例如，下面的代码将依次打印 B, C, D 123456789101112131415161718class B(Exception): passclass C(B): passclass D(C): passfor cls in [B, C, D]: try: raise cls() except D: print(\"D\") except C: print(\"C\") except B: print(\"B\") 请注意如果 except 子句被颠倒（把 except B 放到第一个），它将打印 B，B，B — 即第一个匹配的 except 子句被触发。 最后的 except 子句可以省略异常名，以用作通配符。但请谨慎使用，因为以这种方式很容易掩盖真正的编程错误！它还可用于打印错误消息，然后重新引发异常（同样允许调用者处理异常）。 try ... except 语句有一个可选的 else 子句，在使用时必须放在所有的 except 子句后面。对于在 try 子句不引发异常时必须执行的代码来说很有用。 使用 else 子句比向 try 子句添加额外的代码要好，因为它避免了意外捕获由 try ... except 语句保护的代码未引发的异常。 异常处理程序不仅处理 try 子句中遇到的异常，还处理 try 子句中调用（即使是间接地）的函数内部发生的异常。 异常参数发生异常时，它可能具有关联值，也称为异常参数。参数的存在和类型取决于异常类型。 except 子句可以在异常名称后面指定一个变量。这个变量和一个异常实例绑定，它的参数存储在 instance.args 中。为了方便起见，异常实例定义了 __str__()，因此可以直接打印参数而无需引用 .args。也可以在抛出之前首先实例化异常，并根据需要向其添加任何属性。 12345678910111213141516&gt;&gt;&gt; try:... raise Exception('spam', 'eggs')... except Exception as inst:... print(type(inst)) # the exception instance... print(inst.args) # arguments stored in .args... print(inst) # __str__ allows args to be printed directly,... # but may be overridden in exception subclasses... x, y = inst.args # unpack args... print('x =', x)... print('y =', y)...&lt;class 'Exception'&gt;('spam', 'eggs')('spam', 'eggs')x = spamy = eggs 如果异常有参数，则它们将作为未处理异常的消息的最后一部分（详细信息）打印。 抛出raise 语句允许程序员强制发生指定的异常。例如: 1234&gt;&gt;&gt; raise NameError('HiThere')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: HiThere raise 唯一的参数就是要抛出的异常。这个参数必须是一个异常实例或者是一个异常类（派生自 Exception 的类）。如果传递的是一个异常类，它将通过调用没有参数的构造函数来隐式实例化: 1raise ValueError # raise ValueError() 的简写 如果你需要确定是否引发了异常但不打算处理它，则可以使用更简单的 raise 语句形式重新引发异常： 12345678910&gt;&gt;&gt; try:... raise NameError('HiThere')... except NameError:... print('An exception flew by!')... raise...An exception flew by!Traceback (most recent call last): File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;NameError: HiThere 用户自定义异常程序可以通过创建新的异常类来命名它们自己的异常。异常通常应该直接或间接地从 Exception 类派生。 可以定义异常类，它可以执行任何其他类可以执行的任何操作，但通常保持简单，通常只提供许多属性，这些属性允许处理程序为异常提取有关错误的信息。在创建可能引发多个不同错误的模块时，通常的做法是为该模块定义的异常创建基类，并为不同错误条件创建特定异常类的子类。 大多数异常都定义为名称以 Error 结尾，类似于标准异常的命名。 许多标准模块定义了它们自己的异常，以报告它们定义的函数中可能出现的错误。 定义清理操作try 语句有另一个可选子句，用于定义必须在所有情况下执行的清理操作。 finally 子句总会在离开 try 语句前被执行，无论是否发生了异常。当在 try 子句中发生了异常且尚未被 except 子句处理（或者它发生在 except 或 else 子句中）时，它将在 finally 子句执行后被重新抛出。当 try 语句的任何其他子句通过 break, continue, return 语句离开时，finally 也会在「离开之前」被执行。 在实际应用程序中，finally 子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是否成功使用资源。 进行异常处理时的小技巧传递异常有时我们会在捕捉到一个异常后重新引发它（传递异常），实现起来很简单，使用不带参数的 raise 语句即可，例如： 1234567891011def f1(): print(1/0)def f2(): try: f1() except Exception as e: print('something worng') raisef2() 12345678910# 运行结果something worngTraceback (most recent call last): File &quot;&#x2F;Users&#x2F;ryoma&#x2F;Desktop&#x2F;project&#x2F;learn&#x2F;learn_python&#x2F;python_exception.py&quot;, line 11, in &lt;module&gt; f2() File &quot;&#x2F;Users&#x2F;ryoma&#x2F;Desktop&#x2F;project&#x2F;learn&#x2F;learn_python&#x2F;python_exception.py&quot;, line 6, in f2 f1() File &quot;&#x2F;Users&#x2F;ryoma&#x2F;Desktop&#x2F;project&#x2F;learn&#x2F;learn_python&#x2F;python_exception.py&quot;, line 2, in f1 print(1&#x2F;0)ZeroDivisionError: division by zero 使用内置的语法规范代替 try/exceptPython 本身提供了很多语法范式简化了异常处理，例如： for 语句利用 Stoplteration 异常来结束循环的 with 语句在打开文件后会在操作结束后（无论是否正常结束）会自动关闭文件句柄 使用 getattr() 函数获取对象中的不确定属性 以上这些都是 Python 自身封装好的语法范式，在处理这些事件的时候应避免使用 try/except/finally 的思维来处理。 异常处理的三个好习惯只做精确的异常捕获在 Python 中使用异常捕获的目的并不是使自己写的代码不出现任何异常，而是在可能因外部力量而出错的部分进行预防，例如对用户输入部分进行异常捕获。 在 Python 中使用异常捕获时应捕获尽可能精确的异常类型，而不是模糊的 Exception，因为模糊的捕获 Exception 有时会导致本该被显示的有用的错误信息被自定义的错误信息「吃」掉。 另外，使自己写的代码不出现任何异常的最好方法是规范的代码书写习惯。 别让异常破坏代码抽象分层的一致性很多场景下我们会对异常类进行包装，方便在产生已知异常时自定义错误信息，这样做能大大提高后续的编码效率，但在使用时如果没有做好分层处理很容易击穿代码的抽象分层逻辑，具体案例请参考 Python 工匠： 异常处理的三个好习惯。 为了避免因为使用错误的异常处理方式导致代码的抽象分层逻辑被打破： 让模块只调用与当前抽象层级一致的异常类，既不能高于当前抽象层级，也不能低于当前抽象层级 在需要跨层级调用异常类时应通过异常包装与转换的方法进行，而不是直接跨层级调用异常类 异常处理不应该喧宾夺主当非异常处理逻辑代码中存在大量异常处理操作时，很容易出现因异常处理的逻辑代码太多而扰乱核心的逻辑代码。 123456789101112131415161718192021# 代码来自：Python 工匠：异常处理的三个好习惯def upload_avatar(request): \"\"\"用户上传新头像\"\"\" try: avatar_file = request.FILES['avatar'] except KeyError: raise error_codes.AVATAR_FILE_NOT_PROVIDED try: resized_avatar_file = resize_avatar(avatar_file) except FileTooLargeError as e: raise error_codes.AVATAR_FILE_TOO_LARGE except ResizeAvatarError as e: raise error_codes.AVATAR_FILE_INVALID try: request.user.avatar = resized_avatar_file request.user.save() except Exception: raise error_codes.INTERNAL_SERVER_ERROR return HttpResponse(&#123;&#125;) 此时我们可以使用 Python 中的 上下文管理器（context manager）配合 with 语句简化异常处理过程。 1234567891011121314151617181920212223# 代码来自：Python 工匠：异常处理的三个好习惯class raise_api_error: \"\"\"captures specified exception and raise ApiErrorCode instead :raises: AttributeError if code_name is not valid \"\"\" def __init__(self, captures, code_name): self.captures = captures self.code = getattr(error_codes, code_name) def __enter__(self): # 刚方法将在进入上下文时调用 return self def __exit__(self, exc_type, exc_val, exc_tb): # 该方法将在退出上下文时调用 # exc_type, exc_val, exc_tb 分别表示该上下文内抛出的 # 异常类型、异常值、错误栈 if exc_type is None: return False if exc_type == self.captures: raise self.code from exc_val return False 在上面的代码里，定义了一个名为 raise_api_error 的上下文管理器，它在进入上下文时什么也不做。但是在退出上下文时，会判断当前上下文中是否抛出了类型为 self.captures 的异常，如果有，就用 APIErrorCode 异常类替代它。 使用该上下文管理器后，上面臃肿的 upload_avatar 函数变得更清晰简洁： 1234567891011121314# 代码来自：Python 工匠：异常处理的三个好习惯def upload_avatar(request): \"\"\"用户上传新头像\"\"\" with raise_api_error(KeyError, 'AVATAR_FILE_NOT_PROVIDED'): avatar_file = request.FILES['avatar'] with raise_api_error(ResizeAvatarError, 'AVATAR_FILE_INVALID'),\\ raise_api_error(FileTooLargeError, 'AVATAR_FILE_TOO_LARGE'): resized_avatar_file = resize_avatar(avatar_file) with raise_api_error(Exception, 'INTERNAL_SERVER_ERROR'): request.user.avatar = resized_avatar_file request.user.save() return HttpResponse(&#123;&#125;) 参考感谢参考文章的作者（译者） Python 3.7.4 中文文档-错误和异常Python 工匠： 异常处理的三个好习惯地球的外星人君:一文掌握 Python 异常处理的所有知识点","tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://wiki.blanc.site/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Python","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Python","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Python/"}]},{"title":"CentOS 7 安装 Java 环境","date":"2019-07-20T00:00:00.000Z","path":"archives/2c12e091.html","text":"本文主要讲述在 CentOS 7 下如何安装并部署 Java 环境 从2015年4月16日开始，Oracle JDK许可证已更改。 新许可证允许某些用途（例如个人使用和开发用途）免费使用 - 但根据以前的 Oracle JDK 许可证授权的其他用途可能不再可用。 截取自 Oracle Java 下载网址（机翻） 下载下载地址：点击跳转 这里要根据你的系统情况选择不同文件，另外还要注意看你选择的文件的后缀，如果不懂的话尽可能选后缀为 .tar.gz 的 点击之后他会提醒你进行登录，如果你没有账号则需要先注册一个账号再进行登录 貌似是不登录没办法下载（我个人懒得研究了） 先在本地下载然后通过 FTP 工具传输到 CentOS 系统中 也可以复制带有授权码的下载链接使用命令行工具 wget 下载 安装1. 将文件解压到当前目录1tar -zxvf jdk-8u221-linux-x64.tar.gz 注意这里具体的文件名叫什么与你当时下载的版本有关 2. 将文件转移到常用软件目录1mv ./jdk1.8.0_221/ /usr/local/java/ 设置环境变量1. 使用 vim 打开文件系统环境文件1vim &#x2F;etc&#x2F;profile 2. 在末尾添加1234export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;javaexport JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jreexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;libexport PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH 3. 使环境变量生效1source &#x2F;etc&#x2F;profile 4. 添加软连接1ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java 4. 检查是否生效1java -version 参考游魂：CentOS 7 安装 JAVA环境（JDK 1.8）","tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://wiki.blanc.site/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"Java","slug":"Java","permalink":"https://wiki.blanc.site/tags/Java/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux 下的压缩和解压缩","date":"2019-07-20T00:00:00.000Z","path":"archives/9a031a35.html","text":"Linux 下常见的压缩文件格式有： 1.tar .gz .tar.gz .tgz .bz2 .tar.bz2 .Z .tar.Z .zip .rar 下面我们就分别讲一下在 Linux 下如何用不同的方式对文件进行打包、压缩和解压缩 tarLinux 下最常用的打包程序就是 tar 了，使用 tar 程序打出来的包我们常称为 tar包，tar包 文件的命令通常都是以 .tar 结尾的。生成 tar包 后，就可以用其它的程序来进行压缩了。 基本用法：打包 -c1234# 将所有 .jpg 文件打包为 all.tartar -cf all.tar *.jpg# -c 表示产生新的包# -f 指定包的文件名 添加 -r1234# 将所有 .gif 文件添加到 all.tartar -rf all.tar *.gif# -r 增加文件# -f 指定包的文件名 更新 -u1234# 更新 all.tar 中 logo.gif 文件tar -uf all.tar logo.gif# -u 更新文件# -f 指定包的文件名 列出 -t1234# 列出 all.tar 中所有文件tar -tf all.tar# -t 列出文件# -f 指定包的文件名 解包 -x1234# 解包 all.tar 中所有文件tar -xf all.tar# -x 解包# -f 指定包的文件名 tar 与其他压缩程序为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能：可以在打包或解包的同时调用其它的压缩程序，比如：gzip bzip2 等。 tar 与 gzipgzip 是 GNU 组织开发的一个压缩程序，.gz结尾的文件就是 gzip 压缩的结果。 单纯的 .gz 用 gunzip 命令解压 tar 中使用 -z 这个参数来调用 gzip，举例说明： 打包并使用 gzip 压缩1234tar -czf all.tar.gz *.jpg# -c 表示产生新的包# -z 调用 gzip# -f 指定包的文件名 使用 gzip 解压缩并解包1234tar -xzf all.tar.gz# -x 解包# -z 调用 gzip# -f 指定包的文件名 tar 与 bzip2bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。 单纯的 .bz2 用 bunzip2 命令解压 tar 中使用 -j 这个参数来调用 bzip2，举例说明： 打包并使用 bzip2 压缩1234tar -cjf all.tar.bz2 *.jpg# -c 打包# -j 调用 bzip2# -f 指定包的文件名 使用 bzip2 解压缩并解包1234tar -xjf all.tar.bz2# -x 解包# -j 调用 bzip2# -f 指定包的文件名 tar 与 compresscompress 也是一个压缩程序，但使用人数并不多，.Z 结尾的文件就是 compress 压缩的结果。 单纯的 .Z 用 uncompress 命令解压 tar 中使用 -Z 这个参数来调用 compress，举例说明： 打包并使用 compress 压缩1234tar -cZf all.tar.Z *.jpg# -c 打包# -Z 调用 compress# -f 指定包的文件名 使用 compress 解压缩并解包1234tar -xZf all.tar.Z# -x 解包# -Z 调用 compress# -f 指定包的文件名 总结 tar 知识12345678910111213141516-c 打包-x 解包 -t 查看内容 -r 向压缩归档文件末尾追加文件 -u 更新原压缩包中的文件以上五个是独立的命令参数，可以和别的命令连用但只能用其中一个下面的参数是根据需要在压缩或解压时按需搭配-z 调用 gzip -j 调用 bzip2 -Z 调用 compress -v 显示过程 -O 将文件解压到标准输出 -f 为必要参数，所有命令都必须标明-f 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 zip 和 rar.zip 和 .rar 是 Window 下的常见压缩文件，Linux也有相应的方法来解压它们： zipLinux 下提供了 zip 和 unzip 程序，zip 是压缩命令程序，unzip 是解压命令程序。它们的参数选项很多，这里只做简单介绍： 压缩12# 将所有 .jpg 文件压缩成一个 zip 包zip all.zip *.jpg 解压12# 将 all.zip 中的所有文件解压出来unzip all.zip rar要在 Linux 下处理 .rar 文件，需要安装 RAR for Linux，可以从网上下载 下载地址：http://www.rarsoft.com/download.htm 安装后就有了 rar 和 unrar 这两个命令程序，rar 压缩，unrar 解压。依旧只做简单介绍： 压缩12# 将所有 .jpg 文件压缩成 all.rar，该程序会将 .rar 扩展名将自动附加到包名后rar a all *.jpg 解压12# 将 all.rar 中的所有文件解压出来unrar e all.rar 总结到此为至，已经介绍了 Linux 下的 tar gzip gunzip bzip2 bunzip2 compress uncompress zip unzip rar unrar 等命令工具，使用它们可以对 .tar 、.gz、.tar.gz、.tgz、.bz2、.tar.bz2、. Z、.tar.Z、.zip、.rar 这 10种 压缩文件进行解压。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wiki.blanc.site/tags/Linux/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"正则表达式中的回溯过程","date":"2019-07-16T00:00:00.000Z","path":"archives/7172d605.html","text":"本文所有正则表达式皆为 JavaScript 正则形式本文所有图片和实例都来自：知乎-老姚：正则表达式回溯法原理 回溯算法 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就「回溯」返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为「回溯点」。许多复杂的，规模较大的问题都可以使用回溯法，有「通用解题方法」的美称。 来自「百度百科」 正则中的回溯没有回溯过程的正则匹配正则表达式：/ab{1,3}c/目标字符串：abbbc 有回溯过程的正则匹配正则表达式：/ab{1,3}c/目标字符串：abbc 分析从有回溯过程的正则匹配过程可视化图能够看到，进行到第四步时 /ab{1,3}c/ 已经匹配到了字符串 abbc 中的 abb 到第五步时正则表达式会继续尝试匹配第三个 b 然而字符串中已经没有更多的 b 可供匹配，因此我们能够看到第五步中 c 标有红色，代表的是正则匹配第三个 b 失败。 至此整个正则匹配的过程并没有完成，正则没有直接返回匹配失败而是： 将匹配节点回退到字符串 abbc 中的 abb 后； 结束 b{1,3} 的匹配开始 c 的匹配； 如上两步也是图中第六步所做的事情，整个过程就是「回溯」的过程。 这里我仅引用了 知乎-老姚：正则表达式回溯法原理 中的第一个也是最简单的一个例子作为讲解「正则中的回溯过程」的实例，而该文中还有两个更能体现回溯过程的实例如果感兴趣的话可以自行查看。 参考知乎-老姚：正则表达式回溯法原理百度百科：回溯算法","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://wiki.blanc.site/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"「未完成」正则中的贪婪模式与非贪婪模式","date":"2019-07-15T00:00:00.000Z","path":"archives/cb0153ff.html","text":"概览正则表达式中，贪婪模式与非贪婪模式指的是不同条件下被量词修饰的子表达式的匹配行为： 贪婪模式在整个表达式匹配成功的前提下会尽可能多的匹配； 非贪婪模式在整个表达式匹配成功的前提下会尽可能少的匹配； 非贪婪模式只被部分 NFA引擎 所支持； 常见的贪婪模式量词，也称匹配优先量词： 1&#123;m,n&#125; &#123;m,&#125; ? * + 在一些使用 NFA引擎 的语言中，在匹配优先量词后加上 ?，即变成非贪婪模式量词，也叫做忽略优先量词，有： 1&#123;m,n&#125;? &#123;m,&#125;? ?? *? +? 从正则语法的角度来讲，被匹配优先量词修饰的子表达式使用的就是贪婪模式，被忽略优先量词修饰的子表达式使用的就是非贪婪模式。 应用### 原理","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://wiki.blanc.site/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"单点问题","date":"2019-07-11T00:00:00.000Z","path":"archives/f1bf1c1a.html","text":"是什么？在分布式系统中，如果某个功能只有某台单机在支撑，那么这个节点称为单点，发生的故障称为单点故障，也就是常说的 SPoF(Single Point of Failure)。 如何避免？ 增加冗余节点 增加系统层次化 参考 Chare’s Blog：分布式系统的难点 AQ王浩：单点故障","tags":[{"name":"单点问题","slug":"单点问题","permalink":"https://wiki.blanc.site/tags/%E5%8D%95%E7%82%B9%E9%97%AE%E9%A2%98/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"注册中心","date":"2019-07-11T00:00:00.000Z","path":"archives/a07e5380.html","text":"这里讲的注册中心指的是微服务框架和分布式架构中的注册中心。 名词解释 名词 含义 服务(Service) 一般指一个接口，可以包含多个方法。例如：订单服务包含查询订单、新增订单等方法。 服务提供者(Provider) 暴露一个监听端口，提供一到多个服务。 服务调用者(Consumer) 连接服务提供者的端口，发起远程调用。 注册中心(Registry) 服务注册中心，本文指微服务或分布式架构中的组件。 注册中心客户端(Registry Client) 不管是服务提供者还是服务调用者都算是注册中心客户端，简称客户端。 注册中心管理端(Registry Console) 注册中心数据的管理端，简称管理端。 是什么注册中心像是架构中的「通讯录」，记录了服务和服务地址的映射关系。 在架构中服务会注册到这里，当服务需要调用其他服务时，就在这里查询服务的地址进行调用。 功能有 服务发现 服务注册/反注册：保存服务提供者和服务调用者的信息 服务订阅/取消订阅：服务调用者订阅服务提供者的信息，最好有实时推送的功能 服务路由：具有筛选整合服务提供者的功能。 服务配置 配置订阅：服务提供者和服务调用者订阅相关的配置 配置下发：主动将配置推送给服务提供者和服务调用者 服务健康监测 检测服务提供者的健康情况 思考Django框架 是不是就可以看成一个注册中心，各种 Api接口 可以看做一个个服务 和群友讨论了一下，一位群友说：Django App 不能单独使用，因此不能算作服务 那有没有可能通过修改 Django 令 Django App 可以单独使用？ 参考章耿：服务注册中心架构演进noONE：微服务架构基础之注册中心","tags":[{"name":"注册中心","slug":"注册中心","permalink":"https://wiki.blanc.site/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"ZooKeeper 入门简介","date":"2019-07-11T00:00:00.000Z","path":"archives/f1db9330.html","text":"是什么？ Zookeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。 《从 Paxos 到 ZooKeeper》 ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。 ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。 Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)。 概念1. SessionSession 指的是 ZooKeeper 服务器与客户端会话。 在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。 通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch 事件通知。 在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都要保证全局唯一。 2. Znode在谈到分布式的时候，我们通常说的「节点」是指组成集群的每一台机器。然而，在 Zookeeper 中，「节点」分为两类：第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一znode。 3. 版本Zookeeper 会为每个 znode 都维护一个 Stat 数据结构，Stat 中记录了这个 ZNode 的三个数据版本，分别是：version（当前 znode 的版本）、cversion（当前 znode 子节点的版本）和 aversion（当前 znode 的 ACL 版本）。 4. WatcherWatcher（事件监听器），是 Zookeeper 中的一个重要特性。Zookeeper 允许用户在指定节点上注册一个或多个 Watcher，在一些特定事件发生时触发 Watcher 将事件通知到感兴趣的客户端上去，该机制是 Zookeeper 实现分布式协调服务的重要特性。 5. ACLZookeeper 采用 ACL(Access Control Lists) 策略来进行权限控制，类似于 UNIX 文件系统的权限控制。Zookeeper 定义了如下 5种 权限。 其中尤其需要注意的是，CREATE 和 DELETE 这两种权限都是针对子节点的权限控制。 特性 ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）； 为了保证高可用，最好以集群形态来部署 ZooKeeper，这样只要集群中大部分机器可用，ZooKeeper 本身就是可用的； ZooKeeper 将数据保存在内存中，保证了高吞吐量和低延迟，但内存限制了能够存储的容量不大，此限制也是保持 znode 中存储的数据量较小的一个原因； ZooKeeper 是高性能的。 在「读」多于「写」的应用程序中尤其地高性能，因为「写」会导致所有的服务器间同步状态； ZooKeeper 有临时节点的概念。 只要创建临时节点的客户端会话保持活动，临时节点会一直存在，会话终结，临时节点会被删除。持久节点是指一旦某个 znode 被创建，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 Zookeeper 上； ZooKeeper 底层其实只提供了两个功能，即：管理（存储、读取）用户程序提交的数据和为用户程序提供数据节点监听服务； 特点 顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。 原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。 单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。 可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。 集群最典型集群模式： Master/Slave 模式（主备模式）。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。 但是，在 ZooKeeper 中没有选择传统的 Master/Slave，而是引入了 Leader Follower Observer 三种角色。如下图所示 ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 Leader 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的「过半写成功」策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。 当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的 Leader 服务器。这个过程大致是这样的： Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 Leader； Discovery（发现阶段）：在这个阶段，Followers 跟准 Leader 进行通信，同步 Followers 最近接收的事务提议； Synchronization（同步阶段）：同步阶段主要是利用 Leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 Leader 才会成为真正的 Leader； Broadcast（广播阶段）：到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 Leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。 参考JavaGuide：ZooKeeper 相关概念总结","tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://wiki.blanc.site/tags/ZooKeeper/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"ZooKeeper","slug":"2-软件使用/ZooKeeper","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ZooKeeper/"}]},{"title":"ZooKeeper 命令","date":"2019-07-11T00:00:00.000Z","path":"archives/2b7b1ffc.html","text":"zkServer 启动 zkServer：zkServer.sh start 查看 zkServerr：zkServer.sh status 停止 zkServer：zkServer.sh stop 重启 zkServer：zkServer.sh restart zkCli 启动 zkCli：zkCli.sh -server localhost:2181 Client 命令行模式下 命令 功能 h 显示所有命令 ls path 查看某个节点下的所有子节点信息 stat path 获取指定节点的状态信息 get path 获取当前节点的数据内容 ls2 path ls 和 stat 两个命令的结合 create [-s] [-e] path data acl 创建节点 quit 退出客户端 set path data [version] 修改当前节点的数据内容 如果指定版本，需要和当前节点的数据版本一致 delete path [version] 删除指定路径的节点，如果有子节点要先删除子节点 rmr path 删除当前路径节点及其所有子节点 setquota -n｜-b val path 设置节点配额（比如限制节点数据长度，限制节点中子节点个数） listquota path 查看路径节点的配额信息 delquota [-n｜-b] path 删除节点路径的配额信息 connect host:port 和 clost 在当前连接中连接其他的 ZooKeeper 服务器和关闭服务器 history 和 redo cmdno 查看客户端这次会话所执行的所有命令 和 执行指定历史命令 节点状态信息 状态代码 状态信息 czxid 创建该节点的事务 id ctime 创建该节点的时间 pZxid 操作当前节点的子节点列表的事务 id cversion 当前节点的子节点版本号 dataVersion 当前节点的数据版本号 aclVersion 当前节点的 acl 权限版本号 ephemeralowner 当前节点的如果是临时节点，该属性是临时节点的事务 id dataLength 当前节点的数据长度 numchildren 当前节点的子节点个数 四字命令ZooKeeper 支持某些特定的四字命令字母与其的交互。它们大多是查询命令，用来获取 ZooKeeper 服务的当前状态及相关信息。 四字命令 命令功能 conf 输出相关服务配置的详细信息 cons 列出所有连接到服务器的客户端的全部连接/会话信息 dump 列出未经处理的会话和临时节点 envi 输出关于服务环境的详细信息（区别于 conf 命令） reqs 输出相关服务配置的详细信息 ruok 测试是否启动了该 Server，若回复 imok 表示已经启动 stat 来查看哪个节点被选择作为 follower 或者 leader wchs 列出服务器 watch 的详细信息 wchc 通过 session 列出服务器 watch 的详细信息 wchp 通过路径列出服务器 watch 的详细信息 使用方式：echo stat | nc 127.0.0.1 2181 参考三丰SanFeng：zookeeper命令行(zkCli.sh&amp;zkServer.sh)使用及四字命令RedAnts：ZooKeeper 之 zkCli.sh客户端的命令使用","tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://wiki.blanc.site/tags/ZooKeeper/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"ZooKeeper","slug":"2-软件使用/ZooKeeper","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ZooKeeper/"}]},{"title":"ZooKeeper 配置文件解析","date":"2019-07-11T00:00:00.000Z","path":"archives/bb55e9ff.html","text":"最低配置以下是必须在配置文件中定义的最低配置选项： tickTime: ZooKeeper 中使用的基本时间单元, 以「毫秒」为单位, 默认值是 2000。它用来调节心跳和超时。例如, 默认的会话超时时间是两倍的 tickTime。 dataDir: ZooKeeper 用来存储内存数据库快照的目录, 并且除非指定其它目录, 否则数据库更新的事务日志也将会存储在该目录下。建议配置 dataLogDir 参数来指定 ZooKeeper 事务日志的存储目录。 clientPort: 服务器监听客户端连接的端口, 也即客户端尝试连接的端口, 默认值是 2181。 secureClientPort：服务器监听通过 SSL 连接的客户端端口。clientPort 指定明文连接的端口，而 secureClientPort 指定 SSL 连接的端口。 高级配置 dataLogDir: 事务日志的存储目录，设置日志设备对吞吐量和稳定的延迟有很大的影响。建议将事务日志单独存储在日志设备中并通过 dataLogDir 属性设置存储目录。 globalOutstandingLimit: 客户端提交请求的速度比 ZooKeeper 处理请求的速度要快，特别是在有很多客户端的情况下。为了防止 ZooKeeper 由于排队的请求而耗尽内存，ZooKeeper 将限制客户端请求数为 globalOutstandingLimit。默认为1000。对应 Java 系统属性: zookeeper.globalOutstandingLimit。 preAllocSize: snapCount: maxClientCnxns: 在 socket 级别限制单个客户端与单台服务器之前的并发连接数量, 可以通过 IP地址 来区分不同的客户端。它用来防止某种类型的 DoS攻击, 包括文件描述符耗尽。默认值是 60。将其设置为 0 将完全移除并发连接数的限制。 clientPortAddress: minSessionTimeout: maxSessionTimeout: fsync.warningthresholdms: autopurge.snapRetainCount: 配置 ZooKeeper 在自动清理的时候需要保留的数据文件快照的数量和对应的事务日志文件, 默认值是 3。 autopurge.purgeInterval: 和参数 autopurge.snapRetainCount 配套使用, 用于配置 ZooKeeper 自动清理文件的频率, 默认值是 1, 即默认开启自动清理功能, 设置为 0 则表示禁用自动清理功能。 syncEnabled: zookeeper.extendedTypesEnabled: zookeeper.emulate353TTLNodes: serverCnxnFactory: 集群选项 electionAlg: initLimit: 默认值是 10, 即 tickTime 属性值的 10倍。它用于配置允许 followers 连接并同步到 leader 的最大时间。如果 ZooKeeper 管理的数据量很大的话可以增加这个值。 leaderServes: server.x=[hostname]:nnnnn[:nnnnn]: syncLimit: 默认值是 5, 即 tickTime 属性值的 5倍。它用于配置 leader 和 followers 间进行心跳检测的最大延迟时间。如果在设置的时间内 followers 无法与 leader 进行通信, 那么 followers 将会被丢弃。 group.x=nnnnn[:nnnnn]: weight.x=nnnnn: cnxTimeout: standaloneEnabled: reconfigEnabled: 4lw.commands.whitelist: tcpKeepAlive: ** 参考ZooKeeper 官网珍爱矢豆：ZooKeeper 安装和配置","tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://wiki.blanc.site/tags/ZooKeeper/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"ZooKeeper","slug":"2-软件使用/ZooKeeper","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ZooKeeper/"}]},{"title":"tmux 入门 + 快捷键整理","date":"2019-05-27T00:00:00.000Z","path":"archives/9e40babb.html","text":"123本文全部快捷键和配置文件均在以下环境成功运行：操作系统：macOS 10.14tmux 版本：tmux 2.9a 最近进入了工作热情高涨的时期，疯狂的重构、打包、上传，每次这样搞都要重复开好多的终端窗口而且要一个一个的用鼠标点来点去的很麻烦（最近莫名的嫌弃鼠标），所以想起了之前被自己放到「待会儿再读」收藏夹的「十分钟学会 tmux」，貌似这个工具可以帮助我更好的管理终端窗口。 话不多说直接上手： PS：如果你也像我一样第一次接触这类软件，那么我建议你不要观望，先把软件下下来然后根据快捷键列表一个一个的尝试一次，再决定要不要使用，整个过程不超过十分钟但是却能给你节省 N 多观望的时间。 安装 tmuxtmux 可以应用在各类终端上（Windows 下未测试）支持 Vi/Emacs 风格的键盘映射 1234brew install tmux # MacOSpacman -S tmux # Arch Linuxapt-get install tmux # Ubuntuyun install tmux # CentOS 因为装了黑苹果所以不太关注 Windows 了，简单的搜索了一下网上是有 Windows 下的解决方案的，这里给出一个我看到的文章（未验证）：OneFeed：在 Windows 上安装 tmux 名词理解 名词 个人理解 Session 会话 相当于一个浏览器进程 Window 窗口 相当于一个浏览器窗口 Tab 窗格 相当于一个浏览器页面 基本操作123456tmux new -s foo # 新建名为 foo 的会话tmux ls # 列出全部会话tmux a # 恢复上一次会话tmux a -t foo # 恢复名为 foo 的会话tmux kill-session -t foo # 删除名为 foo 的会话tumx kill-server # 删除所有会话 常用快捷键整理tmux 默认前缀为 ctrl + b 注意：下面的快捷键整理中默认省略前缀 注意：以下仅整理了比较常用的快捷键，可以在 tmux 中通过 ctrl + b + ? 的形式获取全部快捷键 Session 会话类123:new&lt;Enter&gt; # 启动新的会话s # 列出全部会话$ # 重命名当前会话 Window 窗口类12345678910c # 创建新的窗口w # 列出全部窗口n # 跳到下一个窗口p # 跳到前一个窗口f # 查找窗口, # 重命名当前窗口&amp; # 关闭当前窗口swap-window -s 3 -t 1 # 交换 3 号和 1 号窗口swap-window -t 1 # 交换当前窗口和 1 号窗口move-window -t 1 # 移动当前窗口到 1 号窗口 Tab 窗格类123456789101112131415% # 垂直分割\" # 水平分割o # 交换窗格x # 关闭窗格空格 # 切换布局q # 显示每个窗格序号，可以通过序号快速定位&#123; # 与上一个窗格交换位置&#125; # 与下一个窗格交换位置z # 切换窗格最大化/最小化:resize-pane -D # 当前窗格向下扩大 1 格:resize-pane -U # 当前窗格向上扩大 1 格:resize-pane -L # 当前窗格向左扩大 1 格:resize-pane -R # 当前窗格向右扩大 1 格:resize-pane -D 20 # 当前窗格向下扩大 20 格:resize-pane -t 2 -L 20 # 编号为 2 的窗格向左扩大 20 格 杂项1234d # 退出 tmux（tmux 仍在后台运行）t # 窗口中央显示一个数字时钟? # 列出所有快捷键: # 命令提示符 配置选项1234567891011121314151617# 鼠标支持 - 设置为 on 来启用鼠标(与 2.1 之前的版本有区别，请自行查阅 man page)* set -g mouse on# 设置默认终端模式为 256colorset -g default-terminal \"screen-256color\"# 启用活动警告setw -g monitor-activity onset -g visual-activity on# 居中窗口列表set -g status-justify centre# 最大化/恢复窗格unbind Up bind Up new-window -d -n tmp \\; swap-pane -s tmp.1 \\; select-window -t tmpunbind Downbind Down last-window \\; swap-pane -s tmp.1 \\; kill-window -t tmp 参考配置文件注意：具体配置方法在配置文件的备注里，我就不赘述了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 来源：Github# 作者：ryerh# 地址：https:&#x2F;&#x2F;gist.github.com&#x2F;ryerh&#x2F;14b7c24dfd623ef8edc7# -----------------------------------------------------------------------------# Tmux 基本配置 - 要求 Tmux &gt;&#x3D; 2.3# 如果不想使用插件，只需要将此节的内容写入 ~&#x2F;.tmux.conf 即可# -----------------------------------------------------------------------------# C-b 和 VIM 冲突，修改 Prefix 组合键为 Control-Z，按键距离近set -g prefix C-zset -g base-index 1 # 窗口编号从 1 开始计数set -g display-panes-time 10000 # PREFIX-Q 显示编号的驻留时长，单位 msset -g mouse on # 开启鼠标set -g pane-base-index 1 # 窗格编号从 1 开始计数set -g renumber-windows on # 关掉某个窗口后，编号重排setw -g allow-rename off # 禁止活动进程修改窗口名setw -g automatic-rename off # 禁止自动命名新窗口setw -g mode-keys vi # 进入复制模式的时候使用 vi 键位（默认是 EMACS）# -----------------------------------------------------------------------------# 使用插件 - via tpm# 1. 执行 git clone https:&#x2F;&#x2F;github.com&#x2F;tmux-plugins&#x2F;tpm ~&#x2F;.tmux&#x2F;plugins&#x2F;tpm# 2. 执行 bash ~&#x2F;.tmux&#x2F;plugins&#x2F;tpm&#x2F;bin&#x2F;install_plugins# -----------------------------------------------------------------------------setenv -g TMUX_PLUGIN_MANAGER_PATH &#39;~&#x2F;.tmux&#x2F;plugins&#39;# 推荐的插件（请去每个插件的仓库下读一读使用教程）set -g @plugin &#39;seebi&#x2F;tmux-colors-solarized&#39;set -g @plugin &#39;tmux-plugins&#x2F;tmux-pain-control&#39;set -g @plugin &#39;tmux-plugins&#x2F;tmux-prefix-highlight&#39;set -g @plugin &#39;tmux-plugins&#x2F;tmux-resurrect&#39;set -g @plugin &#39;tmux-plugins&#x2F;tmux-sensible&#39;set -g @plugin &#39;tmux-plugins&#x2F;tmux-yank&#39;set -g @plugin &#39;tmux-plugins&#x2F;tpm&#39;# tmux-resurrectset -g @resurrect-dir &#39;~&#x2F;.tmux&#x2F;resurrect&#39;# tmux-prefix-highlightset -g status-right &#39;#&#123;prefix_highlight&#125; #H | %a %Y-%m-%d %H:%M&#39;set -g @prefix_highlight_show_copy_mode &#39;on&#39;set -g @prefix_highlight_copy_mode_attr &#39;fg&#x3D;white,bg&#x3D;blue&#39;# 初始化 TPM 插件管理器 (放在配置文件的最后)run &#39;~&#x2F;.tmux&#x2F;plugins&#x2F;tpm&#x2F;tpm&#39;# -----------------------------------------------------------------------------# 结束# ----------------------------------------------------------------------------- 有关 Vim 快捷键由于我对 Vim 的操作方式还不是很熟悉所以暂时不整理这部分内容了，等我什么时候用到了再来更新。 参考猫哥_kaiye：十分钟学会 tmuxryerh: Tmux 快捷键 &amp; 速查表Hattle Land：优雅地使用命令行：Tmux 终端复用","tags":[{"name":"tmux","slug":"tmux","permalink":"https://wiki.blanc.site/tags/tmux/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"tmux","slug":"2-软件使用/命令行工具/tmux","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/tmux/"}]},{"title":"webpack 4 入门","date":"2019-03-05T00:00:00.000Z","path":"archives/72d385fc.html","text":"导读写这篇文章是为了让自己在自学 webpack 的过程中有所产出，于是边读 webpack 中文文档 边写下了这篇文章，里面的很多实例都是直接挪用的文档中的实例，但在一些概念的理解上我加入了自己的想法「未必精确」，所以读的时候要抱着「怀疑的态度」。 文章内容不仅仅是简单的「概念堆叠」，还有一些「重点」概念的「深入理解」，不过篇幅有限我不希望这篇文章变成一份冗长的伪文档，所以全部的内容都是围绕 webpack 的 4个 核心概念延展开来的，每个配置后面我都会尽量跟上一个实例以更加形象的展示配置的具体作用。 站在我的角度上，读完这篇文章并不能让你精通 webpack 但是理解 webpack 中的重要概念，自己编写一个 webpack.config.js 配置文件还是可以的。 webpack 简介 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(static module bundler)。在 webpack 处理应用程序时，它会在内部创建一个依赖图(dependency graph)，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 来自 webpack 中文文档 目前都是使用一些成熟的 CLI 工具，一般都内置 webpack 所以我对 webpack 的认知一直比较少，只是大概的了解它是用来管理项目中的 .js 文件依赖，然后打包整个项目的。 核心概念1. 入口(entry)对应属性：entry默认值：./src/index.js 作用说明：用来规定 webpack 应该使用哪个模块作为构建内部依赖图的起点。webpack 会找出所有「入口模块」（直接或间接）依赖的「模块」和 [library]。 代码示例： 1234// weboack.config.jsmodule.exports = &#123; entry: './path/to/entry/file.js'&#125; 2. 出口(output)对应属性：output主输出文件默路径：./dist/main.js其他文件默认路径：./dist/&lt;filename&gt; 作用说明：用来规定 webpack 在那里输出 bundles 以及如何命名这些文件。 1234567891011// weboack.config.jsconst path = require('path') // Node.js 核心模块，用于操作文件路径代码示例：module.exports = &#123; entry: './path/to/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '&lt;WhateverYouLike&gt;.js' &#125;&#125; 3. 处理器(loader)对应属性：module-&gt;rules 作用说明：作为开箱即用的自带特性，webpack 自身只支持处理 JavaScript 文件。而 loader 能够让 webpack 处理那些非 JavaScript 文件，并且先将它们转换为有效「模块」，然后添加到「依赖图」中，提供给应用程序使用。 属性特征： test: 利用「正则表达式」规定 loader 用于哪些或哪个文件。 use: 规定运行时使用哪个 loader。 代码示例： 1234567891011121314// webpack.config.jsconst path = require('path')module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125; 代码作用：当运行包含 .txt 文件的 require() 或 import 语句时，在它打包之前，先使用 raw-loader 转换。 4. 插件(plugins)对应属性：plugings 作用说明：打包优化、资源管理和注入环境变量。 代码实例： 12345678910// webpack.config.jsconst HtmlWebpackPlugn = require('html-webpack-plugin') // 提前通过 npm 安装const webpack = require('webpack') //用于访问内置插件module.exports = &#123; ... plugins: [ new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125; 核心概念解析及拓展1. 入口(entry)单入口及其简写12345678910111213141516// webpack.config.jsmodule.exports = &#123; entry: &#123; main: './path/to/entry/file.js' &#125;&#125;// 可简写为如下形式module.exports = &#123; enrty: './path/to/enrty/file.js'&#125;/* * 当你需要为只有一个入口的应用程序或工具（library）快速设置 webpack 配置时， * 简写会是个很不错的选择。然而，使用此语法在扩展配置时有失灵活性。 */ 思考：当你向 entry 传入一个数组时会发生什么？解释：向 entry 传入「文件路径数组」将创建「多个主入口」。在你想要多个依赖文件一起注入，并且将它们的依赖导向到一个 chunk 时，传入数组的方式就很有用。 对象语法用法：entry: {&lt;enrtyChunkName: String&gt;: &lt;Path: String | Array&gt;} 123456789// webpack.config.jsmodule.exports = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;// 对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。 常见场景1. 分离应用程序主体和第三方库1234567891011121314151617// webpack.config.jsmodule.exports = &#123; entry: &#123; app: './src/app.js' vendors: './src/vendors.js' &#125;&#125;/* * webpack 从 app.js 和 vendors.js 开始创建依赖图。 * 这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导）。 * 这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序中。 * * 此设置允许你使用 CommonsChunkPlugin 从应用程序依赖图中提取 vendor 到 vendor 依赖图，并把引用 vendor 的部分替换为 __webpack_require__() 调用。 * 如果应用程序依赖图中没有 vendor 代码，那么你可以在 webpack 中实现被称为长效缓存的通用模式。 * 说实话，目前看不懂上面这段话，所以也不晓得怎么通俗的表述。 */ 2. 多页面应用程序1234567891011121314151617// webpack.config.jsmodule.exports = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;/* * webpack 分离 3 个的依赖图 * * 在多页应用中，每当页面跳转时服务器将为你获取一个新的 HTML 文档。 * 页面重新加载新文档，并且资源被重新下载。这给了我们特殊的机会去做很多事： * 使用 CommonsChunkPlugin 使所有页面的应用程序共享代码创建依赖图， * 入口增多，多页应用能够复用不同入口的大量重复代码/模块。 */ 2. 出口(output)注意，即使可以存在多个入口，但只配置一个出口设置。 用法在 webpack 中配置 output 的最低要求是，将它的值是一个包括以下两点的对象： filename: 输出文件的文件名。 path: 输出目录的绝对路径。 123456789// webpack.config.jsmodule.exports = &#123; output: &#123; filename: '&lt;WhateverYouLike&gt;.js', path: '/path/to/project' &#125;&#125;// 此配置将一个单独的 .js 文件输出到 /path/to/project 目录中。 配合多个入口设置如果配置创建了多个单独的入口，则应该使用 占位符 来确保每个文件具有唯一的名称。 12345678910111213// webpack.config.jsmodule.exports = &#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;;// 写入到硬盘：./dist/app.js, ./dist/search.js 常用占位符内部ID：[id]入口名称：[name]基于构建的hash（每次构建都会改变）：[hash]基于内容的hash（文件内容改变才会改变）：[chunkhash] 高级进阶官网所谓高级进阶其实就是利用哈希占位符构建随版本迭代的文件命名方式这里不展示了。 比较有用的是如何动态设置 publicPath: 首先，何为 publicPath，以及周边概念 output.publicPath: 所有资源的基础路径，它被称为公共路径，以 / 结束，示例： 1234567891011121314// webpack.config.jsmodule.exports = &#123; ... output: &#123; publicPath: '/assets/', chunkFilename: '[id].chunk.js' &#125;&#125;;/* * HTML loader 输入出：&lt;link href=\"/assets/spinner.gif\" /&gt; * CSS：background-image: url(/assets/spinner.gif); * 静态资源最终访问路径 = output.publicPath + loader 或插件等配置路径 */ devServer.publicPath: 确定从哪里提供 bundle 假设服务器运行在 http://localhost:8080 并且 output.filename 被设置为 bundle.js。默认 publicPath 是 /，所以你的包可以通过 http://localhost:8080/bundle.js 访问。 可以修改通过 devServer.publicPath 来修改请求资源时的服务器前缀，示例： 1234567891011121314// webpack.config.jsmodule.exports = &#123; ... devServer: &#123; publicPath: '/assets/' &#125;&#125;;/* * 现在可以通过 http://localhost:8080/assets/bundle.js 访问 bundle。 * 确保 publicPath 总是以斜杠(/)开头和结尾。 * devServer.publicPath 也可以是一个完整的 URL。 * 一般情况下都要保证 devServer.publicPath 与 output.publicPath 保持一致。 */ devServer.contentBase: 告诉服务器从哪里提供内容，只有在提供静态文件时才需要 默认情况下，将使用当前工作目录作为提供内容的目录，但是你可以修改为其他目录，示例： 123456789101112131415161718// webpack.config.jsmodule.exports = &#123; ... devServer: &#123; // 推荐使用绝对路径。 contentBase: path.join(__dirname, 'public') &#125;&#125;;// 也可以从多个目录提供内容module.exports = &#123; ... devServer: &#123; contentBase: [path.join(__dirname, 'public'), path.join(__dirname, 'assets')] &#125;&#125;;// 具体作用不详，官网并没有给出说明也懒得查了 其次，如何动态设置 publicPath12345678910111213// webpack.config.js...const BASE_URL = process.env.NODE_ENV === 'production' ? '/' : '/'module.exports = &#123; ... publicPath: BASE_URL, ...&#125;// 方法来自 iview-admin vue.config.js// 我不知道我理解的动态设置对不对，不过官网给的 __webpack_public_path__ 我没看明白 3. 处理器(loader)loader 用于对模块的源代码进行转换，可以使你在「载入」模块时预处理文件。 loader 类似于其他构建工具中「任务(task)」，提供了处理前端构建步骤的方法。 loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。允许你直接在 JavaScript 模块中 import CSS 文件。 示例配置 loader 使 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。 首先安装相对应的 loader： 12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后配置 webpack 对每个 .css 使用 css-loader，所有 .ts 文件使用 ts-loader： 12345678910// webpack.config.jsmodule.exports = &#123; ... module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125; 使用 loader 的三种方式 配置：在 webpack.config.js 文件中指定 loader。（推荐） 前面展示过了，这里就不重复了。 内联：在每个 import 语句中显式指定 loader。 可以在 import 语句或任何等效于 import 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析，示例： 1import Styles from 'style-loader!css-loader?modules!./styles.css'; CLI：利用 shell 命令指定 loader。 1webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' loader 特性 loader 支持链式传递。loader 链中每个 loader，都对前一个 loader 处理后的资源进行转换。loader 链会按照相反的顺序执行。第一个 loader 将（应用转换后的资源作为）返回结果传递给下一个 loader，依次这样执行下去。最终，在链中最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数，用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 解析 loaderloader 遵循标准的 模块解析。多数情况下，loader 将从模块路径（通常将模块路径认为是 node_modules）解析。 loader 模块需要导出为一个函数，并且使用 Node.js 兼容的 JavaScript 编写。通常使用 npm 进行管理，但是也可以将自定义 loader 作为应用程序中的文件。按照约定，loader 通常被命名为 xxx-loader（例如 json-loader）。有关详细信息，请查看 如何编写 loader？。 4. 插件(plugins)插件是 webpack 的支柱功能。webpack 自身也构建于插件系统之上。 插件目的在于解决 loader 无法实现的其他事。 剖析webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。 12345678910111213// ConsoleLogOnBuildWebpackPlugin.jsconst pluginName = 'ConsoleLogOnBuildWebpackPlugin';class ConsoleLogOnBuildWebpackPlugin &#123; apply(compiler) &#123; // compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。 // 建议为此使用一个常量，以便它可以在所有 hook 中复用。 compiler.hooks.run.tap(pluginName, compilation =&gt; &#123; console.log('webpack 构建过程开始！'); &#125;); &#125;&#125;// 插件编写属于比较深入的内容，这里不过多探讨，目前仅需要知道实现原理即可 用法由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 配置写法1234567891011121314151617181920212223// webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin') //通过 npm 安装const webpack = require('webpack') //访问内置的插件const path = require('path')module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, use: 'babel-loader' &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125; 了解更多1. 模式(mode)对应属性：mode | String 作用说明：通过将 mode 参数设置为 development, production 或 none，可以启用对应环境下 webpack 内置的优化。默认值为 production。 用法 在配置文件中设置 12345// webpack.config.jsmodule.exports = &#123; ... mode: 'production'&#125;; 通过 CLI 参数设置 1webpack --mode=production 支持模式 选项 描述 development 会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin. None 不选用任何默认优化选项 根据 mode 改变编译行为123456789101112131415161718// webpack.config.jsvar config = &#123; entry: './app.js' ...&#125;module.exports = (env, argv) =&gt; &#123; if (argv.mode === 'development') &#123; config.devtool = 'source-map'; &#125; if (argv.mode === 'production') &#123; ... &#125; return config&#125; 2. 模块(modules)在模块化编程中，开发者将程序分解成离散功能块，并称之为「模块」。 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的「模块」提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。 webpack 将「模块」的概念应用于项目中的任何文件。 什么是 webpack 模块对比 Node.js 模块，webpack 「模块」能够以各种方式表达它们的依赖关系，几个例子如下： 样式：(url(...))ES2015: importCommonJS: require()HTML: &lt;img src=...&gt;AMD: define | requirecss/sass/less: @import 支持的模块类型webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理「非 JavaScript(non-JavaScript) 模块」，并且在 bundle 中引入这些「依赖」。 目前 webpack 已经但不限于支持以下语言的 loader: CoffeeScript TypeScript ESNext (Babel) Sass Less Stylus 3. 模块解析(module resolution)resolver 是一个库，用于帮助找到模块的绝对路径。 它帮助 webpack 从每个如 require/import 语句中，找到需要引入到 bundle 中的模块代码。 当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径。 webpack 中的解析规则使用 enhanced-resolve，webpack 能够解析三种文件路径： 1. 绝对路径123// 已经取得文件的绝对路径，因此不需要进一步再做解析。import '/home/me/file';import 'C:\\\\Users\\\\me\\\\file'; 2. 相对路径1234// 在这种情况下，使用 import 或 require 的资源文件所在的目录，被认为是上下文目录。// 在 import/require 中给定的相对路径，会拼接此上下文路径，以产生模块的绝对路径。import '../src/file1';import './file2'; 3. 模块路径123import 'module';import 'module/lib/file';// 解释很啰嗦，感兴趣可以自己去看一下文档 缓存每次文件系统访问都会被缓存，以便更快触发对同一文件的多个并行或串行请求。在 观察模式下，只有修改过的文件会从缓存中摘出。如果关闭观察模式，会在每次编译前清理缓存。 4. 依赖图(dependency graph)任何时候，一个文件依赖于另一个文件，webpack 就把此视为文件之间有「依赖关系」。这使得 webpack 可以接收非代码资源（例如 images 或 web fonts），并且可以把它们作为「依赖」提供给你的应用程序。 webpack 从命令行或配置文件中定义的「入口」开始，递归地构建一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量可由浏览器加载的 bundle（通常只有一个）。 5. 浏览器兼容性webpack 支持所有 ES5 兼容（IE8 及以下不提供支持）的浏览器。webpack 的 import() 和 require.ensure() 需要环境中有 Promise。如果你想要支持旧版本浏览器，你应该在使用这些 webpack 提供的表达式之前，先 加载一个 polyfill。 总结通过整理这篇文档我已经对 webpack 有了一个初步的认识和了解了。 当然如果你要真正的在项目中投入使用 webpack 仅仅阅读这一篇文章是不够的，你还需要去深入地阅读了解文档里的各种配置参数和其他常用的前端构建工具或预处理器配合 webpack 进行调试使用。 前路漫漫，与君共勉。 参考 webpack 中文文档 掘金：Webpack中publicPath详解-Mello_Z segmentfault：webpack output.publicPath 如何动态配置地址 GitHub: iview-admin 源码","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wiki.blanc.site/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"webpack","slug":"webpack","permalink":"https://wiki.blanc.site/tags/webpack/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"macOS 下利用 pyenv 管理 Python 版本和虚拟环境","date":"2019-02-22T00:00:00.000Z","path":"archives/6005f6af.html","text":"pyenv 介绍pyenv 是 Python 版本管理工具。pyenv 可以改变全局的 Python 版本，安装多个版本的 Python，设置目录级别的 Python 版本，还能创建和管理 virtual python environments。所有的设置都是用户级别的操作，不需要 sudo 命令。 pyenv 主要用来管理 Python 的版本，比如一个项目需要 Python 2.x，一个项目需要 Python 3.x。 而 virtualenv 主要用来管理 Python 包的依赖，不同项目需要依赖的包版本不同，则需要使用虚拟环境。 pyenv 原理简介pyenv 通过系统修改环境变量来实现 Python 不同版本的切换。而 virtualenv 通过将 Python 包安装到一个目录来作为 Python 包虚拟环境，通过切换目录来实现不同包环境间的切换。 pyenv 的美好之处在于，它并没有使用将不同的 PATH 植入不同的 shell 这种高耦合的工作方式，而是简单地在 PATH 的最前面插入了一个垫片路径（shims）：~/.pyenv/shims:/usr/local/bin:/usr/bin:/bin。所有对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而使后方的系统路径失效。 安装之前不同系统请参考 Common build problems，安装必须的工具。 pyenv 安装根据官网的 安装说明 或者 自动安装。 如果使用 macOS 直接使用 Homebrew。安装成功后记得在 .bashrc 或者 .bash_profile 中添加三行来开启自动补全。 1234# 根据自己的环境配置export PATH=\"$HOME/.pyenv/bin:$PATH\"eval \"$(pyenv init -)\"eval \"$(pyenv virtualenv-init -)\" 自动安装pyenv 提供了自动安装的工具，执行命令安装即可： 1curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 保证系统有 git，否则需要新安装 git。 手动安装如果想要更加详细的了解安装过程，可以使用手动安装。将 pyenv 检出到你想安装的目录。建议路径为：$HOME/.pyenv 123456cd ~git clone git://github.com/yyuu/pyenv.git .pyenvecho 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.bashrcecho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.bashrcecho 'eval \"$(pyenv init -)\"' &gt;&gt; ~/.bashrcsource ~/.bashrc 添加环境变量 PYENV_ROOT 指向 pyenv 检出的根目录，并向 $PATH 添加 $PYENV_ROOT/bin 以提供访问 pyenv 命令的路径。 这里的 shell 配置文件（~/.bash_profile）依不同 Linux 而需作修改，如果使用 zsh 则需要相应的配置 ~/.zshrc 在使用 pyenv 之后使用 pip 安装的第三方模块会自动安装到当前使用 Python 版本下，不会和系统模块产生冲突。使用 pip 安装模块之后，如果没有生效，记得使用 pyenv rehash 来更新垫片路径。 pyenv 常用命令使用 pyenv commands 显示所有可用命令 Python 配置1234567891011121314151617181920# 查看系统当前安装的python列表pyenv versions# 列出可安装版本pyenv install --list # 安装指定版本 Pythonpyenv install -v 3.5.1# 卸载指定版本 Pythonpyenv uninstall 2.7.3# 显示当前python安装路径pyenv which python # 创建垫片路径# 为所有已安装的可执行文件创建 shims# 如：~/.pyenv/versions/*/bin/*# 每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令pyenv rehash Python 切换123456789101112# 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式pyenv global &lt;版本号&gt;# 设置面向程序的本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。# pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。pyenv local &lt;版本号&gt;# 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。这个版本的优先级比 local 和 global 都要高。pyenv shell &lt;版本号&gt;# --unset 参数可以用于取消当前 shell 设定的版本。pyenv shell --unset Python 优先级shell &gt; local &gt; global pyenv-virtualenvpyenv-virtualenv 是 pyenv 下基于 virtualenv 的一款插件，通过 pyenv-virtualenv 插件可以很好的和 virtualenv 结合。 安装使用自动安装 pyenv 后，它会自动安装部分插件，其中包括了 pyenv-virtualenv。 若使用 Homebrew 进行安装，则可使用命令 brew install pyenv-virtualenv 安装 pyenv-virtualenv 插件。 这样安装之后需要执行如下配置： 12345678910111213141516# 使用 zsh shellvim ~/.zshrc# 使用系统默认vim ~/.bash_profile# 在 .zshrc 或 .bash_profile 文件最后写入：# pyenv-virtualenvif which pyenv-virtualenv-init &gt; /dev/null; then eval \"$(pyenv virtualenv-init -)\";fi# 使配置生效source ~/.zshrc# orsource ~/.bash_profile 使用123456789101112131415# 创建虚拟环境# 若不指定 Python 版本，默认使用当前环境 Python 版本pyenv virtualenv &lt;Python 版本号&gt; &lt;虚拟环境名称&gt;# 列出当前虚拟环境pyenv virtualenvs# 激活虚拟环境pyenv activate &lt;虚拟环境名称&gt;# 退出虚拟环境pyenv deactivate# 删除虚拟环境pyenv uninstall &lt;虚拟环境名称&gt; Tips：更换 pip 源因为国内网络环境，如果在局域网内 pip 下载慢，可以尝试使用阿里云提供的镜像，创建 vim ~/.pip/pip.conf，然后填入： 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 更多 pip 国内源： 豆瓣：http://pypi.douban.com阿里云：http://mirrors.aliyun.com/pypi/simple清华大学：https://pypi.tuna.tsinghua.edu.cn/simple 参考 pyenv GitHub 使用 pyenv 管理 Python 版本 使用 pyenv + virtualenv 打造多版本 Python 开发环境 Mac 下 pyenv 与 pyenv-virtualenv 的安装和使用","tags":[{"name":"pyenv","slug":"pyenv","permalink":"https://wiki.blanc.site/tags/pyenv/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"pyenv","slug":"2-软件使用/命令行工具/pyenv","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/pyenv/"}]},{"title":"Python 虚拟环境：virtualenv 以及 virtualenvwrapper","date":"2019-02-18T00:00:00.000Z","path":"archives/ab4a885.html","text":"在使用 Python 开发的过程中，工程一多，难免会碰到不同的工程依赖不同版本的库的问题；亦或者是在开发过程中不想让物理环境里充斥各种各样的库，引发未来的依赖灾难。此时，我们需要对于不同的工程使用不同的虚拟环境来保持开发环境以及宿主环境的清洁。 1. virtualenvvirtualenv 可以在系统中建立多个不同并且相互不干扰的虚拟环境。 1.1 原理简介把系统 Python 「复制」一份到 virtualenv 的环境，用命令 source venv/bin/activate 进入一个 virtualenv 环境时，virtualenv 会修改相关环境变量，让命令 python 和 pip 均指向当前的 virtualenv 环境。 PS：想了解更多可以查看 activate 脚本文件源码。 1.2 安装1pip install virtualenv 1.3 使用1.3.1 需求：我们有一个 hello_world 项目需要编写，但希望重新开辟一个 Python 包管理环境。 1.3.2 假设：项目地址：/path/to/project/hello_world 1.3.3 创建虚拟环境：1virtualenv &#x2F;path&#x2F;to&#x2F;project&#x2F;hello_world 此时可以看到，在这个目录下面会有三个目录被建立: 123lib -&gt; 各种依赖库include -&gt; 虚拟环境中的头文件，包括 Python 的头文件bin -&gt; 虚拟环境中可用的命令包括开启虚拟环境的脚本 activate 1.3.4 进入（激活）虚拟环境1source &#x2F;path&#x2F;to&#x2F;project&#x2F;hello_world&#x2F;bin&#x2F;activate 此时我们就进入到虚拟环境中了，接下来只需要安装项目需要的库即可。 PS：虚拟环境中的库与本机原始环境的库是不会相互干扰的。 1.3.5 退出虚拟环境1deactivate 1.3.6删除虚拟环境如果想要删除虚拟环境，只要把这个目录下的 bin include lib 三个目录删掉就好了。 1.3.7 其他选项1234567891011121314--version 显示当前版本号-h, --help 显示帮助信息-v, --verbose 显示详细信息-q, --quiet 不显示详细信息-p PYTHON_EXE, --python&#x3D;PYTHON_EXE 指定所用的 python 解析器的版本--clear 清空非 root 用户的安装，并重头开始创建隔离环境--no-site-packages 令隔离环境不能访问系统全局的site-packages目录--system-site-packages 令隔离环境可以访问系统全局的site-packages目录--unzip-setuptools 安装时解压 Setuptools 或 Distribute--relocatable 重定位某个已存在的隔离环境,使用该选项将修正脚本并令所有.pth文件使用相当路径--distribute 使用 Distribute 代替 Setuptools，也可设置环境变量 VIRTUALENV_DISTRIBUTE 达到同样效果--extra-search-dir&#x3D;SEARCH_DIRS 用于查找 setuptools&#x2F;distribute&#x2F;pip 发布包的目录。可以添加任意数量的 –extra-search-dir 路径--never-download 禁止从网上下载任何数据。此时，如果在本地搜索发布包失败， virtualenv 就会报错--prompt&#x3D;&#x3D;PROMPT 定义隔离环境的命令行前缀 2. virtualenvwrapper（基于 virtualenv）virtualenv 的扩展工具，提供了一系列命令行命令，可以方便地创建、删除、复制、切换不同的虚拟环境。同时，使用该扩展后，所有虚拟环境都会被放置在同一个目录下。 virtualenv 的一个最大的缺点就是，每次开启虚拟环境之前要去虚拟环境所在目录下的 bin 目录下 source 一下 activate，这就需要我们记住每个虚拟环境所在的目录。 一种可行的解决方案是，将所有的虚拟环境目录全都集中起来，比如放到 ~/virtualenvs/，并对不同的虚拟环境使用不同的目录来管理。virtualenvwrapper 正是这样做的。并且，它还省去了每次开启虚拟环境时候的 source 操作，使得虚拟环境更加好用。 2.1 安装1pip install virtualenvwrapper 2.2 配置各操作系统配置方法不完全相同，请自行百度 Google。 这里只讲解一个下文会提到的配置中的概念：WORKON_HOME。 WORKON_HOME 是 virtualenvwrapper 配置过程中需要指定的一个环境变量，表示将要用来存放各虚拟环境目录的目录。 2.3 使用2.3.1 新建虚拟环境1mkvirtualenv &lt;自定义虚拟环境名称&gt; 这样会在 WORKON_HOME 变量指定的目录下新建名为 &lt;自定义虚拟环境名称&gt; 的虚拟环境。 若想指定 Python 版本，可通过 --python 参数指定想要使用的 Python 解释器。 1mkvirtualenv --python&#x3D;&lt;Python 解释器路径&gt; &lt;自定义虚拟环境名称&gt; 2.3.2 查看存在的虚拟环境目录1workon 2.3.3 进入（切换）虚拟环境1workon &lt;虚拟环境名称&gt; 2.3.4退出虚拟环境1deactivate 2.3.5删除虚拟环境1rmvirtualenv &lt;虚拟环境名称&gt;","tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://wiki.blanc.site/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"Python","slug":"Python","permalink":"https://wiki.blanc.site/tags/Python/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Django 笔记-1-从请求到响应","date":"2019-01-26T00:00:00.000Z","path":"archives/953c2552.html","text":"本文所用 Django 代码版本：2.1.3 本文中进行的分析并不局限于某一个 Django 版本但都会尽量讨论版本 2.0+ 流程总览 概述：Django 和其他 Web 框架的 HTTP 处理的流程大致相同：先通过 Request Middleware 对请求对象做定义处理，然后再通过默认的 URL 指向的方法，最后再通过 Response Middleware 对响应对象做自定义处理。 细则： [启动-&gt;WSGI]通过任意方式启动 Django 创建 WSGIServer 类的实例 用户通过浏览器请求某个 Django 页面 [WSGI]Django WSGIServer 接收客户端（浏览器）请求初始化 WSGIHandler 实例 [WSGI-&gt;加载配置]导入 setting 配置和 Django 异常类 [WSGI-&gt;中间件]加载 setting 中设置的中间件 [中间件]创建 _request_middleware,_view_middleware,_response_middleware,_exception_middleware 四个列表 [中间件]遍历执行 _request_middleware，对 request 进行处理：若返回 None 进入到 8；若直接返回 HttpResponse 对象进入到 12 [URL Resolver]解析 url 并进行匹配（假设匹配成功） [中间件]遍历执行 _view_middleware，对 request 进行处理：若返回 None 进入到 10；若直接返回 HttpResponse 对象进入到 12。 [中间件]实现 url 匹配的 view 逻辑：若引发异常进入到 11;若正常返回 HttpResponse 对象进入到 12 [中间件]遍历执行 _exception_middleware [中间件]遍历执行 _response_middleware，对 HttpResponse 进行处理并最终返回 response 启动在开发环境中，我们一般是通过命令行执行 runserver 命令，ruserver 命令是使用 Django 自带的的 Web Server，而在正式的环境中，一般会使用 Nginx+uWSGI 模式。 无论通过哪种方式，启动一个项目时，都会做两件事： 创建一个 WSGIServer 类的实例，来接受用户的请求。 当一个用户的 HTTP 请求到达的时，为用户指定一个 WSGIHandler，用于处理用户请求与响应，这个 Handler 是处理整个 Request 的核心。 WSGIWSGI：全称 Web Server Gateway Interface。 WSGI 不是服务器，Python 模块，框架，API 或者任何软件，只是一种规范，描述 Web Server 如何与 Web Application 通信的规范。 WSGI 协议主要包括 server 和 application 两部分： WSGI Server 负责从客户端接收请求，将 request 转发给 application，将application 返回的 response 返回给客户端； WSGI Application 接收由 server 转发的 request，处理请求，并将处理结果返回给 server。application 中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现 server 与 application，因此可以在 WSGI 服务器与 WSGI 应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。 Django WSGI ApplicationWSGI Application 应该实现为一个可调用对象，例如：函数、方法、类（包含 call 方法）。 需要接收两个参数： 包含客户端请求的信息以及其他信息的字典。可以认为是请求上下文，一般叫做environment（编码中多简写为 environ、env）； 用于发送 HTTP 响应状态（HTTP Status）、响应头（HTTP Headers）的回调函数； 通过回调函数将响应状态和响应头返回给 WSGI Server，同时返回响应正文，响应正文是可迭代的、并包含了多个字符串。下面是 Django WSGI Application 的具体实现： 1234567891011121314151617181920212223242526class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # 本文作者注：加载中间件 self.load_middleware() def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) # 本文作者注：处理请求前发送信号 signals.request_started.send(sender=self.__class__, environ=environ) request = self.request_class(environ) response = self.get_response(request) response._handler_class = self.__class__ status = '%d %s' % (response.status_code, response.reason_phrase) response_headers = list(response.items()) for c in response.cookies.values(): response_headers.append(('Set-Cookie', c.output(header=''))) # 本文作者注：将响应的 header 和 status 返回给 server start_response(status, response_headers) if getattr(response, 'file_to_stream', None) is not None and environ.get('wsgi.file_wrapper'): response = environ['wsgi.file_wrapper'](response.file_to_stream) return response 可以看出 Django WSGI Application 的流程包括: 加载所有中间件，以及执行框架相关的操作，设置当前线程脚本前缀，发送请求开始信号； 处理请求，调用 get_response() 方法处理当前请求，该方法的的主要逻辑是通过urlconf 找到对应的 view 和 callback，按顺序执行各种 middleware 和 callback； 调用由 WSGI Server 传入的 start_response() 方法将响应 header 与 status 返回给 WSGI Server； 返回响应正文。 Django WSGI Server负责获取 HTTP 请求，将请求传递给 Django WSGI Application，由 Django WSGI Application 处理请求后返回 response。以 Django 内建 server 为例看一下具体实现。 通过 runserver 命令运行 Django 项目，在启动时都会调用下面的 run 方法，创建一个 WSGIServer 的实例，之后再调用其 serve_forever() 方法启动服务。 1234567891011def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer): server_address = (addr, port) if threading: httpd_cls = type('WSGIServer', (socketserver.ThreadingMixIn, server_cls), &#123;&#125;) else: httpd_cls = server_cls httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6) if threading: httpd.daemon_threads = True httpd.set_app(wsgi_handler) httpd.serve_forever() 下图表示 WSGI Server 服务器处理流程中关键的类和方法（来自：参考引用_1） 1. WSGIServerrun() 方法会创建 WSGIServer 实例，主要作用是接收客户端请求，将请求传递给WSGI Application，然后将 WSGI Application 返回的 response 返回给客户端。 创建实例时会指定 HTTP 请求的 handler ：WSGIRequestHandler 类; 通过 set_app 和 get_app 方法设置和获取 WSGIApplication 实例wsgi_handler; 处理 HTTP 请求时，调用 handler_request 方法，会创建 WSGIRequestHandler 实例处理 HTTP 请求; WSGIServer 中 get_request 方法通过 socket 接受请求数据; 2. WSGIRequestHandler 由 WSGIServer 在调用 handle_request 时创建实例，传入 request,cient_address,WSGIServer 三个参数，__init__ 方法在实例化同时还会调用自身的 handle 方法； handle 方法会创建 ServerHandler 实例，然后调用其 run 方法处理请求； 3. ServerHandler WSGIRequestHandler 在其 handle 方法中调用 run 方法，传入self.server.get_app() 参数，获取 WSGIApplication，然后调用实例(call)，获取 response，其中会传入 start_response 回调，用来处理返回的 header 和 status； 通过 application 获取 response 以后，通过 finish_response 返回 response； 4. WSGIHandler（即 Django WSGI Application） WSGI 协议中的 application，接收两个参数，environ 字典包含了客户端请求的信息以及其他信息，可以认为是请求上下文，start_response 用于发送返回 status 和 header 的回调函数 虽然上面一个 Django WSGI Server 涉及到多个类实现以及相互引用，但其实原理还是调用WSGIHandler，传入请求参数以及回调方法 start_response()，并将响应返回给客户端。 Python wsgiref simple_server在 Python3.7 的源码中给出了一个 simple_server 案例位于 python3.7/wsgiref/simple_server.py。 模块实现了一个简单的 HTTP 服务器，并给出了一个简单的 demo，可以直接运行，运行结果会将请求中涉及到的环境变量在浏览器中展示出来。其中包括上述描述的整个 HTTP 请求的所有组件：ServerHandler,WSGIServer,WSGIRequestHandler 以及 demo_app 表示的简易版的 WSGIApplication。 感兴趣的话可以自己去看一下源码。 加载配置Django 的配置都在 {project_name}/settings.py 中定义，可以是 Django 的配置，也可以是自定义的配置，并且都通过 django.conf.settings 访问。 中间件-Middleware概述：Django 中的 Middleware 类似底层中一个轻量级的插件系统，它能够介入 Django 的请求和响应过程，在全局修改 Django 的输入和输出内容。从流程总览图中可以看出 Django 请求处理过程的核心在于 Middleware，Django 中所有的请求和响应都有 Middleware 的参与。 细则： 一个 HTTP 请求，首先被转化成一个 HttpRequest 对象，然后该对象被传递给 Request Middleware 处理，如果它返回了 HttpResponse 对象，则直接传递给 Response Middleware 做收尾处理。否则的话 Request Middleware 将访问 URL 配置，确定目标 view 来处理 HttpRequest 对象，在确定了 view，但是还没有执行时候，系统会把 HttpRequest 对象传递给 View Middleware 进行处理，如果它返回了 HttpResponse 对象，那么该 HttpResponse 对象将被传递给 Response Middleware 进行后续处理，否则将执行确定的 view 函数处理并返回 HttpResponse 对象，在整个过程中如果引发了异常并抛出，会被 Exception Middleware 进行处理。 中间件执行顺序 在请求阶段，调用视图之前，Django 按照 setting.py 设置的顺序，自顶向下应用遍历执行 Request Middleware。你可以把它想象成一个洋葱：每个中间件类都是一个“层”，它覆盖了洋葱的核心。如果请求通过洋葱的所有层（每一个调用 get_response）以将请求传递到下一层，一直到内核的视图，那么响应将在返回的过程中通过每个层（以相反的顺序）。 如何编写自己的中间件即中间件的深入了解编写一个自己的中间件是很容易的，每个中间件组件都是一个独立的 Python Class，你可以在自定义的 Class 下编写一个或多个下面的方法： process_request函数样式：process_request(request)； 参数解析：request 是一个 HTTPRequest 对象； 调用时间：在 Django 决定执行哪个 view 之前，process_request() 会被请求调用； 产生响应：它应该返回一个 None 或一个 HttpResponse 对象，如果返回 None，Django 会继续处理这个请求；如果它返回一个 HTTPResponse 对象，Django 会直接跳转到 Response Middleware； process_view函数样式：process_view(request, view_func, view_args, view_kwargs)； 参数解析：request 是一个 HTTPRequest 对象，view_func 是 Django 会调用的一个函数（准确的说是一个函数对象而非一个表示函数名的字符串），view_args 是一个会被传递到视图的 *args，view_kwargs 是一个会被传递到视图的 **kwargs，view_args 和 view_kwargs 都不包括 request； 调用时间：process_view() 会在 Django 调用 view 前被调用； 产生响应：它应该返回一个 None 或一个 HttpResponse 对象，如果返回 None，Django 会继续处理这个请求；如果它返回一个 HTTPResponse 对象，Django 会直接跳转到 Response Middleware； PS：除 CsrfViewMiddleware 外中间件运行时在视图运行前或在 process_view() 中访问 request.POST 会使得之后的所有视图无法修改 request，所以应该尽量避免。 process_template_response函数样式：process_template_response(request, response)； 参数解析：request 是一个 HttpRequest 对象，response 是一个 TemplateResponse 对象（或类似对象），由 Django 视图或中间件返回； 调用时间：如果 response 的实例有 render() 方法，process_template_response() 在视图刚好执行完毕之后被调用，这表明他是一个 TemplateResponse 对象（或类似对象）； 产生响应：这个方法必须返回一个实现了 render() 方法的 TemplateResponse 对象（或类似对象），它可以修改给定的 response 对象，也可以创建一个全新的 TemplateResponse 对象（或类似对象）； PS：在响应处理阶段，中间件以相反的顺序运行，包括 process_template_response； process_response函数样式：process_response(request, response)； 参数解析：request 是一个 HttpRequest 对象，response 是一个 HttpResponse 对象，由 Django 视图或中间件返回； 调用时间：process_request 在所有响应返回客户端前被调用; 产生响应：这个方法必须返回一个 HttpRequest 对象，它可以修改给定的 response 对象，也可以创建一个全新的 HttpRequest 对象； PS：process_response 总是被调用，这意味着你的 process_response 不能依赖 process_request process_exception函数样式：process_exception(request, exception)； 参数解析：request 是一个 HttpRequest 对象，exception 是一个被视图抛出 Exception 对象； 调用时间：当一个视图抛出异常，Django 会调用 process_exception 来处理; 产生响应：它应该返回一个 None 或一个 HttpResponse 对象，如果返回 None，Django 会继续处理这个请求；如果它返回一个 HTTPResponse 对象，模板对象和 Response Middleware 会被直接返回给客户端；否则，将启动默认异常处理。； URL Resolver概述：假设：中间件便利执行完 _request_middleware,_view_middleware 后都返回 None。 当 Django 遍历执行完 _request_middleware 后会得到一个经过处理的 request 对象，此时 Django 将按顺序进行对 url 进行正则匹配，如果匹配不成功，就会抛出异常；如果匹配成功，Django 会继续循环执行 _view_middleware 并在执行后继续执行刚刚匹配成功的 view。 在 setting 中有一个 ROOT_URLCONF，它指向 urls.py 文件，根据这个文件可以生产一个 urlconf，本质上，他就是 url 与视图函数之间的映射表，然后通过 resolver 解析用户的 url，找到第一个匹配的 view。 细则： 重要函数源码位置： 1234_path: django&#x2F;urls&#x2F;conf.pyURLPattern: django&#x2F;urls&#x2F;resolvers.pyResolverMatch: django&#x2F;urls&#x2F;resolvers.pyURLResolver: django&#x2F;urls&#x2F;resolvers.py 源码比较长，就不放出来了，感兴趣的话自己去看吧。 通过 urlpatterns 的配置执行 _path 函数； _path 函数进行判断：如果是一个 list 或者 tuple，就用 URLResolver 处理，跳至 4；如果是一个正常的可调用的 view 函数，则用 URLPattern 处理，跳至；如果匹配失败，抛出异常； URLPattern 初始化相应值后执行 resolve 方法：如果匹配成功，返回 ResolverMatch；如果匹配失败，抛出异常； URLResolver 匹配 path 如果匹配成功，则继续匹配它的 url_patterns，跳至 5；匹配失败，抛出异常； 匹配 url_patterns：若为 urlpattern 匹配成功，返回 ResolverMatch；若为 URLResolver 递归调用 URLResolver 跳至 4；若匹配失败，抛出异常； 可以发现，整个过程的关键就是 ResolverMatch，URLPattern 和 URLResolver 三个类，其中：ResolverMatch 是匹配结果，包含匹配成功后需要的信息；URLPattern 是一个 url 映射信息的对象，包含了 url 映射对应的可调用对象等信息；URLResolver 是实现 url 路由，解析 url 的关键的地方，它的 url_patterns既可以是URLPattern 也可以是 URLResolver，正是因为这种设计, 实现了对 url 的层级解析。 总述真实的请求响应过程肯定是比我提到的这些还要复杂的多，但是我的能力实在有限，目前仅能理解到这个层面了，如果错误欢迎指正。 参考引用： 简书：做Python Web开发你要理解：WSGI &amp; uWSGI 作者：rainybowe 掘金：Django从请求到响应的过程 作者：__奇犽犽 现代魔法学院：Python 与 Django 篇-Django 架构流程分析 简书：django源码分析之url路由(URLResolver) 作者：2hanson Django 官方文档","tags":[{"name":"Django","slug":"Django","permalink":"https://wiki.blanc.site/tags/Django/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://wiki.blanc.site/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Django","slug":"2-软件使用/Django","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Django/"}]},{"title":"RESTful 笔记-1-接口设计规范","date":"2019-01-25T00:00:00.000Z","path":"archives/7e15b804.html","text":"本文所有内容皆为个人根据网上文章整理思考所得并非权威指南，仅供参考。 1. 核心思想万物皆资源 2. URI命名2.1 命名规则普遍规则：全部小写，用中划线连接。 单数复数个人习惯：全部单数 2.2 HTTP 方法常用的方法有 GET,POST,PUT,DELETE，此外有时还会用到 HEAD,PATCH和 OPTION。 GET 是查询操作，不会产生状态转移；DELETE 表示删除，将资源状态转移为删除；POST 表示添加一个资源，即资源状态从无转移到有;PUT 和 PATCH 是更新操作，会将资源状态转移为请求方所期望的状态； tip: 这里我们可以看到所有的 HTTP 方法所对应的都是资源状态的变化而非简单的增删改查。 2.3 拓展：安全、幂等、可缓存 HTTP 方法 安全性 幂等性 GET Yes Yes PUT No Yes POST No No HEAD Yes Yes PATCH No No DELETE No Yes 幂等性在 RESTful 中的含义：同一个操作，执行一次和执行多次的效果是一样的。 3. 响应消息体格式3.1 媒体类型与字符编码媒体类型一般为：JSON字符编码一般为：UTF-8 最好：客户端请求时携带请求头 Content-Type: application/json客户端请求中包含请求头 Accept 时它的值包含 application/json 3.2 响应信息包装与可见性常见的两种响应信息格式： 12345678910111213# 带包装&#123; \"code\": 200, \"data\": &#123; \"isbn\": \"9780321125217\", \"name\": \"Domain-Driven Design\" &#125;&#125;# 不带包装&#123; \"isbn\": \"9780321125217\", \"name\": \"Domain-Driven Design\"&#125; 一般情况下我会选择不带包装。 3.3 响应信息统一格式相同概念相同命名：多个表示同一概念的资源命名应保证相同；相似概念相同数据类型：如:时间都用时间戳，是否都用 01 表示等等；命名要符合团队思维定式：如:主键以首字母 + id 命名，外键以 _id 结尾； 4. 异常处理4.1 状态码4xx 客户端错误5xx 服务端错误 4.2 异常响应信息常用的异常响应信息体： 12345&#123; \"code\": \"\", \"message\": \"\", \"detail\": &#123;&#125;&#125; code：必须，错误码message：必须，错误信息detail：非必须，错误详情 tip：异常响应信息针对的一般为 4xx 的错误响应，5xx 的错误响应应为异常日志记录，这里暂不讨论。 5. 版本化如需版本化推荐使用：/{version}/{name}/{pk} 6. 鉴权个人方案：使用 JWT(JSON Web Token) 实现过程：在请求 HTTP HEADER 中添加 Authorization 信息服务端使用中间件拦截请求 HTTP HEADER 中 Authorization 的信息并验证 7. 接口文档待续…","tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://wiki.blanc.site/tags/RESTful/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-软件工程","slug":"3-计算机科学/4-软件工程","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"RESTful","slug":"3-计算机科学/4-软件工程/RESTful","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/RESTful/"}]},{"title":"MySQL 修改数据库名","date":"2019-01-14T00:00:00.000Z","path":"archives/ef1e0835.html","text":"首先，MySQL 没有直接更改数据库名称的命令；其次，无论使用什么方法都要记得提前备份数据库。 注：RENAME DATABASE 这条命令在 MySQL 5.1.7 中被加入，但很快就被发现其所带来的危险，于是在 MySQL 5.1.23 中这条命令被移除。 推荐方案假如现在我们想把数据库名由 ABC 更改为 EFG。 我们可以在数据库外执行以下命令： 12mysqladmin -u root -p create EFGmysqldump ABC | mysql -u root -p EFG 当你确定原数据库中的数据都被复制到了新数据库中，就可以把原数据库删掉了。 1drop database ABC 缺点：当数据库较大的时候，这种方法耗时耗力 其他方案（来自网络，不确保其安全性）重命名数据库里面的所有表information_schema 数据库 table 表记录了数据库中所有表的信息 123CREATE DATABASE new_db_name; # 创建新的数据库RENAME TABLE db_name.table1 TO new_db_name.table1; # 对所有的表进行重命名DROP DATABASE db_name; # 删除原来的数据库 当数据库表包含表很多的情况下，这样操作是比较效率也比较低，可以通过以下脚本进行批量修改: 生成 SQL 脚本 1mysql -uroot -p -e \"select concat('rename table db.',table_name,' to new_db.',table_name,';') from information_schema.TABLES where TABLE_SCHEMA='db';\" &gt; rename_mysql_name.sql 执行 SQL 语句 1mysql -uroot -p &lt; rename_mysql_name.sql # 批量进行修改","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wiki.blanc.site/tags/MySQL/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"6-数据库","slug":"3-计算机科学/2-计算机系统/6-数据库","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"3-计算机科学/2-计算机系统/6-数据库/MySQL","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}]},{"title":"Erlang 程序设计笔记-第一部分","date":"2018-11-19T00:00:00.000Z","path":"archives/76405d8b.html","text":"第一章：什么是并发在本书中，我们讲学习如何将 并行 活动描述为相互通信的多组 并行 进程，并学习如何编写并发程序。 在日常用语中，并发（concurrent）、同时（simultaneous）和并行（parallel）等词几乎表示同一个意思。但在编程语言中需要做更精确的区分。 如果只有一台单核的计算机，是无法在上面运行并行程序的。因为只有一个 CPU，而它一次只能做一件事。然而，可以在单核计算机上运行并发程序。计算机在不同任务之间分享时间，使人产生这些任务是并行运行的错觉。 1.1 给并发建模我们将从一个简单的例子入手，为一种日常情景构建并发模型。设想我看见四个人出去散步，另外还有两条狗和一大群兔子。这些人正在相互交谈，而狗则想要追逐兔子。要在Erlang里模拟这些，需要编写四个模块，名字分别是person（人）、dog（狗）、rabbit（兔子）和world（世界）。person的代码会放在名为person.erl的文件里，看起来就像是这样： 1234-module(person).-export([init/1])init(Name) -&gt; ... 第 1 行 -module(person). 的意思是此文件包含用于 person 模块的代码。它应该与文件名一致（除了 .erl 这个文件扩展名）。模块名必须以一个小写字母开头。从技术上说，模块名是一个原子（atom）（关于原子的详细介绍，可参见 3.5 节）。模块声明之后是一条导出声明。导出声明指明了模块里哪些函数可以从模块外部进行调用。它们类似于许多编程语言里的 public 声明。没有包括在导出声明里的函数是私有的，无法在模块外调用。-export([init/1]). 语法的意思是带有一个参数（/1 指的就是这个意思，而不是除以 1）的函数 init 可以在模块外调用。如果想要导出多个函数，就应该使用下面这种语法：方括号 [ ... ] 的意思是“列表”，因此这条声明的意思是我们想要从模块里导出一个函数列表。我们也会给 dog 和 rabbit 编写类似的代码。 1.1.1 开始模拟要启动程序，可以调用 world:start() 。它定义在一个名为 world 的模块里，这个模块的开头部分就像这样： 123456789101112-module(world).-export([start/0]).start() -&gt; Joe = spawn(person, init, [\"Joe\"]), Susannah = spawn(person, init, [\"Susannah\"]), Dave = spawn(person, init, [\"Dave\"]), Andy = spawn(person, init, [\"Andy\"]), Rover = spawn(dog, init, [\"Rover\"]), ... Rabbitl = spawn(rabbit, init, [\"Flopsy\"]), ... spawn 是一个 Erlang 基本函数，它会创建一个并发进程并返回一个进程标识符。spawn 可以这样调用： 1spawn(ModName, FuncName, [Arg1, Arg2, ..., ArgN]) 当 Erlang 运行时系统执行 spawn 时，它会创建一个新进程（不是操作系统的进程，而是一个由 Erlang 系统管理的轻量级进程）。当进程创建完毕后，它便开始执行参数所指定的代码。ModName 是包含想要执行代码的模块名。FuncName 是模块里的函数名，而 [Arg1, Arg2, ...] 是一个列表，包含了想要执行的函数参数。 spawn 的返回值是一个进程标识符（PID，Process IDentifier），可以用来与新创建的进程交互。 与对象类比 Erlang 里的模块类似于面向对象编程语言（OOPL，Object-Oriented Programming Language）里的类，进程则类似于 OOPL 里的对象（或者说类实例）。 在 Erlang 里，spawn 通过运行某个模块里定义的函数创建一个新进程。而在 Java 里，new 通过运行某个类中定义的方法创建一个新对象。 在 OOPL 里可以用一个类创建数千个类实例。类似地，在 Erlang 里我们可以用一个模块创建数千甚至数百万个执行模块代码的进程。所有 Erlang 进程都并发且独立执行，如果有一台百万核的计算机，甚至可以并行运行。 1.1.2 发送消息启动模拟之后，我们希望在程序的不同进程之间发送消息。在 Erlang 里，各个进程不共享内存，只能通过发送消息来与其他进程交互。这就是现实世界里的物体行为。 假设 Joe 想要对 Susannah 说些什么。在程序里我们会编写这样一行代码： 1Susannah ! &#123;self(), \"Hope the dogs don't chase the rabbits\"&#125; Pid ! Msg 语法的意思是发送消息 Msg 到进程 Pid。大括号里的 self() 参数标明了发送消息的进程（在此处是Joe）。 1.1.3 接收消息为了让 Susannah 的进程接收来自 Joe 的消息，要这样写: 1234receive &#123;From, Message&#125; -&gt; ...end 当 Susannah 的进程接收到一条消息时，变量 From 会绑定为 Joe，这样 Susannah 就知道消息来自何处，变量 Message 则会含此消息。 这里应该记住的关键一点是:编程模型基于对现实世界的观察 1.2 并发的益处并发编程可以用来提升性能，创建可扩展和容错的系统，以及编写清晰和可理解的程序来控制现实世界里的应用。 性能 可扩展性 容错性 清晰性 1.3 并发程序和并行计算机尝试给出并发和并行这类术语的准确含义。 先来区分一下并发程序(也就是如果有并行计算机就可能会跑得更快的程序)和多核(或 CPU)的并行计算机 并发程序 是一种用并发编程语言编写的程序。编写并发程序是为了提升性能、可扩展性和容错性。 并发编程语言 拥有专门用于编写并发程序的语言结构。这些结构是编程语言的主要部分，在所有操作系统上都有着相同的表现。 并行计算机 是一种有多个处理单元(CPU 或核心)同时运行的计算机。 Erlang 里的并发程序是由互相通信的多组顺序进程组成的。一个 Erlang 进程就是一个小小的虚拟机，可以执行单个 Erlang 函数。别把它和操作系统的进程相混淆。 要用 Erlang 编写一个并发程序，必须确定一组用来解决问题的进程。这种确定进程的做法被称为并发建模。它类似于在编写面向对象程序时确定所需对象的技艺。 现在我们了解了并发程序和并行计算机之间的区别。并发性与软件结构有关，而并行性与硬件有关。下面来看看顺序和并发编程语言之间的区别。 1.4 顺序和并发编程语言编程语言有两种:顺序和并发。顺序语言被设计用于编写顺序程序，没有描述并发计算的语言结构。并发编程语言被设计用于编写并发程序，语言本身带有表达并发性的特殊结构。 在 Erlang 里，并发性由 Erlang 虚拟机提供，而非操作系统或任何的外部库。在大多数顺序编程语言里，并发性都是以接口的形式提供，指向主机操作系统的内部并发函数。 在 Erlang 里，进程和并发是我们可以用来定型和解决问题的工具。这让细粒度控制程序的并发结构成为可能，而用操作系统的进程是很难做到的。 第二章：Erlang 速览在这一章里，我们会创建第一个并发程序。制作一个文件服务器，使其拥有两个并发进程:一个进程代表服务器，另一个代表客户端。 2.1 Shell请注意每一条表达式都必须以一个句号后接一个空白字符结尾。 2.1.1 = 操作符可以用=操作符给变量赋值(严格来说是给变量绑定一个值)，就像这样: 12341&gt; X = 123.1232&gt; X * 2.246 不能重新绑定变量。Erlang是一种函数式语言，所以一旦定义了 X = 123，那么X永远就是123，不允许改变! = 不是一个赋值操作符，它实际上是一个模式匹配操作符。(详情请参见3.3.2节) 如果你习惯了命令式语言，可能会对这个概念感到不可思议。在命令式语言里，变量其实是伪装起来的内存地址。 2.1.2 变量和原子的语法请注意 Erlang 的变量以大写字母开头。所以 X、This 和 A_long_name 都是变量。 以小写字母 开头的名称(比如 monday 或 friday )不是变量，而是符号常量，它们被称为原子(atom)。 2.2 进程、模块和编译Erlang 程序是由许多并行的进程构成的。 进程负责执行模块里定义的函数。模块则是扩展名为 .erl 的文件，运行前必须先编译它们。编译某个模块之后，就可以在shell或者直接从操作系统环境的命令行里执行该模块中的函数了。 下面几节将介绍如何在 shell 或操作系统命令行里编译模块和执行函数。 2.2.1 在 shell 里编译并运行 Hello World制作一个带有以下内容的hello.erl文件: 123456% hello.erl-module(hello).-export([start/0]).start() -&gt; io:format(\"hello world~n\"). 为了编译并运行它，我们从保存 hello.erl 的目录里启动 Erlang shell，然后执行下面的操作： 12345678$ erl1&gt; c(hello).&#123;ok,hello&#125;2&gt; hello:start().hello worldok3&gt; halt().$ c(hello) 命令编译了 hello.erl 文件里的代码。{ok, hello} 的意思是编译成功。现在代 码已准备好运行了。第2行里执行了 hello:start() 函数。第3行里停止了 Erlang shell。 在 shell 里进行操作的优点是只要平台为 Erlang 所支持，这种编译和运行程序的方法就一定可用。在操作系统的命令行里的操作可能会因平台的不同而有所差别。 2.2.2 在 Erlang shell 外编译也可以在操作系统的命令行里编译和运行前一个例子中的代码，就像下面这样: 123$ erlc hell.erl$ erl -noshell -s hello start -s init shophello world erlc 从命令行启动了 Erlang 编译器。编译器编译了 hello.erl 里的代码并生成一个名为 hello.beam 的目标代码文件。 $erl -noshell ... 命令加载了 hello 模块并执行 hello:start() 函数。随后，它执行了 init:stop() ，这个表达式终止了Erlang会话。 在 Erlang shell 之外运行 Erlang 编译器(erlc)是编译 Erlang 代码的首选方式。 使用 erlc 的优点在于自动化。我们可以在 rakefile 或 makefile 内运行 erlc 来自动化构建过程。 2.3 你好，并发如何编写并发程序呢?Erlang的基本并发单元是进程(process)。一个进程是一个轻量级的虚拟机，只能通过发送和接收消息来与其他进程通信。 将要编写的第一个并发程序是一个文件服务器。要在两台机器之间传输文件，需要客户端和服务器两个程序。为了实现这一点，我们将制作两个模块：afile_client 和 afile_server。 2.3.1 文件服务器进程文件服务器由一个名为 afile_server 的模块实现。这里再提醒一下，进程和模块类似于对象和类。用于进程的代码包含在模块里，要创建一个进程，需要调用 spawn(...)，创建进程的实际操作由这个基本函数完成。 123456789101112131415% afile_server.erl-module(afile_server).-export([start/1, loop/1]).start(Dir) -&gt; spawn(afile_server, loop, [Dir]).loop(Dir) -&gt; receive &#123;Client, list_dir&#125; -&gt; Client ! &#123;self(), file:list_dir(Dir)&#125;; &#123;Client, &#123;get_file, File&#125;&#125; -&gt; Full = filename:join(Dir, File), Client ! &#123;self(), file:read_file(Full)&#125; end, loop(Dir&#125;. 这段代码的结构非常简单。如果略去大部分细节，它看起来就会像这样: 1234567loop(Dir) -&gt; %% 等待指令 receive Command -&gt; ... 做点什么 ... end, loop(Dir). 这就是用 Erlang 编写无限循环的方法。变量 Dir 包含了文件服务器当前的工作目录。我们在这个循环内等待指令，接收到指令时我们会遵从，然后再次调用自身来获取下一个指令。 不用担心最后的自身调用，这不会耗尽栈空间。Erlang 对代码采用了一种所谓“尾部调用”的优化，意思是此函数的运行空间是固定的。这是用Erlang编写循环的标准 方式，只要在最后调用自身即可。 另一点要注意的是，loop 函数永远不会返回。在顺序编程语言里，必须要极其小心避免无限循环，因为只有一条控制线，如果这条线卡在循环里就有麻烦了。Erlang则没有这个问题。服务器只是一个在无限循环里处理请求的程序，与我们想要执行的其他任务并行运行。 现在仔细查看接收语句。回忆一下，它看起来就像这样: 1234567receive &#123;Client, list_dir&#125; -&gt; Client ! &#123;self(), file:list_dir(Dir)&#125;; &#123;Client, &#123;get_file, File&#125;&#125; -&gt; Full = filename:join(Dir, File), Client ! &#123;self(), file:read_file(Full)&#125;end, 这段代码的意思是如果接收到 {Client, list_dir} 消息，就应该回复一个文件列表;如果接收到的消息是 {Client, {get_file, File}}，则回复这个文件。作为模式匹配过程的一部分，Client 变量在收到消息时会被绑定。 这段代码非常紧凑，所以很容易忽略所发生的细节。这段代码里有三个要点需要加以注意。 回复给谁所有接收的消息都包含变量 Client，它是发送请求进程的进程标识符，也是应该回复的对象。如果想要得到一条消息的回复，最好说明一下回复应该发给谁。就像在信件里写明姓名 和地址，如果不说明信件来自何处，就永远得不到回复。 self() 的用法服务器发送的回复包含了参数 self()(在这个案例里 self() 是服务器的进程标识符)。这个标识符被附在消息中，使客户端可以检查收到的消息的确来自服务器，而不是其他 13 某个进程。 模式匹配被用于选择消息接收语句内部有两个模式。可以这样编写: 1234567receive Pattern1 -&gt; Actions1; Pattern2 -&gt; Actions2 -&gt; ...end Erlang 编译器和运行时系统会正确推断出如何在收到消息时运行适当的代码。不需要编写任何的 if-then-else 或 switch 语句来设定该做什么。这是模式匹配带来的乐趣之一，会为你节省大量工作。 可以像下面这样在 shell 里编译和测试这段代码: 123456789101&gt; c(afile_server).&#123;ok,afile_server&#125;2&gt; FileServer = afile_server:start(\".\").&lt;0.47.0&gt;3&gt; FileServer ! &#123;self(), list_dir&#125;.&#123;&lt;0.31.0&gt;,list_dir&#125;4&gt; receive X -&gt; X end.&#123;&lt;0.47.0&gt;, &#123;ok,[\"afile_server.beam\",\"processes.erl\",\"attrs.erl\",\"lib_find.erl\",\"dist_demo.erl\",\"data1.dat\",\"scavenge_urls.erl\",\"test1.erl\",...]&#125;&#125; 来看看相关细节。 121&gt; c(afile_server).&#123;ok,afile_server&#125; 编译 afile_server.erl 文件所包含的 afile_server 模块。编译很成功，所以“编译”函数 c 的返回值是 {ok, afile_server}。 122&gt; FileServer = afile_server:start(\".\").&lt;0.47.0&gt; afile_server:start(Dir) 调用 spawn(afile_server, loop, [Dir])。这就创建出一个新的并行进程来执行函数 afile_server:loop(Dir) 并返回一个进程标识符，可以用它来与此进程通信。&lt;0.47.0&gt; 是文件服务器进程的进程标识符。它的显示方式是尖括号内由句号分隔的三个整数。 每次运行这个程序时，进程标识符都会改变。因此，&lt;0.47.0&gt; 里的数字在不同的会话里将会是不同的。 123&gt; FileServer ! &#123;self(), list_dir&#125;.&#123;&lt;0.31.0&gt;,list_dir&#125; 这里给文件服务器进程发送了一条 {self(), list_dir} 消息。Pid ! Message 的返回值被规定为 Message ， 因 此 shell 打印出 {self(),list_dir} 的值即 {&lt;0.31.0&gt;, list_dir}。&lt;0.31.0&gt; 是 Erlang shell 自身的进程标识符，它被包括在消息内，告知文件服务器应该回复给谁。 12344&gt; receive X -&gt; X end.&#123;&lt;0.47.0&gt;, &#123;ok,[\"afile_server.beam\",\"processes.erl\",\"attrs.erl\",\"lib_find.erl\",\"dist_demo.erl\",\"data1.dat\",\"scavenge_urls.erl\",\"test1.erl\",...]&#125;&#125; receive X -&gt; X end 接收文件服务器发送的回复。它返回元组 {&lt;0.47.0&gt;, {ok, ...}。 该元组的第一个元素 &lt;0.47.0&gt; 是文件服务器的进程标识符。第二个参数是 file:list_dir(Dir) 函数的返回值，它在文件服务器进程的接收循环里得出。 2.3.2 客户端代码文件服务器通过一个名为 afile_client 的客户端模块进行访问。这个模块的主要目的是为了隐藏底层通信协议的细节。 客户端代码的用户可以通过调用此客户端模块导出的 ls 和 get_file 函数来传输文件。这就能够自由改变底层的协议而不会影响到客户端代码API部分。 1234567891011121314151617%afile_cilent.erl-module(afile_client).-export([ls/1, get_file/2])ls(Server) -&gt; Server ! &#123;self(), list_dir&#125;, receive &#123;Server, FileList&#125; -&gt; FileList end.get_file(Server, File) -&gt; Server ! &#123;self(), &#123;get_file, File&#125;&#125;, receive &#123;Server, Content&#125; -&gt; Content end. 如果对比 afile_clien 与 afile_server 的代码，就会发现一种美妙的对称性。只要客户端 里有 Server ! ... 这类 send 语句，服务器里就会有 receive 模式，反之亦然。 现在要重启 shell 并重新编译所有代码，展示客户端和服务器如何共同工作。 123456789101&gt; c(afile_server).&#123;ok,afile_server&#125;2&gt; c(afile_client&#125;.&#123;ok,afile_client&#125;3&gt; FileServer = afile_server:start(\".\").&lt;0.43.0&gt;4&gt; afile_client:get_file(FileServer,\"missing\").&#123;error,enoent&#125;5&gt; afile_client:get_file(FileServer,\"afile_server.erl\").&#123;ok,&lt;&lt;\"%%%-------------------------------------------------------------------\\n%%% @author ryoma\\n%%% @copyright (C) \"...&gt;&gt;&#125; 现在在 shell 里运行的代码和之前代码的唯一区别，是把接口程序抽象出来放入单独的模块里。我们隐藏了客户端和服务器之间消息传递的细节，因为没有其他程序对此感兴趣。 到目前为止，你看到了一个完整文件服务器的基础部分，但它尚未完成。还有很多的细节问题，涉及启动和停止服务器、连接某个套接字(socket)等，在这里不会提及。 从 Erlang 的角度看，如何启动和停止服务器，连接套接字，从错误中恢复等都是琐碎的细节。 问题的本质在于创建并行进程，以及发送和接收消息。 在 Erlang 里用进程来构建问题的解决方案。思考进程的结构(也就是说哪些进程间相互有联系)，思考进程间传递的消息以及消息包含何种信息是思考和编程方式的中心。 2.3.3 改进文件服务器我们开发的文件服务器包括了运行在同一台机器上的两个相互通信的进程，展示了编写并发程序所需的一些基本要素。对真正的服务器而言，客户端和服务器会运行在不同的机器上，所以 必须设法让进程间的消息不仅能在同一个Erlang节点的进程之间传递，也能在物理上隔开的机器上的Erlang进程之间进行。 在这一章里，我们了解了如何在shell里执行一些简单的操作，编译一个模块，以及用spawn、send和receive这三个基本函数创建一个简单的双进程并发程序。 2.4 练习现在也许是个好机会来检查一下你对目前所做的有几分了解。 启动并停止 Erlang shell。 在 Erlang shell 里输入一些命令。不要忘了以句号和空白结束命令。 对 hello.erl 做一些小小的改动。在 shell 里编译并运行它们。如果有错，中止E rlang shell 并重启 shell。 运行文件客户端和服务器代码。加入一个名为 put_file 的命令。你需要添加何种消息?学习如何查阅手册页。查阅手册页里的file模块。 PS：Erlang 中文文档：点击查看","tags":[{"name":"Erlang 程序设计笔记","slug":"Erlang-程序设计笔记","permalink":"https://wiki.blanc.site/tags/Erlang-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Erlang","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Erlang","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Erlang/"}]},{"title":"CentOS7 + Python3 + Django(rest_framework) + MariaDB + nginx + uwsgi 部署 API 开发环境","date":"2018-08-17T00:00:00.000Z","path":"archives/22a754d3.html","text":"这是一个 Django 环境部署教程，也是一个我坑爹的 Django 环境部署记录： 开始撸代码之前有两点需要提醒： 本教程完美适配如题开发环境但不局限于此环境，其他开发环境仅需将命令操作转换为当前环境下的命令即可； 我写作的顺序是我个人体验比较好的操作顺序仅供参考； 开撸： 1. MariaDB 的安装与部署123456789101112131415161718192021222324252627# yum 安装yum -y install mariadb mariadb-server mariadb-devel# 安装完成MariaDB，首先启动MariaDBsystemctl start mariadb# 设置开机启动systemctl enable mariadb# 接下来进行MariaDB的相关简单配置mysql_secure_installation#首先是设置密码，会提示先输入密码Enter current password for root (enter for none):# 初次运行直接回车#设置密码Set root password? [Y/n] # 是否设置root用户密码，输入y并回车或直接回车New password: # 设置root用户的密码Re-enter new password: # 再输入一次你设置的密码#其他配置Remove anonymous users? [Y/n] # 是否删除匿名用户Disallow root login remotely? [Y/n] #是否禁止root远程登录Remove test database and access to it? [Y/n] # 是否删除test数据库Reload privilege tables now? [Y/n] # 是否重新加载权限表#初始化MariaDB完成，接下来测试登录mysql -uroot -ppassword 注意：切记安装 mariadb-devel （Ubuntu 下是 mysql-dev 或 libmysqlclient-dev）否则在下面安装 Python 的 mysqlclient 包的时候可能会出现 mysql_config not found 的错误。 2. Python3 的安装与部署在 CentOS 中默认安装了 Python2 如果你是基于 Python2 开发的话可以直接使用，但也要注意版本尽量升级到 Python2 的最新版。 2.1 安装 Python3 所需依赖CentOS 里面是 XXX-devel，如果在 Ubuntu 下安装则要改成 XXX-dev。 1234567891011# 为 CentOS 系统增加编译功能yum install -y gcc-c++# 安装这些模块都是为了成功编译安装 Python3，防止出现各种异常yum install -y wget openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel xz-devel tk-devel gdbm-devel# 3.7版本需要一个新的包libffi-devel，安装此包之后再次进行编译安装即可。yum install -y libffi-devel# 安装这个模块是为了让 uwsgi 支持使用 -x 选项，能通过 xml 文件启动项目yum install -y libxml* 各个依赖的用途我就不展开讲了，如果好奇的话可以去百度，度娘都知道。 提醒一点：如果你之前已经尝试过一次安装并且失败了，可以看一下是不是少装了某项依赖，在依赖完整的情况下，安装完 Python3 后会自动附带安装 pip。 2.2 编译安装 Python3.X点击查看 Python 官方 FTP 地址 1234567891011121314151617# 点击上面的官方 FTP 地址选择你想要的版本和压缩方式，获取下载连接# 本例以 Python3.6.3 为例# 在合适的路径（推荐在用户根路径下如 /home 或者 /root ）下执行下载命令：wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz# 下载完成后执行解压命令：tar -zxvf Python-3.6.3.tar.gz# 进入解压后的 Python-3.6.3 文件，依次执行以下命令：# 编译设置将 Python3 安装到 /usr/local/python3/ 路径下./configure --prefix=/usr/local/python3makemake install# 创建 Python3 软连接，方便直接在命令行使用 Python3 和 pip3 直接调用 Python3 和 pip3ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 3.3 利用 pip3 安装必要的 Python 包123456# 升级 pip3 到最新版本pip3 install --upgrade pip# 安装需要的包（ django djangorestframework mysqlclient ) pip3 install django djangorestframework mysqlclient# 创建 django-admin 软连接ln -s /usr/local/python3/bin/django-admin /usr/bin/django-admin 3. uwsgi 的安装本文推荐使用 pip3 直接下载安装 uwsgi 若想使用其他安装方法请自行百度。 1234# 下载安装 uwsgipip3 install uwsgi# 创建 uwsgi 软连接ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi3 4. Django 项目创建或下载在适合的位置用 django-admin startproject myproject 创建自己的项目，或者用 Git , FTP上传工具 等上传、克隆自己的项目，本文采用新建项目的方式呈现此过程： 123456789101112131415161718192021222324252627282930313233# 在合适的地方创建用来存放 Django 项目的目录mkdir /var/www# 进入目录cd /var/www# 创建 Django 项目django-admin startproject myproject# 进入项目cd myproject# 查看项目目录lsmyproject manage.py# 其中 myproject 为项目配置文件目录 manage.py 为 Django 命令行工具# 记住我刚刚定义的几个名词：# 项目目录：/var/www/myproject # 项目配置文件目录：/var/www/myproject/myproject # 这在后面的配置中有很大的作用千万别搞混# 下面，进入项目配置文件目录修改部署需要的配置cd myprojectvim settings.py# 必须修改的有（本设置不适合在上线项目中使用）# 1. 修改 ALLPWED_HOSTS = ['*']# 2. 修改 DATABASES 如下（相应位置改为你的项目的相应值）：DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库类型 'NAME': 'test', # 项目数据库名称 'HOST': '127.0.0.1', # 数据库地址 'PORT': '3306', # 端口号 'USER': 'root', # 数据库用户名 'PASSWORD': 'root', # 数据库密码 &#125; &#125;# 注意：如果你是上传的自己在本地环境写好的程序别忘了同步数据库 5. uwsgi 设置在适当的目录下创建 uwsgi 配置文件。本文采用 xml 配置文件，需要更多类型配置文件请自行百度。 123456789101112131415161718# 进入项目目录cd /var/www/myproject# 创建编辑 uwsgi 配置文件（文件名自起）vim uwsgiset.xml# 内容如下&lt;uwsgi&gt; &lt;socket&gt;127.0.0.1:8997&lt;/socket&gt;&lt;!-- 内部端口，自定义 --&gt; &lt;chdir&gt;/var/www/myproject&lt;/chdir&gt;&lt;!-- 项目目录 --&gt; &lt;module&gt;myproject.wsgi&lt;/module&gt;&lt;!-- wsgi 启动文件 --&gt; &lt;processes&gt;4&lt;/processes&gt; &lt;!-- 进程数 --&gt; &lt;daemonize&gt;uwsgi.log&lt;/daemonize&gt;&lt;!-- 日志文件路径 --&gt; &lt;pidfile&gt;uwsgi.pid&lt;/pidfile&gt;&lt;!-- uwsgi 管理文件路径，用来重启 uwsgi --&gt;&lt;/uwsgi&gt;# 更多配置信息请自行百度# 在项目目录（ /var/www/myproject ）下启动：uwsgi3 -x uwsgiset.xml# 提醒 [uWSGI] parsing config file myproject.xml 则启用成功# 注意仅仅是启用成功 6. nginx 下载、设置和启用12345678910111213141516171819202122232425262728293031323334353637383940414243444546# [必须]安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：yum install -y gcc-c++# [必须]PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：yum install -y pcre pcre-devel# [自选]zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。yum install -y zlib zlib-devel# [自选]nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。yum install -y openssl openssl-devel# 官网下载 Ngxin# 直接下载.tar.gz安装包，地址：https://nginx.org/en/download.html# 推荐选择稳定版下载 ： 当前版本 1.12.2# 下载链接： https://nginx.org/download/nginx-1.12.2.tar.gzwget -c https://nginx.org/download/nginx-1.12.2.tar.gz# 解压 用到了之前下载的zlib库 若没下载可选择其他方式解压tar -zxvf nginx-1.12.2.tar.gz# 编译前初始化配置cd nginx-1.12.2 # 进入nginx目录./configure # 使用默认配置# 编译安装makemake install# 查找安装路径[root@Ryoma nginx-1.12.2]#whereis nginxnginx: /usr/local/nginx# 启动、停止 nginxcd /usr/local/nginx/sbin/ # 进入 nginx sbin 目录./nginx # 启动 nginx./nginx -s quit # 此方式停止步骤是待 nginx 进程处理任务完毕进行停止./nginx -s stop # 此方式相当于先查出 nginx 进程id再使用kill命令强制杀掉进程./nginx -s reload # 重新加载#查询 nginx 进程：ps aux|grep nginx# 配置 nginxvim /usr/local/nginx/conf/nginx.conf# 个人配置图如下 1234567# :wq保存后进入 /usr/local/nginx/sbin/ 目录# 先检查配置文件是否有错./nginx -t# 没有错就执行以下命令：./nginx# 终端没有任何提示就证明 nginx 启动成功，可以通过链接查看 nginx 是否启动成功:# http://192.168.1.111 （请将该ip替换成你的服务器ip） 若出现 nginx 错误，请自行查阅 nginx 错误日志 （默认在 /usr/local/ngxin/logs/error.log）若出现 internal server error，请查看 uwsgi 日志 （位置请看 uwsgi xml 配置文件） 理论上来说到这里你就能看到你的 Django 项目启动成功了，如果过程中出现了任何你自己无法解决的问题，欢迎留言或邮件（ryomahan1996#gmail.com）联系我。","tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://wiki.blanc.site/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"Django","slug":"Django","permalink":"https://wiki.blanc.site/tags/Django/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux 学习笔记-1","date":"2018-07-05T00:00:00.000Z","path":"archives/d19e8f5d.html","text":"常用命令格式：[功能：命令] -&gt; [内部功能：命令] 注销：exit 显示目前所支持的语言：echo $LANG 显示日期与时间：date 显示日历：cal 简单好用的计算器：bc -&gt; 退出：quit 取几位小数：scale=&lt;位数&gt; 更多在线命令手册：man &lt;需要查询的命令&gt; -&gt; 查找：/ &lt;关键词&gt; 数据同步写入磁盘（关机前必备）：sync 惯用的关机命令：shutdown 重启：reboot，halt，poweroff 切换执行等级：init 改变文件所属用户组：chgrp &lt;用户组名&gt; &lt;文件名&gt; -&gt; -R：连同目录下的所有文件、目录 改变文件所有者：chown &lt;账号名称&gt; &lt;文件名&gt; -&gt; -R：连同目录下的所有文件、目录 改变文件的权限：chmod &lt;权限（两种方法）&gt; &lt;文件名&gt; -&gt; -R：连同目录下的所有文件、目录 复制文件：cp &lt;源文件&gt; &lt;目标文件&gt; 切换用户身份：su &lt;用户名&gt; 新建新目录：mkdir &lt;目录名&gt; 新建空文件：touch &lt;文件名&gt; 连接文件并在终端输出文件内容：cat &lt;文件名&gt; 常用热键格式：[热键：功能] Tab ：命令补全、文件补齐 Ctrl + c ：终止 Ctrl + d ：输入（输出）结束，也可以代替 exit 命令行基础command（命令） -options（选项） parameter1（参数1） parameter2（参数2） 一行命令中第一个输入的部分绝对是 [命令（command）]或[可执行文件]； 命令、选项、参数等这几个命令中间以空格来区分，不论几个空格 shell 都视为一个； 按下 Enter 后命令立即执行，Enter 按键代表一行命令的开始启动； 命令太长的时候，可以用反斜杠（\\）来转义 Enter 符号，使命令持续到下一行。 用户与用户组Linux 用户身份与用户组记录的文件在 Linux 系统当中，预设的情况下，所有的系统上的帐号与一般身份使用者，还有 root 的相关资讯，都是记录在 /etc/passwd 这个文件内的。至于个人的密码则是记录在 /etc/shadow 这个文件下。此外，Linux 所有的群组名称都纪录在 /etc/group 内！这三个文件可以说是 Linux 系统里面帐号、密码、群组信息的集中地啰！不要随便删除这三个文件啊！ Linux 文件权限概念Linux 文件属性 上图为 root 用户终端输入 ls -al 后终端输出结果 第一列：代表这个文件的类型与权限（permission）：这个地方最需要注意了！仔细看的话，你应该可以发现这一栏其实共有十个字元： 第一个字元代表这个文件是目录、文件或连接档等等： 当为 d 则是目录，例如上表文件名为 .config 的那一行；当为 - 则是文件，例如上表文件名为 initial-setup-ks.cfg 那一行；若是 l 则表示为连接档（link file）；若是 b 则表示为装置档里面的可供储存的周边设备（可随机存取装置）；若是 c 则表示为装置档里面的序列端口设备，例如键盘、鼠标（一次性读取装置）。 接下来的字元中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读（read）、 w 代表可写（write）、 x 代表可执行（execute）。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已: 第一组为文件拥有者可具备的权限，以 initial-setup-ks.cfg 那个文件为例，该文件的拥有者可以读写，但不可执行；第二组为加入此群组之帐号的权限；第三组为非本人且没有加入本群组之其他帐号的权限。 第二列：表示有多少文件名连接到此节点（i-node）；第三列：表示这个文件（或目录）的拥有者帐号；第四列：表示这个文件的所属群组；第五列：为这个文件的容量大小，预设单位为 bytes；第六列：为这个文件的建档日期或者是最近的修改日期；第七列：为该文件名（若文件名前面多了一个 . 则表示该文件为隐藏文件）；目录与文件的权限意义权限对文件的重要性文件是实际含有数据的地方，包括一般文字文件、数据库内容文件、二进位可执行文件（binary program）等等。因此，权限对于文件来说，他的意义是这样的： r（read）：可读取此一文件的实际内容，如读取文字文件的文字内容等； w（write）：可以编辑、新增或者是修改该文件的内容（但不含删除该文件）； x（execute）：该文件具有可以被系统执行的权限。 可读（r）代表读取文件内容是还好了解，那么可执行（x）呢？这里你就必须要小心啦！因为在 Windows 底下一个文件是否具有执行的能力是是由扩展名来判断的，例如：.exe，.bat，.com 等等，但是在 Linux 底下，我们的文件是否能被执行，则是是由是否具有 x 这个权限来决定的！跟文件名是没有绝对的关系的！ 当你对一个文件具有 w 权限时，你具有写入/编辑/新增/修改文件的内容的权限，但并不具备有删除该文件本身的权限！对于文件的 rwx 来说，主要都是针对文件的内容而言，与文件文件名的存在与否没有关系！因为文件记录的是实际的数据！ 注意：一个文件有可执行权限不代表这个文件就一定能被执行成功，还需要看文件内有没有可以被执行的内容！ 权限对目录的重要性目录主要的内容在记录文件名清单，文件名与目录有强烈的关连！所以如果是针对目录时，rwx 是什么意义呢？ 1. r: read contents in directory：表示具有读取目录结构清单的权限，所以当你具有读取（r）一个目录的权限时，表示你可以查询该目录下的文件名数据。所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！ 2. w: modify contents of directory：这个可写入的权限对目录来说，是很了不起的！因为他表示你具有异动该目录结构清单的权限，也就是底下这些权限： 建立新的文件与目录； 删除已经存在的文件与目录（不论该文件的权限为何！） 将已存在的文件或目录进行更名； 搬移该目录内的文件、目录位置。 总之，目录的 w 权限就与该目录底下的文件名异动有关就对了啦！ 3. x: access directory：目录只是记录文件名而已，不可以被执行，目录的 x 代表的是使用者能否进入该目录成为工作目录！所谓的工作目录（work directory）就是你目前所在的目录啦！举例来说，当你登入 Linux 时，你所在的目录就是你当下的工作目录。而变换目录的指令是 cd: change directory！ Linux 文件种类与扩展名文件种类- ：普通文件d ：目录l ：连接文件（类似于 Windows 下的快捷方式）b ：块设备文件（例如硬盘、软盘等）c ：字符设备文件（例如鼠标、键盘等，特征：一次性读取）s ：套接字，数据接口文件（通常被用在网络上的数据连接）p ：管道（FIFO，pipe），主要用于解决多个程序同时访问一个文件所造成的错误 Linux 目录配置Linux 目录配置标准：FHS（Filesystem Hierarchy Standard）FHS 依据档案系统使用的频繁与否与是否允许使用者随意更动，而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样： 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行档与使用者的邮件等数据，是能够分享给网络上其他主机挂载用的目录； 不可分享的：自己机器上面运作的装置档案或者是与程序有关的 socket 档案等，由于仅与自身机器有关，所以当然就不适合分享给其他主机了。 不变的：有些数据是不会经常变动的，跟随着 distribution 而不变动。例如函式库、文件说明档、系统管理员所管理的主机服务设定档等等； 可变动的：经常改变的数据，例如登录档、一般用户可自行收受的新闻组等。 事实上，FHS 针对目录树构架仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义： /：root，根目录，与开机系统有关/usr：unix software resource，与软件安装/执行有关/var：variable，与系统运作过程有关 去FHS官网了解更多 绝对路径与相对路径除了需要特别注意的 FHS 目录配置外，在文件名部分我们也要特别注意！因为根据文件名写法的不同，也可将所谓的路径（path）定义为绝对路径（absolute）与相对路径（relative）。这两种文件名/路径的写法依据是这样的： 绝对路径：由根目录（/）开始写起的文件名或目录名称，例如 /home/dmtsai/.bashrc；相对路径：相对于目前路径的文件名写法。例如：./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法 而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下，如果想要进入 /var/log 这个目录时，可以怎么写呢？ 绝对路径：cd /var/log相对路径：cd ../var/log 因为你在 /home 底下，所以要回到上一层（../）之后，才能继续往/var来移动的！特别注意这两个特殊的目录： .：代表当前的目录，也可以使用 ./ 来表示；..：代表上一层目录，也可以 ../ 来代表。. 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式，就是代表上一层与目前所在目录的工作状态！ 目录与路径目录的相关操作","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wiki.blanc.site/tags/Linux/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://wiki.blanc.site/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"2-操作系统","slug":"3-计算机科学/2-计算机系统/2-操作系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"3-计算机科学/2-计算机系统/2-操作系统/Linux","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}]},{"title":"VMware 安装 CentOS 后网络设置","date":"2018-06-30T00:00:00.000Z","path":"archives/4dedf7b2.html","text":"这是一个适用性比较小解决方法，若此方法不能解决你遇到的问题请自行百度其他方法。 打开虚机看看虚机的网络设置了。命令如下 1vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0 其中部分内容如下： 1234DEVICE&#x3D;eth0 #设备名称，可根据ifcofnig命令查看到。BOOTPROTO&#x3D;dhcp #连接方式，dhcp会自动分配地址，此时不需要在下面设置ip和网关HWADDR&#x3D;00:0C:29:AD:66:9F #硬件地址，可根据ifcofnig命令查看到。ONBOOT&#x3D;yes #yes表示启动就执行该配置，需要改为yes 可用 ifconfig 命令获取相关信息。 修改完后需要重启网络设置 1service network restart","tags":[{"name":"VMware","slug":"VMware","permalink":"https://wiki.blanc.site/tags/VMware/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"VMware","slug":"2-软件使用/VMware","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/VMware/"}]},{"title":"「转载」PHP 判断文件存在是用 file_exists 还是 is_file","date":"2018-06-25T00:00:00.000Z","path":"archives/44e28494.html","text":"原文链接 结论:如果要判断文件是否存在，用函数 is_file()如果要判断目录是否存在，用函数 is_dir()好像没地方需要用 file_exists 了，不确定传入的参数是文件还是目录的时候用？ 以下为原文作者的证明过程： 在写程序时发现在判断文件是否存在时，有两种写法，有的人用了 is_file，有的人用了 file_exists，用哪个更好或者说更合适呢？ 判断文件存在用 is_file 还是 file_exists？ 看了这篇 PHP 中 file_exists 与 is_file, is_dir 的区别的说法基本明白，PHP 的 file_exists = is_dir + is_file。 写程序验证一下： 分别执行 1000次，记录所需时间。 文件存在(当前目录)is_file: 0.4570msfile_exists: 2.0640ms 文件存在(绝对路径 3 层 /www/hx/a/)is_file: 0.4909msfile_exists: 3.3500ms 文件存在(绝对路径 5 层 /www/hx/a/b/c/)is_file: 0.4961msfile_exists: 4.2100ms 文件不存在(当前目录)is_file: 2.0170msfile_exists: 1.9848ms 文件不存在(绝对路径 5 层 /www/hx/a/b/c/)is_file: 4.1909msfile_exists: 4.1502ms 目录存在file_exists: 2.9271msis_dir: 0.4601ms 目录不存在file_exists: 2.9719msis_dir: 2.9359ms is_file($file)file_exists($file)当 $file 是目录时，is_file 返回 false，file_exists 返回 true 文件存在的情况下，is_file 比 file_exists 要快得多；要检测文件所在的目录越深，速度差越多，但至少快 4 倍。 文件不存在的情况下，is_file 比 file_exists 要慢一点点，但可以忽略不计。 目录存在的情况下，is_dir 比 file_exists 要快得多；目录不存在的情况下，is_dir 比 file_exists 要慢一点点，但可以忽略不计。","tags":[],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"PHP","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/PHP","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/PHP/"}]},{"title":"「转载」PHP 静态方法和非静态方法简单对比","date":"2018-06-23T00:00:00.000Z","path":"archives/e639e72a.html","text":"静态方法优点效率比实例化高静态方法和静态变量创建后始终使用同一块内存 静态方法缺点不自动进行销毁 实例化优点可以做销毁 实例化缺点会创建多个内存 如何选择？很好理解，能够拿起来就用的，就用静态实现，比如工具类。你想用锤子，不可能先拿个锤子的模具制造出锤子之后再用吧，就是这么个意思。","tags":[],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"PHP","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/PHP","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/PHP/"}]},{"title":"vue-cli 下配置 Element + axios + Mockjs","date":"2018-05-31T00:00:00.000Z","path":"archives/b4f7e05e.html","text":"近期打算配合学习计划写一个小的匿名树洞，打算结合之前学习的 ThinkPHP5 和正在学习的 Vue 两个框架，最近在写项目的前端部分踩了好多坑还在一步一步摸索中。 本文是讲解在刚开始接触 Vue 时就使用 vue-cli 脚手架（官方不建议这么做而且确实有道理）的情况下如何配置 Element + axios + Mockjs 完成前后端分离开发（听起来很吊的样子）。 其中：Element 为饿了吗团队编写的一套 Vue 组件库axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中(简单的说就是一个 Ajax 构造器）Mockjs 是一个大佬写的[生成随机数据，拦截 Ajax 请求]的脚本（我其实还没完全研究明白这个东西怎么用） 1. 安装 vue-cli 脚手架参考博文：Vue 使用 vue-cli 搭建项目 2. 安装并配置 Element2.1 安装 loader 模块123npm install style-loader --save-Dnpm install css-loader --save-Dnpm install file-loader --save-D 2.2 安装 Element-UI 模块1npm install element-ui -S 2.3 在项目 main.js 中引入123import ElementUI from 'element-ui'import 'element-ui/lib/theme-default/index.css'Vue.use(ElementUI) 若安装后报错尝试重新安装 loader 模块 以上就成功在 Vue 脚手架上安装了 Element 组件，可以按照 Element 官网 给出的简例进行测试。 3. 安装并配置 axios3.1 安装 axios1npm install axios --save-dev 安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use ，只能每个需要发送请求的组件中即时引入。 为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton。这里只说修改原型链的方式。 3.2 如何改写原型链在 main.js 中引入 axios 1import axios from 'axios' 这时候如果在其它的组件中，是无法使用 axios 命令的。所以我们将 axios 改写为 Vue 的原型属性。 1Vue.prototype.$http= axios 在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http 命令，例如： 12345678910methods: &#123; show() &#123; this.$http(&#123; method: 'get', url: '/user', data: &#123; name: 'virus' &#125; &#125;)&#125; 4. 安装并配置 MockJsMockJs 的使用教程网上很多但是大都是基于低版本 Vue 做得现在已经不适用了，于是我结合了 MockJs 官方维基和一些大佬们写的最新版配置过程自己作了一次尝试目前在我自己的开发环境已经测试可用，若你们在配置的过程中出现问题欢迎随时留言我会在看到后尽快回复。 4.1 安装 MockJs1npm install mockjs --save-dev 4.2 配置 MockJs 入口文件在项目 src 目录下创建 mock 文件夹，定义 MockJs 主文件 mock.js，在该文件中定义拦截路由配置： 4.3 在 main.js 中引入 MockJs 4.4 成果测试因为我在安装 MockJS 之前就已经写了一些代码了所以我就在原来的代码基础上加了一个测试的 button 按钮以下是代码截图和前端展示： 到此此次教程结束，中途因为考试而终止了一次编写所以显得有些仓促，如果你在配置的过程中出现了问题欢迎留言。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://wiki.blanc.site/tags/Vue/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Vue","slug":"2-软件使用/Vue","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Vue/"}]},{"title":"ThinkPHP5 + 梦网实现手机验证码登陆后台逻辑","date":"2018-05-15T00:00:00.000Z","path":"archives/28f0dfb7.html","text":"前言之前一直挺好奇各个大平台怎么实现手机验证码登陆的，前几天手痒就尝试着通过 ThinkPHP 和梦网云通讯的短信 API 实现了一下服务器端的逻辑，功能实现很简单，不过还是有几个坑存在因此写下这篇文章记录一下。 本文记录了本人此次尝试的全部思路，比较冗长，提前劝退各位已经熟悉此类操作的大佬，当然如果有大佬愿意检查我的思路过程并指出其中不足我还是很欢迎的。 准备1. 模拟服务器环境准备我是用自己的笔记本来码的代码因此需要做一些前期的模拟服务器准备，不过由于我之前一直在写 PHP 所以环境早就搭建好了也不想在赘述过程了，具体环境信息如下：PHPStudy: PHP 7 + MySQL + ApacheIDE: PHPStrom 2. 短信验证码服务准备我简单的搜索了一下并尝试了几个别人说还不错的产品最后选择了梦网云通讯，原因有两个：注册简单，能免费体验。 需要准备的东西有：认证后的账号一个，上线的梦网短信发送账号一个（登录后在控制台的业务中心自己开启），PHP API 文件一份（官网开发者中心下载） 3. 部署好的 ThinkPHP5 代码我使用的是 v5.0.20 而不是最新的 v5.1 分支因为之前写的项目都是基于 5.0 开发的所以比较熟悉，为了降低时间成本就延续用了。 将下载好的代码放到开发目录下就可以开始准备开发了~ 开发开发分为两部分：发送验证码和验证验证码 发送验证码开发流程图 验证验证码开发流程图 源码源码已经被我删了，有问题直接问我吧。","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://wiki.blanc.site/tags/ThinkPHP/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"ThinkPHP","slug":"2-软件使用/ThinkPHP","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ThinkPHP/"}]},{"title":"Windows 下 ThinkPHP5 配置 redis 缓存","date":"2018-05-15T00:00:00.000Z","path":"archives/d2b8c7e4.html","text":"最近再写一个小的学校论坛项目，项目是基于 Vue + ThinkPHP5 开发的，在开发过程中遇到一个小问题让我纠结了好久，就是如何实现用户给帖子点赞。 用户给帖子点赞是一个很细节的小功能，在刚开始学习 Web编程 的时候曾经尝试过实现这个功能但总是会莫名其妙的卡住，当时觉得不是问题太难应该是我还没有学习相关的知识，直到最近开发项目的时候才发现问题并没有那么简单，我已经掌握了基本的前后端和数据库的知识但是具体实践起来还是有些困难，于是就百度了一下在 V2EX 上找到了这样一篇帖子 小菜我准备写一个简单的论坛…，看了里面大佬的回复才发现原来还是知识体系不全面，如大佬所言要很好的实现点赞功能需要借助 redis 等缓存机制来完成快速的读写。 于是我又赶紧补习了一下关于 redis 的一下皮毛并进行了 Windows 下 ThinkPHP5 配置 redis 缓存，过程中还是有几个小坑的，于是写下这篇文章记录一下： 1. 声明本教程所配置的仅是 Windows 下的开发环境并非服务器环境若需要服务器环境配置请自行百度。 2. 安装 php 的 redis 和 igbinary 拓展php_igbinary: 在序列化和反序列化的效率上高于其自带的php_redis: 效率是相当高有链表排序功能 首先在 phpinfo 页面查看本机 php 版本 然后分别点击 redis 拓展下载地址 和 igbinary 拓展下载地址 下载相应的拓展 下载完成后解压，将 php_redis.dll 和 php_igbinary.dll 拷贝至 php 的 ext 目录下，修改 php.ini，在该文件中加入 123; php_redis extension=php_igbinary.dll extension=php_redis.dll 3. 下载 redis 的 Windows server下载地址 下载，解压后得到文件夹重命名为 redis 并将得到的文件夹移动到任意你想放置的位置打开一个 cmd 窗口 使用 cd 命令切换目录到 redis 目录下运行 redis-server.exe redis.windows.conf 得到上图信息则说明安装成功，若出现错误提示请按照提示信息自行百度解决或再文章下留言我看到后会第一时间回复 但是问题又来了，关闭 cmd 窗口就会关闭 Redis，难道要一直开着吗？这显然是不科学的，下面看怎么在设置为自动运行： 1234# 将 redis 设置为开机自动运行redis-server --service-install redis.windows.conf# 设置完成后运行 redisredis-server --service-start 推荐一个可视化工具 Redis Desktop Manager 4. ThinkPHP5 配置 redis 缓存在 ThinkPHP5 中 config.php 修改缓存方式为 redis 使用方法参考 ThinkPHP5 开发手册缓存说明 以上，就完成了 Windows 下 ThinkPHP5 配置 redis 缓存 溜了溜了，接着去开发了…","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://wiki.blanc.site/tags/ThinkPHP/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"ThinkPHP","slug":"2-软件使用/ThinkPHP","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ThinkPHP/"}]},{"title":"新部署一台Linux云服务器时常用的命令","date":"2018-05-12T00:00:00.000Z","path":"archives/e94a0a36.html","text":"每次部署新的云服务器总是会进行一些流程化的东西，现在还不会写脚本所以只能一个一个的码命令，但是有些命令很少会用到所以每次都要去查一遍，干脆就搬运到自己的博客里以供下次使用。 根据一下命令可以进行的操作：拿到新服务器 -&gt; SSH 远程连接 root -&gt; 新建一个用户组 -&gt; 新建一个用户并添加到新建的用户组 -&gt; 设置新用户密码 -&gt; 添加新用户到 sudoer -&gt; 开启一个随机端口号 -&gt; 重启防火墙- &gt; 修改 SSH 登陆端口号为随机端口号 -&gt; 重启 SSH firewall 命令 作用 firewall-cmd --state 查看防火墙状态，是否是 running firewall-cmd --reload 重新载入配置，比如添加规则之后，需要执行此命令 firewall-cmd --get-zones 列出支持的 zone firewall-cmd --get-services 列出支持的服务，在列表中的服务是放行的 firewall-cmd --query-service ftp 查看 FTP 服务是否支持，返回 yes 或者 no firewall-cmd --add-service=ftp 临时开放 FTP 服务 firewall-cmd --add-service=ftp --permanent 永久开放 FTP 服务 firewall-cmd --remove-service=ftp --permanent 永久移除 FTP 服务 firewall-cmd --add-port=80/tcp --permanent 永久添加 80 端口 iptables -L -n 查看规则，这个命令是和 iptables 的相同的 man firewall-cmd 查看帮助 linux创建用户（组）并设置密码添加用户：useradd -m username设置密码 ：passwd username删除用户：userdel -r username添加用户组：groupadd testgroup删除用户组：groupdel testgroup Linux给用户添加 sudo 权限123/etc/sudoers找到：\"root ALL=(ALL) ALL\"在下面添加\"xxx ALL=(ALL) ALL\"(xxx是用户名)，保存。 修改默认 SSH 端口123vim /etc/ssh/sshd_config# 修改 Port 为想要设置的端口systemctl restart sshd 设置 SSH 不自动断开连接1234567vim /etc/ssh/sshd_config# 修改两处的值为：ClientAliveInterval 60 # 每隔多少秒服务器端向客户端发送心跳ClientAliveCountMax 10 # 多少次心跳无响应之后认为 Client 断开# 使修改的ssh配置文件生效：systemctl restart sshd","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wiki.blanc.site/tags/Linux/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"「转载」PHP 常用缓存技术的总结","date":"2018-05-12T00:00:00.000Z","path":"archives/60232ab3.html","text":"1、全页面静态化缓存：将页面全部生成为 HTML 静态页面，用户访问时直接访问静态页面，不走 PHP 服务器的解析流程。此种方式在 CMS 系统中比较常见，如 dedecms。实现方法：输出缓存 操作 效果 ob_start() 打开“输出控制缓冲” some code 要运行的代码 $content = ob_get_contents() 返回“输出缓冲区的内容” some code 使用 file_put_contents() 等函数将返回的数据写入 HTML 文件 ob_clearn() 清空“输出缓冲区” 2、页面部分缓存：将页面中不常变动的部分进行静态化缓存，而经常变化的部分不缓存，最后组装在一起显示；可以使用类似 ob_get_contents() 的方式实现，也可以利用类似 ESI 之类的页面片段缓存策略，使其用来做动态页面中相对静态的片段部分的缓存。该缓存方式常用与商城中的商品页。 3、数据缓存：缓存数据的一种方式。比如，商城中的某个商品信息，当用商品 ID 去请求时，就会得出包括店铺信息、商品信息等数据，此时就可以将这些 数据缓存到一个 PHP 文件中，文件名包含商品 ID 来建一个唯一标示；下一次有人想查看这个商品时，首先就直接调这个文件里面的信息，而不用再去数据库查 询；其实缓存文件中缓存的就是一个 PHP 数组之类；Ecmall 商城系统里面就用了这种方式； 4、查询缓存：根据查询来进行缓存。将查询得到的数据缓存在一个文件中，下次遇到相同的查询时，就直接先从这个文件里面调数据，不再去查数据库；但此处的缓存文件名可能就需要以查询语句为基点来建立唯一标示。 注意：以上几种缓存方式都需要对缓存的文件设置一个有效时间，在这个时间内，相同的访问会先取缓存文件的内容，超过有效时间后就重新从数据库中获取数据，并生成新的缓存文件。 5、内存式缓存：使用 Redis、Memcached 等 NoSQL 数据库设置 PHP 缓存，通过缓存查询结果，来减少数据库的访问次数，从而提高网站的响应速度。 6、Apache 缓存模块： Apache 安装完以后，是不允许被 cache 的。如果外接了cache 或 squid 服务器要求进行 Web 加速的话，就需要在 htttpd.conf 里进行设置，当然前提是在安装 Apache 的时候要激活 mod_cache 的模块。安装 apache 时：./configure –enable-cache –enable-disk-cache –enable-mem-cache 7、PHP APC 缓存扩展：使用 PHP 中的 APC 扩展来进行缓存 8、Opcode：首先 PHP 代码被解析为 Tokens ，然后再编译为 Opcode 码，最后执行 Opcode 码，返回结果；所以，对于相同的 PHP 文件，第一次运行时 可以缓存其 Opcode 码，下次再执行这个页面时，直接会去找到缓存下的 Opcode 码，直接执行最后一步，而不再需要中间的步骤了。比较知名的是 XCache,Turck MM Cache ,PHP Accelerator 等。关于 PHP Opcode，鸟哥的博客中有一篇详解：http://www.laruence.com/2008/06/18/221.html 原文地址","tags":[],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"PHP","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/PHP","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/PHP/"}]},{"title":"ThinkPHP5 下商城类微信小程序下单 + 支付开发流程图","date":"2018-04-25T00:00:00.000Z","path":"archives/7d2dd65c.html","text":"最近在跟着视频模仿着用 ThinkPHP5 框架写小程序，眼看支付逻辑快写完了，回过头一想啥都没记住，所以就比照着代码画了了流程图，方便之后回顾，也给想要开发的同类产品的人一个参考。 下单流程 支付流程 微信回调流程 综合","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://wiki.blanc.site/tags/ThinkPHP/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"ThinkPHP","slug":"2-软件使用/ThinkPHP","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ThinkPHP/"}]},{"title":"解决 TP5 无法接收客户端 Post 传递的 Json 参数","date":"2018-04-23T00:00:00.000Z","path":"archives/87acc549.html","text":"ThinkPHP 版本： 5.0.16 这段时间在学习 API 开发，从网上搞了一个课程在跟着做，就在昨天我又一次碰到了讲师一路畅通我半天调试的情况，遇到的问题是我用 Postman 测试 API 某 Post 接口的时候无论怎么发送请求总是提示我参数验证失败，在我调试的过程中某次采用通过 Body 表传递参数的方法，API 神奇地通了，于是我判断是之前 Json 传递出了问题，就各种在网上搜，然而并没有解决方法[不过 Get 了两个知识点放在文章结尾处]。 关于 ThinkPHP5 的问题度娘不行就只能查源代码了，于是乎我就跟着错误一点一点的打断点终于被我发现了问题所在： 原来 ThinkPHP5 是通过 strpos 函数在 Header 的 content-type 值中查找 app/json 字符串，也就是说你必须设置 Header 的 content-type 值为 app/json 才行，否则 ThinkPHP5 不会认为你传入的是 Json 参数并给 Request::post 设值为空。 以上就解决了 ThinkPHP5 无法接收 客户端 Post 传递的 Json 参数的问题。 两个知识点： content-type 为 &quot;application/json&quot; 的数据 PHP 是不能直接识别的，所以导致 $_POST 数组为空。解决办法：我们只要用 $GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;] 把原始数据取出来，然后再 json_decode 就行了[使用此方法，需要设置 php.ini 中的always_populate_raw_post_data 值为 $HTTP_RAW_POST_DATA ，包含了 POST 的原始数据。但这不是一个超全局变量，要在函数中使用它，必须声明为 global ，或使用 $GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;] 代替。； 可以通过 file_get_contents(&#39;php://input&#39;) 代替上面的方法直接获取到传入的 Json 参数[我在阅读 ThinkPHP5 源码的时候发现他们也是用这个方法来获取的初始值]。","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://wiki.blanc.site/tags/ThinkPHP/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"ThinkPHP","slug":"2-软件使用/ThinkPHP","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ThinkPHP/"}]},{"title":"VS Code + PHPStudy 断点调试 PHP","date":"2018-04-03T00:00:00.000Z","path":"archives/a29d84d8.html","text":"最近可利用时间比较少，加上团队项目重新开发[没错之前的网站白做了，所以主题开发就鸽了… 目前正在尝试做三端分离的小程序开发[借鉴慕课网某课程需要的可以找我要]，讲师“嘴欠”非得讲什么断点调试，我这个敲代码至今没调试过代码的人也是突然燃起了兴趣，就跟着设置了一下，仍然是常见的软件不匹配问题：就是讲师叭叭叭三两句话弄好了我这边还没开始… 经过度娘的一番调教大概弄懂了具体操作流程了，本次教程以 VS Code + PHPStudy 为例，但适用于所有可以进行 PHP 断点调试的编程软件： 打开 phpinfo 查看是否安装了 XDebug PHP 插件[ PHPStudy 一般是不自带或者不自动开启的] 若没有安装，点击这里，然后将你的 phpinfo 页面源码复制进输入框，让网站帮你查找适合你版本的插件[我当时搜索的时候提示的是只支持 PHP 7.0 以上的版本，不晓得是不是我老花眼…] 按照网站给出的提示把插件移动到对应的文件夹，并且修改 PHP 的配置文件[php.ini] 操作如图： 把下面这两句也写进 php.ini 文件[作用是开启远程调试] 12xdebug.remote_enable = 1xdebug.remote_autostart = 1 重启 Apache 服务器[到此 PHP 就设置好了] 打开 VS Code 下载 PHP Debug、PHP Extension Pack、PHP IntelliSense 三个插件 打开 VS Code 设置文件设置 PHP 路径，如图： 重启 VS Code 随便打开一个 PHP 文件按 F5 开始调试","tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://wiki.blanc.site/tags/VSCode/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"VSCode","slug":"2-软件使用/VSCode","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/VSCode/"}]},{"title":"「转载」同步和异步的区别","date":"2018-03-31T00:00:00.000Z","path":"archives/f63c0d8d.html","text":"原文：我带你们打-知乎-什么是阻塞，非阻塞，同步，异步？ 老张爱喝茶，废话不说，煮开水。出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。1 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~的噪音。3 老张把响水壶放到火上，立等水开。（异步阻塞）老张觉得这样傻等意义不大4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。 所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。 所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。","tags":[{"name":"转载","slug":"转载","permalink":"https://wiki.blanc.site/tags/%E8%BD%AC%E8%BD%BD/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"ThinkPHP5 的 Nginx 配置","date":"2018-03-05T00:00:00.000Z","path":"archives/71825b94.html","text":"1. 为什么要配置 Nginx？因为 ThinkPHP5 采用了路由系统，而默认配置的 Nginx 无法识别 ThinkPHP5 产生的 URL 导致 404，另外有时候我们需要隐藏 ThinkPHP 的入口文件； 2. 主要修改 Nginx 配置文件的哪几个点？我们主要修改配置文件中 server {} 中的三处地方： 首先在 server_name 下设置 $root 变量：set $root /app/www/mydomain.vm/public;; 然后再 location / {} 中修改 root 并添加正则匹配规则; 最后设置 location ~ .+\\.php($|/) {} 使网站解析 PHP 文件并识别 ThinkPHP5 路由产生的 URL ； 3. 具体配置文件如下：在配置中我们默认： 配置文件使用 vhost 方式，如果单主机的酌情修改； 假定配置的域名是 mydomain.vm； 假定用户使用的是 Linux 操作系统； 假定项目文件部署在 /app/www/mydomain.vm 目录下； 假定 Nginx 的日志放在 /app/logs/nginx 目录下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; server_name mydomain.vm www.mydomain.vm; # 设置服务器名称[推荐保持默认设置] access_log &#x2F;app&#x2F;logs&#x2F;nginx&#x2F;mydomain_access.log; # 设置Nginx运行日志位置[推荐保持默认设置] error_log &#x2F;app&#x2F;logs&#x2F;nginx&#x2F;mydomain_error.log; # 设置Nginx错误日志位置[推荐保持默认设置] set $root &#x2F;app&#x2F;www&#x2F;mydomain.vm&#x2F;public; # 设置Nginx解析根目录[即网站根目录，这里一般设置为ThinkPHP5的入口文件目录] location ~ .*\\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123; root $root; &#125; location &#x2F; &#123; root $root; index index.html index.php; if ( -f $request_filename) &#123; # 设置正则匹配规则隐藏入口文件 break; &#125; if ( !-e $request_filename) &#123; rewrite ^(.*)$ &#x2F;index.php&#x2F;$1 last; break; &#125; &#125; location ~ .+\\.php($|&#x2F;) &#123; # 这个地方一定注意，我们修改了原先的php文件匹配规则 set $script $uri; # 以下为设置 Ngxin 识别 ThinkPHP5 路由产生的 url set $path_info &quot;&quot;; if ($uri ~ &quot;^(.+\\.php)(&#x2F;.+)&quot;) &#123; set $script $1; set $path_info $2; &#125; fastcgi_pass 127.0.0.1:9000; # 设置为 php-fpm 运行端口，让 php-fpm 解析 php 文件 fastcgi_index index.php?IF_REWRITE&#x3D;1; # 下面这些设置具体是做什么的我也不太清楚不过为必须设置不可省略 fastcgi_param PATH_INFO $path_info; fastcgi_param SCRIPT_FILENAME $root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $script; include fastcgi_params; &#125;&#125; 修改完配置文件之后记得重启一下 Nginx。","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://wiki.blanc.site/tags/ThinkPHP/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"ThinkPHP5 静态资源[CSS , JS , img]加载","date":"2018-03-05T00:00:00.000Z","path":"archives/d9089534.html","text":"说起这个静态资源加载可真的是一把心酸泪呀，各种路径问题[绝对、相对]，还有前段时间写 WordPress 主题也是，需要通过各种内置钩子或函数模版来解决路径问题； 解决 ThinkPHP5 的 CSS , JS 静态资源加载我采用的是官方手册给出的视图模版函数 {load href=&quot;/...&quot; /} 在视图模版中引入此函数并设置静态资源位置，函数会自动识别引入文件是 CSS 文件还是 JS 文件从而选择不同的引入方式；官方手册本章节地址 注意 href=&quot;/...&quot; 中 / 指的是 public 目录 [即入口目录] 解决 ThinkPHP5 的其他静态资源[图片等]加载我采用的是设置视图输出字符串内容替换，即修改 app/config.php 下的 view_replace_strview_replace_str 具体修改方法请参考：官方手册本章节地址","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://wiki.blanc.site/tags/ThinkPHP/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"ThinkPHP","slug":"2-软件使用/ThinkPHP","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ThinkPHP/"}]},{"title":"CentOS7 下配置 Nginx + PHP7 + MariaDB + ThinkPHP5.1","date":"2018-02-21T00:00:00.000Z","path":"archives/ff98c7a2.html","text":"最近突然想学习一下使用一些比较成熟的后台框架，考虑到之前帮大佬打下手的时候用过 ThinkPHP 所以就暂定了以 ThinkPHP 为主要学习目标。 下面是我在服务器端配置 ThinkPHP 所需环境而踩的一些坑（且有很多已经是老坑了）： 本次配置选择的服务器系统为 Centos7 环境是 Nginx + PHP7 + MariaDB + ThinkPHP5.1 我会按照我个人认为合适的顺序分别介绍他们的安装与配置过程 1. MariaDB 的安装与初始配置123456789101112131415161718192021222324252627# yum 安装yum -y install mariadb mariadb-server# 安装完成MariaDB，首先启动MariaDBsystemctl start mariadb# 设置开机启动systemctl enable mariadb# 接下来进行MariaDB的相关简单配置mysql_secure_installation#首先是设置密码，会提示先输入密码Enter current password for root (enter for none):# 初次运行直接回车#设置密码Set root password? [Y/n] # 是否设置root用户密码，输入y并回车或直接回车New password: # 设置root用户的密码Re-enter new password: # 再输入一次你设置的密码#其他配置Remove anonymous users? [Y/n] # 是否删除匿名用户Disallow root login remotely? [Y/n] #是否禁止root远程登录Remove test database and access to it? [Y/n] # 是否删除test数据库Reload privilege tables now? [Y/n] # 是否重新加载权限表#初始化MariaDB完成，接下来测试登录mysql -uroot -ppassword 2. PHP7 + PHP-FPM 安装123456789101112131415161718192021222324# 在 CentOS 7 通过 yum 安装 PHP 7，首先在终端运行：rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm# 提示错误：error: Failed dependencies:epel-release &gt;= 7 is needed by webtatic-release-7-3.noarch# 需要先安装 epel-release。yum -y install epel-release # 再安装 PHP 7rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm # 获取 PHP 7 的 yum 源yum install php70w php70w-fpm# 验证安装PHP -v，# 显示当前 PHP 版本，信息如下：[root@Ryoma /]# php -vPHP 7.0.18 (cli) (built: Apr 15 2017 07:09:11) ( NTS )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies# 这样就在 CentOS 7 下通过 yum 安装成功 PHP 7. 3. 编译安装 Nginx 并配置 PHP12345678910111213141516171819202122232425262728293031323334353637383940414243444546# [必须]安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：yum install gcc-c++# [必须]PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：yum install -y pcre pcre-devel# [自选]zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。yum install -y zlib zlib-devel# [自选]nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。yum install -y openssl openssl-devel# 官网下载 Ngxin# 直接下载.tar.gz安装包，地址：https://nginx.org/en/download.html# 推荐选择稳定版下载 ： 当前版本 1.12.2# 下载链接： https://nginx.org/download/nginx-1.12.2.tar.gzwget -c https://nginx.org/download/nginx-1.12.2.tar.gz# 解压 用到了之前下载的zlib库 若没下载可选择其他方式解压tar -zxvf nginx-1.12.2.tar.gz# 编译前初始化配置cd nginx-1.12.2 # 进入nginx目录./configure # 使用默认配置# 编译安装makemake install# 查找安装路径[root@Ryoma nginx-1.12.2]#whereis nginxnginx: /usr/local/nginx# 启动、停止 nginxcd /usr/local/nginx/sbin/ # 进入 nginx sbin 目录./nginx # 启动 nginx./nginx -s quit # 此方式停止步骤是待 nginx 进程处理任务完毕进行停止./nginx -s stop # 此方式相当于先查出 nginx 进程id再使用kill命令强制杀掉进程./nginx -s reload # 重新加载#查询 nginx 进程：ps aux|grep nginx# 配置 nginxvim /usr/local/nginx/conf/nginx.conf# 个人配置图如下 4. 安装 ThinkPHP51234567# 全局安装 composercurl -sS https://getcomposer.org/installer | phpmv composer.phar /usr/local/bin/composer# tp5 5.1 版本安装composer create-project topthink/think tp5 --prefer-dist# PHP 版本低于 5.6 的话 将仍然安装 5.0 版本","tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://wiki.blanc.site/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://wiki.blanc.site/tags/ThinkPHP/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"固定一个 div 在另一个 div 的底部","date":"2018-01-27T00:00:00.000Z","path":"archives/c0d98826.html","text":"123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;style&gt; .big&#123; width:20%; height:100%; float:left; position:relative; &#125; .small&#123; width:100%; position:absolute; bottom:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"big\"&gt; &lt;div class=\"small\"&gt;我在底部&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果要始终固定在页面底部，那么就需要使用：position：fixed","tags":[],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"HTML","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/HTML","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/HTML/"}]},{"title":"利用 position + rgba 将 HTML 背景灰化","date":"2018-01-20T00:00:00.000Z","path":"archives/8b008844.html","text":"最近正在摸索着写自己的第一个主题，在 Copy 大佬页面设计的时候发现虽然用了同一张图做背景我 Copy 出来的页面却显得很不协调： 很明显我临摹的作品背景偏亮，使得副标题显示的很模糊，因此我断定是我临摹过程中漏掉了一个步骤[然而具体是什么步骤就不得而知了]，经过我一顿百度摸索发现可以在背景上面再加一层纯色蒙版然后调整蒙版不透明度即可： 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ceshi&lt;/title&gt; &lt;style type=\"text/css\"&gt; .top &#123; /*根据需求设置宽和高*/ width: 500px; height: 500px; /*相对定位*/ position: relative; /*利用 rgba 设置背景色 前三个数字决定颜色，最后一个数字代表不透明度，1为完全不透明*/ background-color: rgba(19,18,16,0.5); &#125; .down &#123; /*设置背景图片*/ background-image: url(img/banner.png); /*设置绝对定位*/ position: absolute; top: 0px; bottom: 0; left: 0; right: 0; /*将背景置于底层*/ z-index: -1; /*自适应分辨率*/ background-position: center center; background-size: cover; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"top\"&gt; /*蒙版区*/ &lt;/div&gt; &lt;div class=\"down\"&gt; /*背景图存放区*/ &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","tags":[],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"HTML","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/HTML","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/HTML/"}]},{"title":"Linux 下安装 Node.js","date":"2017-12-11T00:00:00.000Z","path":"archives/6bfb5db9.html","text":"1. 选择合适的 Node.js 安装包从 Node.js官网 给出的列表中挑选适合的版本和安装包并复制下载链接 以 64 位 v9.2.1 版本为例： 下载地址 2. 安装以 64 位 v9.2.1 版本的为例 进入到命令行： 12345678910111213141516171819202122232425262728# 进入到用户目录下cd ~ # 下载选好的node压缩包wget https://nodejs.org/dist/v9.2.1/node-v9.2.1-linux-x64.tar.xz # 等待下载完成后解压安装包，因为我下载的安装包是两层压缩所以要解压两次xz -d node-v9.2.1-linux-x64.tar.xz # 解压后得到node-v9.2.1-linux-x64.tartar -xf node-v9.2.1-linux-x64.tar # 解压后得到node-v9.2.1-linux-x64 # 将node文件转移到/usr/local/node目录下mv node-v9.2.1-linux-x64 /usr/local/node # 配置环境变量vi /etc/profile # 在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL前插入如下代码：export NODE_HOME=/usr/local/nodeexport PATH=$NODE_HOME/bin:$PATH# 注意等号两遍不要有空格 # 完成后退出重启profilesource /etc/profile 3. 安装成功测试123# 至此 nodejs 就安装完成了，可以输入命令查看 node 版本node -v# 若安装成功会显示 V9.2.1","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wiki.blanc.site/tags/Linux/"},{"name":"Node.js","slug":"Node-js","permalink":"https://wiki.blanc.site/tags/Node-js/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Nginx rtmp 模块配合 OBS 推流实现直播(监控)功能","date":"2017-12-11T00:00:00.000Z","path":"archives/3f439512.html","text":"写的有点仓促，有问题的话可以随时留言。 客户端环境：系统：WIN 10推流软件：OBS StudioPC测试浏览器：ChromeAndroid 测试浏览器：QQ 内置 服务器环境：系统：Centos 7代理：Nginx（ http+rtmp )浏览器播放器：ckplayer 1. 安装 Nginx具体过程参考 Centos 7 下配置 Nginx… 2. 安装编译 rtmp 模块12345678910# 下载 rtmp 模块压缩包(最好和 Nginx 的安装包在同一目录下)wget https://github.com/arut/nginx-rtmp-module/archive/master.zip# 解压unzip nginx-rtmp-module-master.zip# 得到 nginx-rtmp-module-master# 进入 Nginx 安装包文件夹cd nginx-1.12.2# 编译安装 rtmp./configure --add-module=/root/nginx-rtmp-module &amp;&amp; make &amp;&amp; make install# 注意将 /root/nginx-rtmp-module 替换成你 rtmp 包所在的位置 3. 配置 Nginx 的 rtmp 和 http 模块在 Nginx 配置目录（一般为：usr/local/nginx/conf）下编辑 live_rtmp.conf 文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#user nobody;worker_processes 1;error_log logs&#x2F;error.log;error_log logs&#x2F;error.log notice;error_log logs&#x2F;error.log info;#pid logs&#x2F;nginx.pid;events &#123; worker_connections 1024;&#125;rtmp &#123; server &#123; listen 1935; chunk_size 4000; application mylive &#123; live on; record all; record_path &#x2F;home&#x2F;live_record; record_max_size 200M; hls on; # 注意此地址设置，hls_path 代表 hls 目录及.m3u8文件的保存目录 hls_path &#x2F;var&#x2F;www&#x2F;html&#x2F;hls; hls_fragment 1s; hls_playlist_length 5; allow play all; &#125; &#125;&#125;http &#123; server &#123; listen 8080; location &#x2F;stat &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location &#x2F;stat.xsl &#123; # Copy stat.xsl wherever you want # and put the full directory path here root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;; &#125; location &#x2F;hls &#123; # Serve HLS fragments types &#123; application&#x2F;vnd.apple.mpegurl m3u8; video&#x2F;mp2t ts; &#125; root &#x2F;var&#x2F;www&#x2F;html&#x2F;hls; add_header Cache-Control no-cache; &#125; # http 根目录 location &#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;html; &#125; &#125;&#125; 验证配置文件正确性：1/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/live_rtmp.conf 配置文件说明： hls 开启后产生的 m3u8 文件会存在 hls_path 下，播放端调用 404 的时候先去看看 m3u8 有没有生成。 stat.xsl 要从 nginx-rtmp 的源代码根目录中考出来，考到配置的那个文件夹。 4. 启动 Nginx1/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/live_rtmp.conf 推流地址： rtmp://服务器ip/mylive/xxxxx播放地址： rtmp://服务器ip/mylive/xxxxxhls 地址： http://服务器ip:8080/hls/xxxxx.m3u8状态查看地址： http://服务器ip:8080/statxxxx 代表你在 OBS 设置的流名称 5. 客户端下载并配置 OBS下载地址：OBS官网 6. 下载配置 ckplayer rtmp 浏览器播放器下载地址：clpalyer 官网 下载后找到最里层的 ckplayer 文件夹通过 FTP 上传到服务器(或直接 wget 下载) http 根目录下。 按照 官网示例 编辑一个 index.html 文件放在刚刚上传的 ckplayer 目录下。 7. 开启 OBS 推流访问网页查看直播(监控)访问 http://服务器ip:8080/ckplayer/index.html即可查看推流情况（贴图看疗效）理论上服务器带宽越高，推流的 FPS 越小你的直播越流畅","tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://wiki.blanc.site/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"Nginx","slug":"Nginx","permalink":"https://wiki.blanc.site/tags/Nginx/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"WordPress 配置七牛云 CDN 具体操作","date":"2017-11-29T00:00:00.000Z","path":"archives/6ec97606.html","text":"1. 前言前段时间突发奇想把原先挂在 Coding 上的 Hexo 博客迁到 WordPress 上了，反正阿里云送的服务器闲着也是闲着，于是就搭了一个 WordPress 博客，这个过程中遇到了好多坑，有的坑甚至折磨了我一个多星期，本着先照顾自己再关心大众的理念，我打算在我解决这些坑之后留下排坑博文，一来万一以后健忘的我又遇到了类似问题可以有所参考，二来也为之后遇到同类坑的朋友们提供排坑方法，话不多说，本篇博文将具体的讲解 WordPress 配置七牛云 CDN 的具体操作。 注：默认读者懂得基本的 FTP、WordPress 后台管理、域名解析等基本操作。 2. 前期准备 认证了的七牛云账号一枚 国内已经备案完成的域名一枚 已经搭建好的 WordPress 博客平台一个 带上脑子我们出发了…… 3. 七牛云端设置流程在为 WordPress 配置 CDN 之前我们先需要在七牛云端进行储存空间的基本设置： 3.1 新建储存空间 3.2 绑定域名 3.3 域名解析 3.4 等待添加成功提示 3.5 设置镜像源 3.6 七牛云端设置完毕，跳转到 WordPress 后台4. WordPress 后台设置流程4.1 安装插件搜索并安装图示两个插件，根据需求启动 WPJAM BASIC 插件中你需要的功能，不要忘记开启七牛云镜像云储存，下图为我的配置目录： 4.2 配置插件 4.3 等待设置后请等待约 30分钟 后刷新博客，查看网页源码即可发现，网站中的 JS、CSS 和图片的 URL 都转到你设置的 CDN 上了，如图： 4.4 设置成功","tags":[{"name":"WordPress","slug":"WordPress","permalink":"https://wiki.blanc.site/tags/WordPress/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"WordPress","slug":"2-软件使用/WordPress","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/WordPress/"}]},{"title":"影梭（Shadowsocks）服务端安装、配置及多用户","date":"2017-10-23T00:00:00.000Z","path":"archives/7f71ea0e.html","text":"1. 前记最近由于某些不可抗力，墙变得格外的高，蓝灯、萤火虫等免费翻墙软件间歇性崩溃，最后我实在受不了了就直接自己搭了一个影梭服务端，写下这篇博文记录搭建过程和自己走过的一些坑。 2. 服务器选择学生党，所以去博客：VPS侦探 找了一个性价比比较高的 VULTR，最低配置 &#36;2.5（折合人民币差不多 ￥20），支持支付宝所以不用担心支付问题，但是比较坑的是充值 &#36;10 起充，不过先存着也没坏处。 节点的话我搜了一下网上推荐洛杉矶，我手快买了一个迈阿密的用起来感觉也不慢。 3. SSH 搭建服务端不懂的同学直接略过概念按照步骤走就行了： 1. 下载一个 SSH 登录器，我用的是 Xshell，官网可免费下载2. 用 Xshell 登陆 3. 检查下 Python 版本，要有 2.6 or 2.74. 安装 pip5. 安装影梭服务端1pip install shadowsocks 6. 建立并完善影梭配置文件12vi /etc/shadowsocks.json# 然后按 i 进入插入模式，输入以下内容： 123456789101112131415&#123; \"server\":\"my_server_ip\"， \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"port_password\":&#123; \"8391\": \"password1\", \"8392\": \"password2\", \"8393\": \"password3\", \"8394\": \"password4\"&#125;, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false&#125; 配置文件为 json 格式，每一项后面有一个逗号不要忘记！如果格式错误，试试手动输入。 123456789101112配置相关说明：server: the address your server listens（服务器IP）local_address: the address your local listens（本地代理地址）local_port: local port（本地代理端口）port_password: password used for encryption(自己设定的服务器端口和密码)timeout: in seconds（超时断开，以秒为单位）method: default: “aes-256-cfb”, see Encryption（加密方式）fast_open: use TCP_FASTOPEN, true &#x2F; false（是否使用TCP）输入完毕之后按 Esc 退出编辑模式，接着按 shift+: 进入命令模式，最后输入 wq 保存并退出。 配置完毕。 7. 启动影梭1234567前端启动（不推荐）:ssserver -c /etc/shadowsocks.json后端启动（推荐）：开始：ssserver -c /etc/shadowsocks.json -d start结束：ssserver -c /etc/shadowsocks.json -d stop 8. 设置开机启动1234vi /etc/rc.local# 然后将里面的最后带有ssserver的删除（双击字母d注释掉），然后加入/usr/bin/ssserver -c /etc/shadowsocks.json -d start# 再:wq保存退出。 4. 客户端下载和使用各系统下载地址：shadowsocks Clients 5. Windows 详细配置","tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://wiki.blanc.site/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Python + OpenCV 图像处理-1","date":"2017-09-16T00:00:00.000Z","path":"archives/19ed6e31.html","text":"1. 读取、写入和展示图片1.1 图像读入：cv2.imread()使用函数 cv2.imread() 读入图像。这幅图像应该在此程序的工作路径，或者给函数提供完整路径，第二个参数是要告诉函数应该如何读取这幅图片。 cv2.IMREAD_COLOR：读入一副彩色图像。图像的透明度会被忽略，这是默认参数。 cv2.IMREAD_GRAYSCALE：以灰度模式读入图像 PS：调用 OpenCV，就算图像的路径是错的，OpenCV 也不会提醒你的，但是当你使用命令 print img 时得到的结果是 None。 代码示例： 12345# -*- coding: utf-8 -*-import cv2# 灰度图模式加载一副彩图img = cv2.imread('lena.jpg',0) 1.2 图像显示：cv2.imshow()使用函数 cv2.imshow() 显示图像。窗口会自动调整为图像大小。第一个参数是窗口的名字，其次才是我们的图像。你可以创建多个窗口，只要你喜欢，但是必须给他们不同的名字。 代码示例： 123456789101112131415161718cv2.imshow('image',img)cv2.waitKey(0)\"\"\"cv2.waitKey() 是一个键盘绑定函数。需要指出的是它的时间尺度是毫秒级。函数等待特定的几毫秒，看是否有键盘输入。特定的几毫秒之内，如果按下任意键，这个函数会返回按键的ASCII 码值，程序将会继续运行。如果没有键盘输入，返回值为-1，如果我们设置这个函数的参数为0，那它将会无限期的等待键盘输入。它也可以被用来检测特定键是否被按下，例如按键a 是否被按下，这个后面我们会接着讨论。\"\"\"cv2.destroyAllWindows()\"\"\"cv2.destroyAllWindows() 可以轻易删除任何我们建立的窗口。如果你想删除特定的窗口可以使用cv2.destroyWindow()，在括号内输入你想删除的窗口名。\"\"\" 1.3 图像保存：cv2.imwrite()代码示例： 12# 图像名 要保存的句柄cv2.imwrite('lena.png',img) 2. 调用摄像头拍照代码示例： 1234567891011121314151617import cv2 # 引入opencv cap = cv2.VideoCapture(0) # 创建摄像头句柄，打开摄像头while(1): # 读取摄像头资源 ret, frame = cap.read() # 展示读取到的摄像头图像 cv2.imshow(\"capture\", frame) # 判断当键盘输入Q时 #waitKey()函数的功能是不断刷新图像，频率时间为delay，单位为ms。 #返回值为当前键盘按键值。 if cv2.waitKey(1) &amp; 0xFF == ord('q'): # 保存当前时刻的照片到指定路径 cv2.imwrite(\"/pant/name.jpg\", frame) breakcap.release() # 清空摄像头资源cv2.destroyAllWindows() # 销毁窗口 3. 调用摄像头录制视频代码示例： 123456789101112131415161718192021222324252627282930313233343536# coding:utf-8import cv2import sys reload(sys) # 重新导入sys来设置系统编码.sys.setdefaultencoding('utf8') cap = cv2.VideoCapture(0) # 创建一个摄像头句柄，开启摄像头cap.set(3,640)cap.set(4,480)cap.set(1, 10.0) # 第一个参数：视频保存路径# 第二个参数：视频编码模式，-1表示自己选择# 第三个参数：镜头快慢# 第四个参数：视频窗口大小out = cv2.VideoWriter('/path/output.avi',-1,10,(640,480)) # 展示视频窗口while True: # cap.read()返回了一个元组，分别用ret和frame接收 ret,frame = cap.read() if ret == True: frame = cv2.flip(frame, 1) a = out.write(frame) cv2.imshow(\"frame\", frame) # 接受键盘输入，若输入q则终止程序 if cv2.waitKey(1) &amp; 0xFF == ord('q'): break else: break # 释放资源，销毁窗口cap.release()out.release()cv2.destroyAllWindows()","tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://wiki.blanc.site/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Python","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Python","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Python/"}]},{"title":"Web 安全学习笔记","date":"2017-09-15T00:00:00.000Z","path":"archives/7cd2d86d.html","text":"1. URL 2. HTTP 协议2.1 什么是 HTTP 2.2 HTTP 的工作原理 2.3 HTTP 报文 2.4 什么是 Cookies 2.5 HTTP 请求方式 2.6 Referer 请求的功能 2.7 HTTP 状态码、Set-Cookies","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wiki.blanc.site/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"计算机安全","slug":"计算机安全","permalink":"https://wiki.blanc.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Fatal error in launcher：Unable to create process using '\"'","date":"2017-09-09T00:00:00.000Z","path":"archives/50486745.html","text":"Windows 下同时存在 Python2 和 Python3 使用 pip 时系统报错：Fatal error in launcher: Unable to create process using &#39;&quot;&#39; 的解决方案 Windows 下 Python3 和 Python2 共存环境 用 pip 安装一个包执行 pip2 install xxx 的时候报错 1Fatal error in launcher: Unable to create process using &#39;&quot;&#39; 执行 pip3 install xxx 的时候报同样的错误 1Fatal error in launcher: Unable to create process using &#39;&quot;&#39; 解决办法-改用如下命令： 1234# Python2 安装：python2 -m pip install XXX# Python3 安装python3 -m pip install XXX 这样就可以正常使用 pip 安装模块了","tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://wiki.blanc.site/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"Python","slug":"Python","permalink":"https://wiki.blanc.site/tags/Python/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"不翻墙下载 Chrome + 不用 VPN 上 Google","date":"2017-08-17T00:00:00.000Z","path":"archives/573af784.html","text":"如何不翻墙下载 Chrome使用 Chrome下载器 轻松下载 Chrome 百度云下载 本地下载 请注意： 本程序需要 .NET Framework 4.5 运行环境（Win8 及以后的系统自带），Win7 请点这里； 本工具作者博客&lt;-内含工具简要问答以及更新文档 工具里会有一个版本选择，若不懂如何选择请转到：解析谷歌 Chrome 各分支版本 如何不用 VPN 上 Google答案是：修改 host 文件。 但是很多小伙伴并不懂什么是 host 文件以及如何修改，因此这里提供了一个傻瓜包： 点我下载 本工具作者博客&lt;-内含工具简要问答以及更新文档","tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://wiki.blanc.site/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"「转载」解析谷歌 Chrome 各分支版本","date":"2017-08-17T00:00:00.000Z","path":"archives/decc86d5.html","text":"文章内容来自 cnBeta：解析谷歌Chrome各分支版本 网友尝试下载使用 Chrome 时，才发现 Chromium 版本众多，版本号更是一周升级一次，那些 Chromium、Dev、Beta、Stable 等名词让人很难选择到底自己适合使用哪一款。 通常来说，最早释出的是 Chromium，经过功能改进和 Bug 修复后可依次上升为 Chrome Dev、Beta，最终定格为 Chrome Stable 稳定版。 以 Chromium 5.0.375.9 为例，5.0 是指新一代浏览器版本；375 是当前代码号，推出新功能；9 则侧重于安全补丁和修复稳定性，一般不包括功能更新； 各种版本的特点：Chromium：Chromium 是谷歌浏览器开源项目，新功能会率先在 Chromium 上实现，待验证后才会应用在 Chrome 上，故 Chrome 的功能会相对落后但较稳定（实际上稳定性也差不多）； Chromium 的更新速度很快，每隔数小时即有新的开发版本。 Chrome dev：基于最新的 Chromium Build，经常每周就更新释出的功能；与 Beta 版十分相似，但稳定性较差，不适合公共使用； Chrome beta：基于 Chrome dev；按月更新；崩溃等重大故障较少发生，功能比 dev 更加完善 Chrome stable：基于最新的测试版本，已知 Bug 均被修复，功能发挥稳定；按季度更新；稳定性有很大提升，适用于各个环境； Chromium 与 Chrome 的差异主要表现在以下方面：程式图示：两者图示只在色彩上有不同，Chromium 的是天蓝色系，而 Chrome 的则是 Google 公司的代表色。 标题栏：Chromium 的标题栏无任何字样，而 Chrome 的标题栏在右侧有白色的 Google 字样。 自动更新：Chromium 不开放自动更新功能，所以无法自动更新，而 Chrome 则可自动连上 Google 的伺服器更新，但新版的推出很慢。 功能差异：如前所述，新功能会率先在 Chromium上 推出，Chrome 则会相对落後许多。","tags":[{"name":"转载","slug":"转载","permalink":"https://wiki.blanc.site/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Chrome","slug":"Chrome","permalink":"https://wiki.blanc.site/tags/Chrome/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"Chrome","slug":"2-软件使用/Chrome","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Chrome/"}]},{"title":"「转载」Git 远程仓库 pull/push 操作详解","date":"2017-08-17T00:00:00.000Z","path":"archives/6c235203.html","text":"1. 简要说明使用 git 操作远程仓库时 pull 和 push 命令机制及原理Git 其实是是一个不用网络的仓库（本地仓库），你也可以把数据 push 到 GitHub 上（远程仓库）。 你现在的 pull 和 push 都是本地版本库和远程仓库之间的数据交互 2. 组成在你的本地仓库，其实是由两部分组成： 123451. 工作区 (Working Directory) &#x2F;&#x2F;看得见的2. 版本库 (Repository) &#x2F;&#x2F;看不见的 版本库又包括： * 暂存区(Stage) * 分支 (branch) 3. 流程：3.1 初次提交： 通过 git add 将文件 工作区 —&gt;暂存区 (本地) 通过 git commit 将文件 暂存区 —&gt;分支 (本地) 通过 git push 将文件 分支 —&gt;远程库 (GitHub) 3.2 提交改动：通过 git commit 将文件 暂存区 —&gt;分支 (本地)通过 git push 将文件 分支 —&gt;远程库 (GitHub) 3.3 pull&amp;push通过 git pull 将文件 远程库 —&gt;分支 (本地)通过 git push 将文件 分支 —&gt;远程库 (GitHub) 而上面的两个操作是需要有改动，有差异才能执行。所以会提示暂存区和远程库的内容一致。 4. 原文原文地址请点这里作者信息请点这里学习Git请点这里","tags":[{"name":"Git","slug":"Git","permalink":"https://wiki.blanc.site/tags/Git/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"2-软件使用/命令行工具/Git","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/Git/"}]},{"title":"「转载」如何选择开源许可证？","date":"2017-08-15T00:00:00.000Z","path":"archives/3c798f3a.html","text":"作者： 阮一峰 原文 如何为代码选择开源许可证，这是一个问题。 世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种 GPL, BSD, MIT, Mozilla, ApacheLGPL 之中做选择，也很复杂。 乌克兰程序员 Paul Bagwell，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。 下面是我制作的中文版，请点击看大图。","tags":[{"name":"转载","slug":"转载","permalink":"https://wiki.blanc.site/tags/%E8%BD%AC%E8%BD%BD/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Sublime Text 3 安装 SVN 插件","date":"2017-08-10T00:00:00.000Z","path":"archives/59657ebc.html","text":"1. 第一步若你是第一次使用 Sublime Text 需要先安装插件管理器方法如下： 首先通过 ctrl + ~ 唤出控制台 如果你是 Sublime Text 3 将下面代码复制到窗口并按回车键运行 1import urllib.request,os,hashlib; h &#x3D; &#39;7183a2d3e96f11eeadd761d777e62404&#39; + &#39;e330c659d4bb41d3bdf022e94cab3cd0&#39;; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by &#x3D; urllib.request.urlopen( &#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh &#x3D; hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh !&#x3D; h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by) 如果你是 Sublime Text 2 将下面代码复制到窗口并按回车键运行 1import urllib2,os,hashlib; h &#x3D; &#39;7183a2d3e96f11eeadd761d777e62404&#39; + &#39;e330c659d4bb41d3bdf022e94cab3cd0&#39;; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by &#x3D; urllib2.urlopen( &#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh &#x3D; hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh &#x3D;&#x3D; h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh !&#x3D; h else &#39;Please restart Sublime Text to finish installation&#39;) 2. 第二步等待下载完成之后按组合键 CTRL + SHIFP + P 唤出命令窗口并在窗口输入 install 选择 install Package 回车，然后你会看见左下角有个 = 号在一直晃动,等待一下就会出来可以安装的包,此时你只需要输入 svn 如果你的是 Windows 的则选择(需要提前安装 TortoiseSVN，也就是我们说的小乌龟) 如果是 Linux 的则选择 SVN 此时左下角显示 Installing package TortoiseSVN 或者 Installing package SVN，下载完成之后会自动打开一个文件。 你要是默认安装的 TortoiseSVN，则不需要更改直接可以使用，要是自定义的路径，则需要手动配置 Sublime Text 的 SVN 插件路径，具体的配置文件在 Preferences（首选项）-&gt; Package Settings -&gt; TortoiseSVN -&gt; Settings -&gt; User 如我的路径是 F:\\TortoiseSvn\\bin\\TortoiseProc.exe 则在刚才打开的配置文件里边输入一下内容： 12345&#123; // Auto close update dialog when no errors, conflicts and merges \"autoCloseUpdateDialog\": false, \"tortoiseproc_path\": \"D:\\\\SVN\\\\bin\\\\TortoiseProc.exe\"&#125; 注意，目录层之间用 \\\\\\ 分割而不是 \\ 现在你在你左侧栏中右键就能看见 SVN 的操作选项了","tags":[{"name":"SublimeText","slug":"SublimeText","permalink":"https://wiki.blanc.site/tags/SublimeText/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"SublimeText","slug":"2-软件使用/SublimeText","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/SublimeText/"}]},{"title":"PHPStrom 常用快捷键汇总","date":"2017-08-09T00:00:00.000Z","path":"archives/297592c5.html","text":"PhpStorm 是 JetBrains 公司开发的一款商业的 PHP 集成开发工具，PhpStorm 可随时帮助用户对其编码进行调整，运行单元测试或者提供可视化Debug 功能。下面为大家介绍一些软件中常用的快捷键。 自定义快捷键设置快捷键：File -&gt; Settings -&gt; IDE Settings -&gt; Keymap -&gt; 选择 Eclipse -&gt; 然后 Copy 一份 -&gt; 再个性化设置（自己习惯的）快捷键 常用快捷键(keymaps:Default 情况下)F1 帮助F2（Shift+F2） 下/上高亮错误或警告快速定位F3 向下查找关键字出现位置F4 查找变量来源F5 复制文件/文件夹F6 移动文件F11 切换书签F12 返回到以前的工具窗口 注意：部分快捷键，必须在没有更改快捷键的情况下才可以使用 查询快捷键CTRL+N 查找类CTRL+SHIFT+N 查找文件，打开工程中的文件(类似于eclipse中的ctrl+shift+R)，目的是打开当前工程下任意目录的文件CTRL+SHIFT+ALT+N 查 找类中的方法或变量(JS)CIRL+B 找变量的来源，跳到变量申明处CTRL+ALT+B 找所有的子类CTRL+SHIFT+B 找变量的 类CTRL+G 定位行，跳转行CTRL+F 在当前窗口查找文本CTRL+SHIFT+F 在指定路径查找文本CTRL+R 当前窗口替换文本CTRL+SHIFT+R 在指定路径替换文本ALT+SHIFT+C 查找修改的文件，最近变更历史CTRL+E 最近打开的文件F3 查找下一个SHIFT+F3 查找上一个F4 查找变量来源CTRL+ALT+F7 选 中的字符 查找工程出现的地方ALT+F7 直接查询选中的字符Ctrl+F7 文件中查询选中字符 自动代码ALT+回车 导入包,自动修正CTRL+ALT+L 格式化代码CTRL+ALT+I 自动缩进CTRL+ALT+O 优化导入的类和包CTRL+E 最近更改的文件/代码CTRL+SHIFT+SPACE 切换窗口CTRL+SPACE 空格 代码自动完成，代码提示,一般与输入法冲突CTRL+ALT+SPACE 类 名或接口名提示（与系统冲突）CTRL+P 方法参数提示，显示默认参数CTRL+J 自动代码提示，自动补全CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里ALT+INSERT 生成代码(如GET,SET方法,构造函数等) 复制快捷方式F5 复制文件/文件夹CTRL+C 复制CTRL+V 粘贴CTRL+X 剪 切,删除行CTRL+D 复制行Ctrl + Y 删除行插入符号CTRL+SHIFT+V 可以复制多个文本 高亮CTRL+F 选中的文字,高亮显示 上下跳到下一个或者上一个F2（Shift+F2） 高亮错误或警告快速定位SHIFT+F2 高亮错误或警告快速定位CTRL+SHIFT+F7 高亮显示多个关键字. 本地历史 VCS/SVNAlt +反引号（’） 快速弹出VCS菜单Ctrl + K 提交项目VCSCtrl + T 更新项目从VCSAlt + Shift + C 查看最近发生的变化 其他快捷方式CTRL+Z 倒退(代码后悔)CTRL+SHIFT+Z 向前CTRL+H 显 示类结构图Ctrl +F12 文件结构弹出Ctrl+Shift+H 方法的层次结构Ctrl+Alt+H 呼叫层次CTRL+Q 显示代码注释CTRL+W 选中代码，连续按会 有其他效果Ctrl+Shift+W 减少当前选择到以前的状态CTRL+B 转到声明，快速打开光标处的类或方法说明注释(CTRL + 鼠标单击 也可以)CTRL+O 魔术方法CTRL+/ 注释//取消注释CTRL+SHIFT+/ 注释/…/CTRL+ [] 光标移动到 {}[]开头或结尾位置CTRL+SHIFT+[] 选中块代码，可以快速复制ctrl + ‘-/+’: 可以折叠项目中的任何代码块,包括htm中的任意nodetype=3的元素，function,或对象直接量等等。它不是选中折叠，而是自动识别折叠。ctrl + ‘.’: 折叠选中的代码的代码Ctrl+Shift+U 选中的字符大小写转换ctrl+shift+i 快速查看变量或方法定义源CTRL+ALT+F12 资源管理器打开文件夹，跳转至当前文件在磁盘上的位置ALT+F1 选择当前文件或菜单中的任何视图工具栏SHIFT+ALT+INSERT 竖编辑模式CTRL+ALT ←/→ 返回上次编辑的位置ALT+ ←/→ 切换代码视图，标签切换ALT+ ↑/↓ 在方法间快速移动定位ALT + ‘7’: 显示当前的类/函数结构。类似于eclipse中的outline的效果。试验了一下，要比aptana的给力一些，但还是不能完全显示prototype下面的方法名。SHIFT+F6 重命名,重构 当前区域内变量重命名/重构 不但可以重命名文件名，而且可以命名函数名，函数名可以搜索引用的文件，还可以重命名局部变量。还可以重命名标签名。在sublime text中有个类似的快捷键：ctrl+shift+d。 CTRL+SHIFT+ENTER (智能完善代码 如 if())CTRL+SHIFT+UP/DOWN(移动行、合并选中行，代码选中区域 向上/下移动)CTRL+UP/DOWN 光标跳转到编辑器显示区第一行或最后一行下ESC 光标返回编辑框SHIFT+ESC 光 标返回编辑框,关闭无用的窗口CTRL+F4 关闭当前的编辑器或选项卡Ctrl + Alt + V引入变量Ctrl + Alt + F 类似引入变量Ctrl + Alt + C引入常量Ctrl + Tab 键切换选项卡和工具窗口Ctrl + Shift + A 查找快捷键Alt + ＃[0-9] 打开相应的工具窗口Ctrl + Shift + F12 切换最大化编辑器Alt + Shift + F 添加到收藏夹Alt + Shift + I 检查当前文件与当前的配置文件Ctrl +反引号（`） 快速切换目前的配色/代码方案/快捷键方案/界面方案Ctrl + Alt + S 打开设置对话框（与QQ冲突） 运行Alt + Shift + F10 选择的配置和运行Alt + Shift + F9 选择配置和调试Shift + F10 运行Shift + F9调试Ctrl + Shift + F10运行范围内配置编辑器Ctrl + Shift + X运行命令行 调试F8步过F7步入Shift + F7智能进入Shift + F8步骤ALT + F9运行到光标Alt + F8计算表达式F9恢复程序Ctrl + F8切换断点Ctrl + Shift + F8查看断点 导航Shift + Esc键隐藏活动或最后一个激活的窗口Ctrl + Shift + F4关闭活动运行/消息/ / …选项卡Ctrl + Shift + Backspace键导航到最后编辑的位置Ctrl + Alt+B 到实施（S）Ctrl + Shift+I 打开快速定义查询Ctrl + U 转到super-method/super-classAlt + Home 组合显示导航栏 书签Ctrl + F11切换书签助记符Ctrl +＃[0-9]转到编号书签Shift + F11显示书签 编辑Ctrl + Q 快速文档查询ALT + INSERT 生成的代码…器（getter，setter方法，构造函数）Ctrl + O 覆盖方法Ctrl + I 实现方法Alt + Enter 显示意图的行动和快速修复Shift + Tab 键缩进/取消缩进选中的行Ctrl + Shift + J 智能线连接（仅适用于HTML和JavaScript）Ctrl + Enter 智能线分割（HTML和JavaScript）Shift + Enter 开始新的生产线Ctrl + Delete 删除字（word）Ctrl + Backspace删除字开始Ctrl +小键盘+ / - 展开/折叠代码块Ctrl + Shift +小键盘+展开全部Ctrl + Shift +数字键盘关闭全部","tags":[{"name":"PHPStrom","slug":"PHPStrom","permalink":"https://wiki.blanc.site/tags/PHPStrom/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"PHPStrom","slug":"2-软件使用/PHPStrom","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/PHPStrom/"}]},{"title":"如何用纯 HTML 区分一个 form 表单中的多个 submit","date":"2017-07-27T00:00:00.000Z","path":"archives/cd7f373a.html","text":"当然可以用 JS 的方法，但是对于初学者来说 JS 函数有些麻烦，在这里我分享两个纯 HTML 区分一个 form 中不同 submit 的方法： 1. 使用不同的 name 属性1.1 前端代码：1234&lt;form method=\"post\"&gt;&lt;input type=\"submit\" name=\"save\" value=\"保存设置\"/&gt;&lt;input type=\"submit\" name=\"reset\" value=\"复位设置\"/&gt;&lt;/form&gt; 1.2 后台验证：123456// PHP 代码if ( $_REQUEST['save'] ) &#123;// ...&#125; elseif ( $_REQUEST['reset'] ) &#123;// ...&#125; 原理：只有被点击的 submit 按钮数据才会被提交 2. 使用相同的 name，不同的 value2.1 前端代码：1234&lt;form method=\"post\"&gt;&lt;input type=\"submit\" name=\"action\" value=\"保存设置\"/&gt;&lt;input type=\"submit\" name=\"action\" value=\"复位设置\"/&gt;&lt;/form&gt; 2.2 后台验证：12345if ( $_REQUEST['action']=='保存设置' ) &#123;// ...&#125; elseif ( $_REQUEST['action']=='复位设置' ) &#123;// ...&#125; 要注意的是方法二中，由于用到了中文，前后台编码要保持一致，否则会导致判断失败。","tags":[],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"HTML","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/HTML","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/HTML/"}]},{"title":"Git 学习笔记","date":"2017-07-25T00:00:00.000Z","path":"archives/3c3cdb74.html","text":"创建版本库什么是版本库呢？版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： 123$ mkdir learngit$ cd learngit$ pwd 把一个文件放到 Git 仓库只需要两步： 第一步，用命令 git add 告诉 Git，把文件添加到仓库： 1$ git add &lt;The file name&gt; 第二步，用命令 git commit 告诉 Git，把文件提交到仓库： 1$ git commit -m \"You can write directions here\" Git时光机要随时掌握工作区的状态，使用 git status 命令。如果 git status 告诉你有文件被修改过，用 git diff` 可以查看修改内容。 HEAD 指向的版本就是当前版本，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100个^比较容易数不过来，所以写成HEAD~100。因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard `。 穿梭前，用 git log 可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用 git reflog 查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区概念以及 add 和 commit 工作原理","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wiki.blanc.site/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Git","slug":"Git","permalink":"https://wiki.blanc.site/tags/Git/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"2-软件使用/命令行工具/Git","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/Git/"}]},{"title":"Linux 系统下不同类型文件默认的颜色","date":"2017-07-05T00:00:00.000Z","path":"archives/1d036a8c.html","text":"白色：表示普通文件蓝色：表示目录绿色：表示可执行文件红色：表示压缩文件浅蓝色：链接文件红色闪烁：表示链接的文件有问题黄色：表示设备文件灰色：表示其它文件","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wiki.blanc.site/tags/Linux/"}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"2-操作系统","slug":"3-计算机科学/2-计算机系统/2-操作系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"3-计算机科学/2-计算机系统/2-操作系统/Linux","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}]},{"title":"适合 Linux 新手的 man page 使用手册","date":"2017-07-04T00:00:00.000Z","path":"archives/ee66e659.html","text":"入门man page 新手入门 什么是 man page（来自 wiki）手册页（英语：Manual pages，缩写 man page）是在 Unix 或类 Unix 操作系统在线软件文档的一种普遍的形式。 内容包括计算机程序（包括库和系统调用），正式的标准和惯例，甚至是抽象的概念。用户可以通过执行 man 命令调用手册页。 什么时候会使用 man page 在使用 Linux 时常常会遇到一些我们不知道具体是什么作用的命令； 想输入某个命令但是只记得命令的某一部分，例如：突然忘记了 date 怎么拼只记得 datX 则可使用 man page 来查找； 想要深入了解某个命令； 如何使用 man page 查询手册：在终端输入：man &lt;要查询的命令（全拼区分大小写）&gt; 模糊匹配：在终端输入：man -k &lt;模糊匹配对象（区分大小写）&gt; 操作快捷键向下翻一页：空格键或 Page Down向上翻一页：Page Up返回首页：Home返回尾页：End向下查询：终端输入：/要查询的字符串向上查询：终端输入：?要查询的字符串结束查询：q 代码输入标准123# man 与要查询的命令之间有空格# 注意：输入是区分大小写的$ man man 知道以上这些就可以开始使用 man page 了，但你可能会在使用的过程中产生这样或那样的疑问，这时你可以继续阅读下面的进阶部分。 进阶 上图为在终端输入：man man 后终端输入的结果，我们以上面这张图片为例来深入的了解 man page 的进阶知识。 man page 中的代号注意图片左上角和右上角的 man(1)，我们知道 man 是命令的名称，那 (1) 又代表什么那？ 它代表的是一般用户可以使用的命令，在查询数据的后面的数字是有意义的。它可以帮助我们了解或者是直接查询相关的资料。常见的几个数字的意义如下图所示： 上表中的1, 5, 8这三个号码特別重要。 man page 中的内容分块通过终端输入：man man 的输出结果图我们能够清楚的看到输出结果的展示页面被几个单词区分为若干块，它们分别代表什么那？请看下表： 有时候除了这些外，还可能会看到 Authors 与 Copyright 等，不过也有很多时候仅有 NAME与DESCRIPTION 等部分。通常鸟哥在查询某个数据时是这样来查阅的： 先察看 NAME 的项目，约略看一下这个数据的意思； 再详看一下 DESCRIPTION，这个部分会提到很多相关的数据与使用时机，从这个地方可以学到很多小细节呢； 而如果这个指令其实很熟悉了（例如上面的 date），那么鸟哥主要就是查询关于 OPTIONS 的部分了！可以知道每个选项的意义，这样就可以下达比较细部的指令内容呢！ 最后，鸟哥会再看一下，跟这个数据有关的还有哪些东西可以使用的？举例来说，上面的 SEE ALSO 就告知我们还可以利用『info coreutils date』来进一步查阅数据； 某些说明内容还会列举有关的档案（FILES 部分）来提供我们参考！这些都是很有帮助的！ man page 中的参数man pge 语法格式：man [ -c -t Section | -k | -f -F -m -MPath -r -a ] Title 在“[]”内的表示可以省略的部分，下面就让我们来了解一下一些主要参数的意义吧： -c ：显示使用 cat 命令的手册信息； -t ：使用 troff 命令格式化手册信息。如果在超文本信息基中查找到手册页面，则忽略该标志。 -k ：显示关键字数据库中包含与作为最终参数给定的字符匹配的标题的字符串的每一行。可以输入多个标题，中间用空格隔开。要使用 -k 标志，root 用户必须以前已输入 catman -w 以建立 /usr/share/man/whatis 文件； -f ：显示在关键字数据库中仅与作为最终参数给定的命令名相关的项。可以输入多个命令名，中间用空格隔开。使用该标志仅搜索命令物件。要使用 -f 标志，root 用户必须以前已输入 catman -w 以建立 /usr/share/man/whatis 文件； -F ：只显示首个匹配项； -m ：只在 MANPATH 或 -M 中指定的路径中搜索； -MPath ：更改 man 命令搜索手册信息的标准位置。路径是用冒号隔开的路径的列表，其中，可以使用以下特殊符号： %D － 联机帮助页的缺省 AIX? 路径。 %L －与当前语言环境的 LC_MESSAGES 类别相对应的特定于语言环境的目录位置。 %L －与当前 LC_MESSAGES 类别的首 2 个字符相对应的特定于语言环境的目录位置； -r ：手册信息的远程搜索。如果出于某个原因，远程搜索失败，则 man 将执行本地搜索以获取请求的联机帮助页； -a ：显示所有匹配项。 一般来说，鸟哥是真的不会去背指令的，只会去记住几个常见的指令而已。那么鸟哥是怎么找到所需要的指令呢？举例来说，打印的相关指令，鸟哥其实仅记得 lp（line print）而已。那我就由 man lp 开始，去找相关的说明，然后，再以 lp [tab] 找到任何以lp为开头的指令，找到我认为可能有点相关的指令后，先以 –help 去查基本的用法，若有需要再以 man 去查询指令的用法！呵呵！所以，如果是实际在管理 Linux，那么真的只要记得几个很重要的指令即可，其他需要的，嘿嘿！努力的找男人（man）吧！ 最后，给大家推荐一个 man 的非常好的网站，linuxmanpages，相当于一个网页版的 Linux 的 man 手册。 到此有关 man page 进阶篇描述也结束了，这也意味着《Linux 之 man page 新手使用手册》到此结束，如果想要继续进阶成为大师就带上你的信心去探索吧。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wiki.blanc.site/tags/Linux/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"U盘安装 Linux distribution 提示 waring /dev/root does not exist","date":"2017-06-30T00:00:00.000Z","path":"archives/8678286b.html","text":"之前也遇到过这种情况只是没有记录下来导致这次遇到的时候又百度了一遍，很麻烦，所以干脆就自己记录下来方便以后查询。 问题描述：U盘安装 CentOS 7 时提示 waring /dev/root does not exist 问题分析：这句错误指令是提醒我们电脑无法读取到U盘，我两次出现这个错误的原因都是因为U盘名字太长或太诡异。 个人解决办法[测试成功]： 第一步用 Windows 系统打开U盘，选择属性，然后更改U盘的盘符标签（要求：尽可能的简短，英文） 第二步进入U盘打开 EFI 文件夹，进入 boot 文件夹，修改 grub.cfg 文件里面的 CentOS\\x207\\x20x86_64 改为刚刚修改的U盘的盘符标签。 OK，处理完成，重启之后就可以安装了。 举一反三：本次问题是出现在安装 CentOS7 的时候，但解决问题的方法不仅仅可以用在这一个问题上，在遇到类似问题时注意联想。","tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://wiki.blanc.site/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"Linux","slug":"Linux","permalink":"https://wiki.blanc.site/tags/Linux/"}],"categories":[{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}]},{"title":"Code::Block 新手配置教程","date":"2017-03-13T00:00:00.000Z","path":"archives/51f295ff.html","text":"1. 前言总有些东西要写在前面 1.1 有关 Code::BlockCode::Blocks 是一个开放源码的全功能的跨平台 C/C++ 集成开发环境。 Code::Blocks 是开放源码软件。Code::Blocks 由纯粹的 C++ 语言开发完成，它使用了著名的图形界面库 wxWidgets 2.6.2 unicode。对于追求完美的 C++ 程序员，再也不必忍受 Eclipse 的缓慢，再也不必忍受 VS.NET 的庞大和高昂的价格。 1.2 为什么要用Code::Block这段时间在网易云上自学 C 语言：老九学堂（吐血安利）。里面的配套编译器就是 Code::Block。 2. 下载各操作系统下载地址： 2.1 Windows XP / Vista / 7 / 8.x / 10:推荐下载：codeblocks-16.01mingw-setup.exe 2.2 Linux：Linux 系统太多而且我也没用过就不推荐了：全部下载地址，需要自取。 2.3 Mac OS X:只有这一个版本：CodeBlocks-13.12-mac.zip 3. 配置包括：汉化-语法高亮-调整字体等常见配置 3.1 汉化3.1.1 先百度下载汉化包3.1.2 替换文件找到你 Codeblocks 的安装根目录，依次进入 share / CodeBlocks 文件夹，解压汉化包，其中的 locale 文件复制到 CodeBlocks 中。 3.1.3 汉化：如果全程你都没有打开 Codeblocks 编译器，这个时候你直接打开即可汉化成功； 反之：打开软件，Settings-Evironment，左边列表选择 View，语言选项改成 Chinese，重启即可完成汉化操作（也可直接关掉再启动 Codeblocks 编译器）。 3.2 语法高亮3.2.1 百度下载配置文件3.2.2 替换配置文件：下载好配置文件，并将其添加到 C:\\Users\\&lt;你的用户名&gt;\\AppData\\Roaming\\CodeBlocks\\（覆盖以前的配置文件）。 注意：在添加这些自定义配置文件之前一定要先将之前的文件配置备份！在添加时一定要确保 Code::Blocks 没有在运行！ 3.2.3 设置语法高亮：添加好配置文件之后，运行 Code::Blocks。打开 setting（设置）=&gt; Editor（编译器）=&gt; Syntax highlighting（语法高亮）=&gt; colour theme（色彩主题），这时你就可以根据个人的品味来选择你喜欢的主题了！补充：当你修改好主题之后，可能会看不到你的光标，其实这是因为你的光标颜色选的不合适。找到 setting（设置）=&gt; Editor（编译器）=&gt; Margins and caret（边界和光标），你就可以修改光标的宽度和颜色了。 3.3 调整字体setting（设置）=&gt; Editor（编译器）=&gt; 常规设置第一个就是字体，点击选择即可调整字体。 3.4 等其实汉化之后很多功能都可以自己去摸索出来，如果大家还有什么比较棘手的问题欢迎在留言区与我讨论，当然亦可以通过邮件联系我。 4. 总思有个东西百度，但还有个东西叫脑子，希望大家遇到问题能多动脑子。","tags":[{"name":"CodeBlock","slug":"CodeBlock","permalink":"https://wiki.blanc.site/tags/CodeBlock/"}],"categories":[{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"CodeBlock","slug":"2-软件使用/CodeBlock","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/CodeBlock/"}]}],"categories":[{"name":"3-计算机科学","slug":"3-计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"3-计算机应用技术","slug":"3-计算机科学/3-计算机应用技术","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"4-人工智能","slug":"3-计算机科学/3-计算机应用技术/4-人工智能","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/4-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"1-网络笔记","slug":"1-网络笔记","permalink":"https://wiki.blanc.site/categories/1-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"},{"name":"1-理论计算机科学","slug":"3-计算机科学/1-理论计算机科学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"4-编程语言和编译器","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Shell","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Shell","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Shell/"},{"name":"2-计算机系统","slug":"3-计算机科学/2-计算机系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"5-计算机安全和密码学","slug":"3-计算机科学/2-计算机系统/5-计算机安全和密码学","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"2-软件使用","slug":"2-软件使用","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"命令行工具","slug":"2-软件使用/命令行工具","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"dmidecode","slug":"2-软件使用/命令行工具/dmidecode","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/dmidecode/"},{"name":"2-操作系统","slug":"3-计算机科学/2-计算机系统/2-操作系统","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"CiscoIOS","slug":"3-计算机科学/2-计算机系统/2-操作系统/CiscoIOS","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CiscoIOS/"},{"name":"汇编语言","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/汇编语言","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"C&CPP","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/C-CPP","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/C-CPP/"},{"name":"1-数据结构和算法","slug":"3-计算机科学/1-理论计算机科学/1-数据结构和算法","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"zsh","slug":"2-软件使用/zsh","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/zsh/"},{"name":"Django","slug":"2-软件使用/Django","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Django/"},{"name":"Python","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Python","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Python/"},{"name":"pyenv","slug":"2-软件使用/命令行工具/pyenv","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/pyenv/"},{"name":"vim","slug":"2-软件使用/命令行工具/vim","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/vim/"},{"name":"6-数据库","slug":"3-计算机科学/2-计算机系统/6-数据库","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"3-计算机科学/2-计算机系统/6-数据库/MongoDB","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"},{"name":"VOX","slug":"2-软件使用/VOX","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/VOX/"},{"name":"TypeScript","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/TypeScript","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/TypeScript/"},{"name":"JetBrains","slug":"2-软件使用/JetBrains","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/JetBrains/"},{"name":"Vue","slug":"2-软件使用/Vue","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Vue/"},{"name":"curl","slug":"2-软件使用/命令行工具/curl","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/curl/"},{"name":"homebrew","slug":"2-软件使用/命令行工具/homebrew","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/homebrew/"},{"name":"pip","slug":"2-软件使用/命令行工具/pip","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/pip/"},{"name":"MySQL","slug":"3-计算机科学/2-计算机系统/6-数据库/MySQL","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/6-%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"macOS","slug":"3-计算机科学/2-计算机系统/2-操作系统/macOS","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/macOS/"},{"name":"Excel","slug":"2-软件使用/Excel","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Excel/"},{"name":"4-软件工程","slug":"3-计算机科学/4-软件工程","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"ZooKeeper","slug":"2-软件使用/ZooKeeper","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ZooKeeper/"},{"name":"tmux","slug":"2-软件使用/命令行工具/tmux","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/tmux/"},{"name":"RESTful","slug":"3-计算机科学/4-软件工程/RESTful","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/RESTful/"},{"name":"Erlang","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/Erlang","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/Erlang/"},{"name":"Linux","slug":"3-计算机科学/2-计算机系统/2-操作系统/Linux","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"},{"name":"VMware","slug":"2-软件使用/VMware","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/VMware/"},{"name":"PHP","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/PHP","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/PHP/"},{"name":"ThinkPHP","slug":"2-软件使用/ThinkPHP","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ThinkPHP/"},{"name":"VSCode","slug":"2-软件使用/VSCode","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/VSCode/"},{"name":"HTML","slug":"3-计算机科学/1-理论计算机科学/4-编程语言和编译器/HTML","permalink":"https://wiki.blanc.site/categories/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/HTML/"},{"name":"WordPress","slug":"2-软件使用/WordPress","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/WordPress/"},{"name":"Chrome","slug":"2-软件使用/Chrome","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Chrome/"},{"name":"Git","slug":"2-软件使用/命令行工具/Git","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/Git/"},{"name":"SublimeText","slug":"2-软件使用/SublimeText","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/SublimeText/"},{"name":"PHPStrom","slug":"2-软件使用/PHPStrom","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/PHPStrom/"},{"name":"CodeBlock","slug":"2-软件使用/CodeBlock","permalink":"https://wiki.blanc.site/categories/2-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/CodeBlock/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://wiki.blanc.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"神经网络","slug":"神经网络","permalink":"https://wiki.blanc.site/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://wiki.blanc.site/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Shell","slug":"Shell","permalink":"https://wiki.blanc.site/tags/Shell/"},{"name":"计算机安全和密码学","slug":"计算机安全和密码学","permalink":"https://wiki.blanc.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"命令行工具","slug":"命令行工具","permalink":"https://wiki.blanc.site/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"dmidecode","slug":"dmidecode","permalink":"https://wiki.blanc.site/tags/dmidecode/"},{"name":"Cisco IOS","slug":"Cisco-IOS","permalink":"https://wiki.blanc.site/tags/Cisco-IOS/"},{"name":"系列文章","slug":"系列文章","permalink":"https://wiki.blanc.site/tags/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://wiki.blanc.site/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"汇编指令","slug":"汇编指令","permalink":"https://wiki.blanc.site/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"},{"name":"CPP","slug":"CPP","permalink":"https://wiki.blanc.site/tags/CPP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wiki.blanc.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"zsh","slug":"zsh","permalink":"https://wiki.blanc.site/tags/zsh/"},{"name":"Django","slug":"Django","permalink":"https://wiki.blanc.site/tags/Django/"},{"name":"异常处理","slug":"异常处理","permalink":"https://wiki.blanc.site/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"MySQL","slug":"MySQL","permalink":"https://wiki.blanc.site/tags/MySQL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://wiki.blanc.site/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"WSGI","slug":"WSGI","permalink":"https://wiki.blanc.site/tags/WSGI/"},{"name":"pyenv","slug":"pyenv","permalink":"https://wiki.blanc.site/tags/pyenv/"},{"name":"vim","slug":"vim","permalink":"https://wiki.blanc.site/tags/vim/"},{"name":"效率工作","slug":"效率工作","permalink":"https://wiki.blanc.site/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E4%BD%9C/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://wiki.blanc.site/tags/MongoDB/"},{"name":"VOX","slug":"VOX","permalink":"https://wiki.blanc.site/tags/VOX/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://wiki.blanc.site/tags/TypeScript/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://wiki.blanc.site/tags/JetBrains/"},{"name":"Vue","slug":"Vue","permalink":"https://wiki.blanc.site/tags/Vue/"},{"name":"科学上网","slug":"科学上网","permalink":"https://wiki.blanc.site/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"包管理器","slug":"包管理器","permalink":"https://wiki.blanc.site/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"curl","slug":"curl","permalink":"https://wiki.blanc.site/tags/curl/"},{"name":"homebrew","slug":"homebrew","permalink":"https://wiki.blanc.site/tags/homebrew/"},{"name":"pip","slug":"pip","permalink":"https://wiki.blanc.site/tags/pip/"},{"name":"macOS","slug":"macOS","permalink":"https://wiki.blanc.site/tags/macOS/"},{"name":"效率","slug":"效率","permalink":"https://wiki.blanc.site/tags/%E6%95%88%E7%8E%87/"},{"name":"鸭子类型","slug":"鸭子类型","permalink":"https://wiki.blanc.site/tags/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"},{"name":"Excel","slug":"Excel","permalink":"https://wiki.blanc.site/tags/Excel/"},{"name":"转载","slug":"转载","permalink":"https://wiki.blanc.site/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"软件工程","slug":"软件工程","permalink":"https://wiki.blanc.site/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"硬件相关","slug":"硬件相关","permalink":"https://wiki.blanc.site/tags/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"内置异常","slug":"内置异常","permalink":"https://wiki.blanc.site/tags/%E5%86%85%E7%BD%AE%E5%BC%82%E5%B8%B8/"},{"name":"环境部署","slug":"环境部署","permalink":"https://wiki.blanc.site/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"Java","slug":"Java","permalink":"https://wiki.blanc.site/tags/Java/"},{"name":"Linux","slug":"Linux","permalink":"https://wiki.blanc.site/tags/Linux/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://wiki.blanc.site/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"单点问题","slug":"单点问题","permalink":"https://wiki.blanc.site/tags/%E5%8D%95%E7%82%B9%E9%97%AE%E9%A2%98/"},{"name":"注册中心","slug":"注册中心","permalink":"https://wiki.blanc.site/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://wiki.blanc.site/tags/ZooKeeper/"},{"name":"tmux","slug":"tmux","permalink":"https://wiki.blanc.site/tags/tmux/"},{"name":"webpack","slug":"webpack","permalink":"https://wiki.blanc.site/tags/webpack/"},{"name":"Python","slug":"Python","permalink":"https://wiki.blanc.site/tags/Python/"},{"name":"RESTful","slug":"RESTful","permalink":"https://wiki.blanc.site/tags/RESTful/"},{"name":"Erlang 程序设计笔记","slug":"Erlang-程序设计笔记","permalink":"https://wiki.blanc.site/tags/Erlang-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"name":"VMware","slug":"VMware","permalink":"https://wiki.blanc.site/tags/VMware/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://wiki.blanc.site/tags/ThinkPHP/"},{"name":"VSCode","slug":"VSCode","permalink":"https://wiki.blanc.site/tags/VSCode/"},{"name":"Node.js","slug":"Node-js","permalink":"https://wiki.blanc.site/tags/Node-js/"},{"name":"Nginx","slug":"Nginx","permalink":"https://wiki.blanc.site/tags/Nginx/"},{"name":"WordPress","slug":"WordPress","permalink":"https://wiki.blanc.site/tags/WordPress/"},{"name":"图像处理","slug":"图像处理","permalink":"https://wiki.blanc.site/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"计算机安全","slug":"计算机安全","permalink":"https://wiki.blanc.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"},{"name":"Chrome","slug":"Chrome","permalink":"https://wiki.blanc.site/tags/Chrome/"},{"name":"Git","slug":"Git","permalink":"https://wiki.blanc.site/tags/Git/"},{"name":"SublimeText","slug":"SublimeText","permalink":"https://wiki.blanc.site/tags/SublimeText/"},{"name":"PHPStrom","slug":"PHPStrom","permalink":"https://wiki.blanc.site/tags/PHPStrom/"},{"name":"CodeBlock","slug":"CodeBlock","permalink":"https://wiki.blanc.site/tags/CodeBlock/"}]}